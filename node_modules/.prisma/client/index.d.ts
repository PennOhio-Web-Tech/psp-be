
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Organization
 * 
 */
export type Organization = {
  id: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  firstName: string
  lastName: string
  initials: string
  email: string
  password: string
  organizationId: string | null
  roleId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: number
  type: string
}

/**
 * Model OrganizationAccess
 * 
 */
export type OrganizationAccess = {
  organizationId: string
  userId: string
  read: boolean
  write: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Engagement
 * 
 */
export type Engagement = {
  id: string
  organizationId: string
  userId: string
  createdAt: Date
  updatedAt: Date
  locationId: string | null
  demographicId: string
  engagementDetailId: string
  status: string
  crossFunctionalTeamId: number
  requestorId: string
  shortId: string | null
  feedbackConfigId: string | null
  isDeleted: boolean
  statusChangedOn: Date | null
}

/**
 * Model Location
 * 
 */
export type Location = {
  id: string
  addressOne: string
  addressTwo: string | null
  city: string
  state: string
  zip: number
}

/**
 * Model EngagementDetail
 * 
 */
export type EngagementDetail = {
  id: string
  title: string
  summary: string
  description: string
  associatedProgram: string
  armyImpact: string
  fundingDetails: string | null
  otherInformation: string | null
}

/**
 * Model CrossFunctionalTeams
 * 
 */
export type CrossFunctionalTeams = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Demographic
 * 
 */
export type Demographic = {
  id: string
  soldierInput: string
  soldiersNeeded: number
  mos: string
}

/**
 * Model Requirement
 * 
 */
export type Requirement = {
  id: string
  content: string
}

/**
 * Model RequestorInformation
 * 
 */
export type RequestorInformation = {
  id: string
  name: string
  organization: string
  title: string
  email: string
  phone: string
}

/**
 * Model Event
 * 
 */
export type Event = {
  id: string
  startDate: Date
  endDate: Date
  title: string
  description: string
  engagementId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DueDate
 * 
 */
export type DueDate = {
  id: string
  title: string
  dueDate: Date
  engagementId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FeedbackConfig
 * 
 */
export type FeedbackConfig = {
  id: string
  feedbackType: FeedbackTypes
  isHumanResearch: boolean
  hasSubmissions: boolean
  freeFormQuestion: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TestFeedbackSubmission
 * 
 */
export type TestFeedbackSubmission = {
  id: string
  feedbackConfigId: string
  rating: string
  testFeedbackResponseId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TestFeedbackResponses
 * 
 */
export type TestFeedbackResponses = {
  id: string
  startDate: Date
  endDate: Date | null
  customResponse: string | null
  results: string
  anticipatedResults: string
  conditionsConstraints: string
  metExpectations: string
  notMetExpectations: string
  otherOpportunities: string
  additionalThoughts: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model InputFeedbackSubmission
 * 
 */
export type InputFeedbackSubmission = {
  id: string
  feedbackConfigId: string
  inputFeedbackResponseId: string
  rating: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model InputFeedbackResponses
 * 
 */
export type InputFeedbackResponses = {
  id: string
  startDate: Date
  endDate: Date | null
  customResponse: string | null
  opportunities: string
  processSolution: string
  notAsked: string
  responseViews: string
  additionalThoughts: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model FreeFeedbackSubmission
 * 
 */
export type FreeFeedbackSubmission = {
  id: string
  feedbackConfigId: string
  freeFeedbackResponseId: string
  createdAt: Date
  updatedAt: Date
  rating: string
}

/**
 * Model FreeFeedbackResponses
 * 
 */
export type FreeFeedbackResponses = {
  id: string
  startDate: Date
  endDate: Date | null
  response: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model File
 * 
 */
export type File = {
  id: string
  engagementId: string | null
  engagementDraftId: string | null
  blobName: string
  containerName: string
  path: string
}

/**
 * Model EngagementDraft
 * 
 */
export type EngagementDraft = {
  id: string
  userId: string
  engagementTitle: string | null
  engagementSummary: string | null
  associatedProgram: string | null
  soldierInput: string | null
  soldiersNeeded: string | null
  preferredDivision: string | null
  mos: string | null
  requirements: string[]
  armyImpact: string | null
  cft: number | null
  engagementRequest: string | null
  feedbackType: string | null
  eventStartDate: Date | null
  eventEndDate: Date | null
  eventTitle: string | null
  eventDescription: string | null
  dueDate: Date | null
  dueDateTitle: string | null
  addressOne: string | null
  addressTwo: string | null
  city: string | null
  state: string | null
  zip: string | null
  funding: string | null
  otherInfo: string | null
  requestorName: string | null
  requestorEmail: string | null
  requestorPhone: string | null
  requestorTitle: string | null
  requestorOrganization: string | null
  freeFormQuestion: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const FeedbackTypes: {
  testFeedbackSubmission: 'testFeedbackSubmission',
  freeFeedbackSubmission: 'freeFeedbackSubmission',
  inputFeedbackSubmission: 'inputFeedbackSubmission'
};

export type FeedbackTypes = (typeof FeedbackTypes)[keyof typeof FeedbackTypes]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.organizationAccess`: Exposes CRUD operations for the **OrganizationAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationAccesses
    * const organizationAccesses = await prisma.organizationAccess.findMany()
    * ```
    */
  get organizationAccess(): Prisma.OrganizationAccessDelegate<GlobalReject>;

  /**
   * `prisma.engagement`: Exposes CRUD operations for the **Engagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Engagements
    * const engagements = await prisma.engagement.findMany()
    * ```
    */
  get engagement(): Prisma.EngagementDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<GlobalReject>;

  /**
   * `prisma.engagementDetail`: Exposes CRUD operations for the **EngagementDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EngagementDetails
    * const engagementDetails = await prisma.engagementDetail.findMany()
    * ```
    */
  get engagementDetail(): Prisma.EngagementDetailDelegate<GlobalReject>;

  /**
   * `prisma.crossFunctionalTeams`: Exposes CRUD operations for the **CrossFunctionalTeams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrossFunctionalTeams
    * const crossFunctionalTeams = await prisma.crossFunctionalTeams.findMany()
    * ```
    */
  get crossFunctionalTeams(): Prisma.CrossFunctionalTeamsDelegate<GlobalReject>;

  /**
   * `prisma.demographic`: Exposes CRUD operations for the **Demographic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demographics
    * const demographics = await prisma.demographic.findMany()
    * ```
    */
  get demographic(): Prisma.DemographicDelegate<GlobalReject>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirement.findMany()
    * ```
    */
  get requirement(): Prisma.RequirementDelegate<GlobalReject>;

  /**
   * `prisma.requestorInformation`: Exposes CRUD operations for the **RequestorInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestorInformations
    * const requestorInformations = await prisma.requestorInformation.findMany()
    * ```
    */
  get requestorInformation(): Prisma.RequestorInformationDelegate<GlobalReject>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject>;

  /**
   * `prisma.dueDate`: Exposes CRUD operations for the **DueDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DueDates
    * const dueDates = await prisma.dueDate.findMany()
    * ```
    */
  get dueDate(): Prisma.DueDateDelegate<GlobalReject>;

  /**
   * `prisma.feedbackConfig`: Exposes CRUD operations for the **FeedbackConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackConfigs
    * const feedbackConfigs = await prisma.feedbackConfig.findMany()
    * ```
    */
  get feedbackConfig(): Prisma.FeedbackConfigDelegate<GlobalReject>;

  /**
   * `prisma.testFeedbackSubmission`: Exposes CRUD operations for the **TestFeedbackSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestFeedbackSubmissions
    * const testFeedbackSubmissions = await prisma.testFeedbackSubmission.findMany()
    * ```
    */
  get testFeedbackSubmission(): Prisma.TestFeedbackSubmissionDelegate<GlobalReject>;

  /**
   * `prisma.testFeedbackResponses`: Exposes CRUD operations for the **TestFeedbackResponses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestFeedbackResponses
    * const testFeedbackResponses = await prisma.testFeedbackResponses.findMany()
    * ```
    */
  get testFeedbackResponses(): Prisma.TestFeedbackResponsesDelegate<GlobalReject>;

  /**
   * `prisma.inputFeedbackSubmission`: Exposes CRUD operations for the **InputFeedbackSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InputFeedbackSubmissions
    * const inputFeedbackSubmissions = await prisma.inputFeedbackSubmission.findMany()
    * ```
    */
  get inputFeedbackSubmission(): Prisma.InputFeedbackSubmissionDelegate<GlobalReject>;

  /**
   * `prisma.inputFeedbackResponses`: Exposes CRUD operations for the **InputFeedbackResponses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InputFeedbackResponses
    * const inputFeedbackResponses = await prisma.inputFeedbackResponses.findMany()
    * ```
    */
  get inputFeedbackResponses(): Prisma.InputFeedbackResponsesDelegate<GlobalReject>;

  /**
   * `prisma.freeFeedbackSubmission`: Exposes CRUD operations for the **FreeFeedbackSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreeFeedbackSubmissions
    * const freeFeedbackSubmissions = await prisma.freeFeedbackSubmission.findMany()
    * ```
    */
  get freeFeedbackSubmission(): Prisma.FreeFeedbackSubmissionDelegate<GlobalReject>;

  /**
   * `prisma.freeFeedbackResponses`: Exposes CRUD operations for the **FreeFeedbackResponses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreeFeedbackResponses
    * const freeFeedbackResponses = await prisma.freeFeedbackResponses.findMany()
    * ```
    */
  get freeFeedbackResponses(): Prisma.FreeFeedbackResponsesDelegate<GlobalReject>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<GlobalReject>;

  /**
   * `prisma.engagementDraft`: Exposes CRUD operations for the **EngagementDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EngagementDrafts
    * const engagementDrafts = await prisma.engagementDraft.findMany()
    * ```
    */
  get engagementDraft(): Prisma.EngagementDraftDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.12.0
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    Role: 'Role',
    OrganizationAccess: 'OrganizationAccess',
    Engagement: 'Engagement',
    Location: 'Location',
    EngagementDetail: 'EngagementDetail',
    CrossFunctionalTeams: 'CrossFunctionalTeams',
    Demographic: 'Demographic',
    Requirement: 'Requirement',
    RequestorInformation: 'RequestorInformation',
    Event: 'Event',
    DueDate: 'DueDate',
    FeedbackConfig: 'FeedbackConfig',
    TestFeedbackSubmission: 'TestFeedbackSubmission',
    TestFeedbackResponses: 'TestFeedbackResponses',
    InputFeedbackSubmission: 'InputFeedbackSubmission',
    InputFeedbackResponses: 'InputFeedbackResponses',
    FreeFeedbackSubmission: 'FreeFeedbackSubmission',
    FreeFeedbackResponses: 'FreeFeedbackResponses',
    File: 'File',
    EngagementDraft: 'EngagementDraft'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */


  export type OrganizationCountOutputType = {
    user: number
    engagement: number
    organizationAccess: number
  }

  export type OrganizationCountOutputTypeSelect = {
    user?: boolean
    engagement?: boolean
    organizationAccess?: boolean
  }

  export type OrganizationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrganizationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrganizationCountOutputType
    : S extends undefined
    ? never
    : S extends OrganizationCountOutputTypeArgs
    ?'include' extends U
    ? OrganizationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrganizationCountOutputType ? OrganizationCountOutputType[P] : never
  } 
    : OrganizationCountOutputType
  : OrganizationCountOutputType




  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     * 
    **/
    select?: OrganizationCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    engagement: number
    organizationAccess: number
    EngagementDraft: number
  }

  export type UserCountOutputTypeSelect = {
    engagement?: boolean
    organizationAccess?: boolean
    EngagementDraft?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect = {
    users?: boolean
  }

  export type RoleCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RoleCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RoleCountOutputType
    : S extends undefined
    ? never
    : S extends RoleCountOutputTypeArgs
    ?'include' extends U
    ? RoleCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
    : RoleCountOutputType
  : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     * 
    **/
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type EngagementCountOutputType
   */


  export type EngagementCountOutputType = {
    events: number
    dueDates: number
    files: number
  }

  export type EngagementCountOutputTypeSelect = {
    events?: boolean
    dueDates?: boolean
    files?: boolean
  }

  export type EngagementCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EngagementCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EngagementCountOutputType
    : S extends undefined
    ? never
    : S extends EngagementCountOutputTypeArgs
    ?'include' extends U
    ? EngagementCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EngagementCountOutputType ? EngagementCountOutputType[P] : never
  } 
    : EngagementCountOutputType
  : EngagementCountOutputType




  // Custom InputTypes

  /**
   * EngagementCountOutputType without action
   */
  export type EngagementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EngagementCountOutputType
     * 
    **/
    select?: EngagementCountOutputTypeSelect | null
  }



  /**
   * Count Type CrossFunctionalTeamsCountOutputType
   */


  export type CrossFunctionalTeamsCountOutputType = {
    engagements: number
  }

  export type CrossFunctionalTeamsCountOutputTypeSelect = {
    engagements?: boolean
  }

  export type CrossFunctionalTeamsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CrossFunctionalTeamsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CrossFunctionalTeamsCountOutputType
    : S extends undefined
    ? never
    : S extends CrossFunctionalTeamsCountOutputTypeArgs
    ?'include' extends U
    ? CrossFunctionalTeamsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CrossFunctionalTeamsCountOutputType ? CrossFunctionalTeamsCountOutputType[P] : never
  } 
    : CrossFunctionalTeamsCountOutputType
  : CrossFunctionalTeamsCountOutputType




  // Custom InputTypes

  /**
   * CrossFunctionalTeamsCountOutputType without action
   */
  export type CrossFunctionalTeamsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeamsCountOutputType
     * 
    **/
    select?: CrossFunctionalTeamsCountOutputTypeSelect | null
  }



  /**
   * Count Type DemographicCountOutputType
   */


  export type DemographicCountOutputType = {
    requirements: number
  }

  export type DemographicCountOutputTypeSelect = {
    requirements?: boolean
  }

  export type DemographicCountOutputTypeGetPayload<
    S extends boolean | null | undefined | DemographicCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? DemographicCountOutputType
    : S extends undefined
    ? never
    : S extends DemographicCountOutputTypeArgs
    ?'include' extends U
    ? DemographicCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof DemographicCountOutputType ? DemographicCountOutputType[P] : never
  } 
    : DemographicCountOutputType
  : DemographicCountOutputType




  // Custom InputTypes

  /**
   * DemographicCountOutputType without action
   */
  export type DemographicCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DemographicCountOutputType
     * 
    **/
    select?: DemographicCountOutputTypeSelect | null
  }



  /**
   * Count Type RequirementCountOutputType
   */


  export type RequirementCountOutputType = {
    demographics: number
  }

  export type RequirementCountOutputTypeSelect = {
    demographics?: boolean
  }

  export type RequirementCountOutputTypeGetPayload<
    S extends boolean | null | undefined | RequirementCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? RequirementCountOutputType
    : S extends undefined
    ? never
    : S extends RequirementCountOutputTypeArgs
    ?'include' extends U
    ? RequirementCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RequirementCountOutputType ? RequirementCountOutputType[P] : never
  } 
    : RequirementCountOutputType
  : RequirementCountOutputType




  // Custom InputTypes

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RequirementCountOutputType
     * 
    **/
    select?: RequirementCountOutputTypeSelect | null
  }



  /**
   * Count Type FeedbackConfigCountOutputType
   */


  export type FeedbackConfigCountOutputType = {
    testFeedbackSubmissions: number
    inputFeedbackSubmissions: number
    freeFeedbackSubmissions: number
  }

  export type FeedbackConfigCountOutputTypeSelect = {
    testFeedbackSubmissions?: boolean
    inputFeedbackSubmissions?: boolean
    freeFeedbackSubmissions?: boolean
  }

  export type FeedbackConfigCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FeedbackConfigCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FeedbackConfigCountOutputType
    : S extends undefined
    ? never
    : S extends FeedbackConfigCountOutputTypeArgs
    ?'include' extends U
    ? FeedbackConfigCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FeedbackConfigCountOutputType ? FeedbackConfigCountOutputType[P] : never
  } 
    : FeedbackConfigCountOutputType
  : FeedbackConfigCountOutputType




  // Custom InputTypes

  /**
   * FeedbackConfigCountOutputType without action
   */
  export type FeedbackConfigCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfigCountOutputType
     * 
    **/
    select?: FeedbackConfigCountOutputTypeSelect | null
  }



  /**
   * Count Type EngagementDraftCountOutputType
   */


  export type EngagementDraftCountOutputType = {
    files: number
  }

  export type EngagementDraftCountOutputTypeSelect = {
    files?: boolean
  }

  export type EngagementDraftCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EngagementDraftCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EngagementDraftCountOutputType
    : S extends undefined
    ? never
    : S extends EngagementDraftCountOutputTypeArgs
    ?'include' extends U
    ? EngagementDraftCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EngagementDraftCountOutputType ? EngagementDraftCountOutputType[P] : never
  } 
    : EngagementDraftCountOutputType
  : EngagementDraftCountOutputType




  // Custom InputTypes

  /**
   * EngagementDraftCountOutputType without action
   */
  export type EngagementDraftCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraftCountOutputType
     * 
    **/
    select?: EngagementDraftCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Organization
   */


  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs = {
    /**
     * Filter which Organization to aggregate.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs = {
    where?: OrganizationWhereInput
    orderBy?: Enumerable<OrganizationOrderByWithAggregationInput>
    by: Array<OrganizationScalarFieldEnum>
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }


  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect = {
    id?: boolean
    name?: boolean
    user?: boolean | UserFindManyArgs
    engagement?: boolean | EngagementFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    organizationAccess?: boolean | OrganizationAccessFindManyArgs
    _count?: boolean | OrganizationCountOutputTypeArgs
  }

  export type OrganizationInclude = {
    user?: boolean | UserFindManyArgs
    engagement?: boolean | EngagementFindManyArgs
    organizationAccess?: boolean | OrganizationAccessFindManyArgs
    _count?: boolean | OrganizationCountOutputTypeArgs
  }

  export type OrganizationGetPayload<
    S extends boolean | null | undefined | OrganizationArgs,
    U = keyof S
      > = S extends true
        ? Organization
    : S extends undefined
    ? never
    : S extends OrganizationArgs | OrganizationFindManyArgs
    ?'include' extends U
    ? Organization  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'engagement' ? Array < EngagementGetPayload<S['include'][P]>>  :
        P extends 'organizationAccess' ? Array < OrganizationAccessGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'engagement' ? Array < EngagementGetPayload<S['select'][P]>>  :
        P extends 'organizationAccess' ? Array < OrganizationAccessGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganizationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Organization ? Organization[P] : never
  } 
    : Organization
  : Organization


  type OrganizationCountArgs = Merge<
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }
  >

  export interface OrganizationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Organization'> extends True ? CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationClient<Organization | null >, Prisma__OrganizationClient<OrganizationGetPayload<T> | null >>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Organization'> extends True ? CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationClient<Organization | null >, Prisma__OrganizationClient<OrganizationGetPayload<T> | null >>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Organization>>, PrismaPromise<Array<OrganizationGetPayload<T>>>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs>
    ): CheckSelect<T, Prisma__OrganizationClient<Organization>, Prisma__OrganizationClient<OrganizationGetPayload<T>>>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    engagement<T extends EngagementFindManyArgs = {}>(args?: Subset<T, EngagementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Engagement>>, PrismaPromise<Array<EngagementGetPayload<T>>>>;

    organizationAccess<T extends OrganizationAccessFindManyArgs = {}>(args?: Subset<T, OrganizationAccessFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrganizationAccess>>, PrismaPromise<Array<OrganizationAccessGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Throw an Error if a Organization can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Organization to fetch.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Throw an Error if a Organization can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Organization to fetch.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     * 
    **/
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter, which Organizations to fetch.
     * 
    **/
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     * 
    **/
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganizationScalarFieldEnum>
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The data needed to create a Organization.
     * 
    **/
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs = {
    /**
     * The data used to create many Organizations.
     * 
    **/
    data: Enumerable<OrganizationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The data needed to update a Organization.
     * 
    **/
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs = {
    /**
     * The data used to update Organizations.
     * 
    **/
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     * 
    **/
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * The filter to search for the Organization to update in case it exists.
     * 
    **/
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     * 
    **/
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
    /**
     * Filter which Organization to delete.
     * 
    **/
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs = {
    /**
     * Filter which Organizations to delete
     * 
    **/
    where?: OrganizationWhereInput
  }


  /**
   * Organization without action
   */
  export type OrganizationArgs = {
    /**
     * Select specific fields to fetch from the Organization
     * 
    **/
    select?: OrganizationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    initials: string | null
    email: string | null
    password: string | null
    organizationId: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    initials: string | null
    email: string | null
    password: string | null
    organizationId: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    initials: number
    email: number
    password: number
    organizationId: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    initials?: true
    email?: true
    password?: true
    organizationId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    initials?: true
    email?: true
    password?: true
    organizationId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    initials?: true
    email?: true
    password?: true
    organizationId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId: string | null
    roleId: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    initials?: boolean
    email?: boolean
    password?: boolean
    organization?: boolean | OrganizationArgs
    organizationId?: boolean
    role?: boolean | RoleArgs
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    engagement?: boolean | EngagementFindManyArgs
    organizationAccess?: boolean | OrganizationAccessFindManyArgs
    EngagementDraft?: boolean | EngagementDraftFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    organization?: boolean | OrganizationArgs
    role?: boolean | RoleArgs
    engagement?: boolean | EngagementFindManyArgs
    organizationAccess?: boolean | OrganizationAccessFindManyArgs
    EngagementDraft?: boolean | EngagementDraftFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> | null :
        P extends 'role' ? RoleGetPayload<S['include'][P]> :
        P extends 'engagement' ? Array < EngagementGetPayload<S['include'][P]>>  :
        P extends 'organizationAccess' ? Array < OrganizationAccessGetPayload<S['include'][P]>>  :
        P extends 'EngagementDraft' ? Array < EngagementDraftGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> | null :
        P extends 'role' ? RoleGetPayload<S['select'][P]> :
        P extends 'engagement' ? Array < EngagementGetPayload<S['select'][P]>>  :
        P extends 'organizationAccess' ? Array < OrganizationAccessGetPayload<S['select'][P]>>  :
        P extends 'EngagementDraft' ? Array < EngagementDraftGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | null >, Prisma__OrganizationClient<OrganizationGetPayload<T> | null >>;

    role<T extends RoleArgs = {}>(args?: Subset<T, RoleArgs>): CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>;

    engagement<T extends EngagementFindManyArgs = {}>(args?: Subset<T, EngagementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Engagement>>, PrismaPromise<Array<EngagementGetPayload<T>>>>;

    organizationAccess<T extends OrganizationAccessFindManyArgs = {}>(args?: Subset<T, OrganizationAccessFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrganizationAccess>>, PrismaPromise<Array<OrganizationAccessGetPayload<T>>>>;

    EngagementDraft<T extends EngagementDraftFindManyArgs = {}>(args?: Subset<T, EngagementDraftFindManyArgs>): CheckSelect<T, PrismaPromise<Array<EngagementDraft>>, PrismaPromise<Array<EngagementDraftGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: Array<RoleScalarFieldEnum>
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    type: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    type?: boolean
    users?: boolean | UserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleInclude = {
    users?: boolean | UserFindManyArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     * 
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     * 
    **/
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     * 
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     * 
    **/
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     * 
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     * 
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     * 
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     * 
    **/
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     * 
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RoleInclude | null
  }



  /**
   * Model OrganizationAccess
   */


  export type AggregateOrganizationAccess = {
    _count: OrganizationAccessCountAggregateOutputType | null
    _min: OrganizationAccessMinAggregateOutputType | null
    _max: OrganizationAccessMaxAggregateOutputType | null
  }

  export type OrganizationAccessMinAggregateOutputType = {
    organizationId: string | null
    userId: string | null
    read: boolean | null
    write: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationAccessMaxAggregateOutputType = {
    organizationId: string | null
    userId: string | null
    read: boolean | null
    write: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationAccessCountAggregateOutputType = {
    organizationId: number
    userId: number
    read: number
    write: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAccessMinAggregateInputType = {
    organizationId?: true
    userId?: true
    read?: true
    write?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationAccessMaxAggregateInputType = {
    organizationId?: true
    userId?: true
    read?: true
    write?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationAccessCountAggregateInputType = {
    organizationId?: true
    userId?: true
    read?: true
    write?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAccessAggregateArgs = {
    /**
     * Filter which OrganizationAccess to aggregate.
     * 
    **/
    where?: OrganizationAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrganizationAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationAccesses
    **/
    _count?: true | OrganizationAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationAccessMaxAggregateInputType
  }

  export type GetOrganizationAccessAggregateType<T extends OrganizationAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationAccess[P]>
      : GetScalarType<T[P], AggregateOrganizationAccess[P]>
  }




  export type OrganizationAccessGroupByArgs = {
    where?: OrganizationAccessWhereInput
    orderBy?: Enumerable<OrganizationAccessOrderByWithAggregationInput>
    by: Array<OrganizationAccessScalarFieldEnum>
    having?: OrganizationAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationAccessCountAggregateInputType | true
    _min?: OrganizationAccessMinAggregateInputType
    _max?: OrganizationAccessMaxAggregateInputType
  }


  export type OrganizationAccessGroupByOutputType = {
    organizationId: string
    userId: string
    read: boolean
    write: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrganizationAccessCountAggregateOutputType | null
    _min: OrganizationAccessMinAggregateOutputType | null
    _max: OrganizationAccessMaxAggregateOutputType | null
  }

  type GetOrganizationAccessGroupByPayload<T extends OrganizationAccessGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationAccessGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationAccessGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationAccessSelect = {
    organization?: boolean | OrganizationArgs
    organizationId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    read?: boolean
    write?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationAccessInclude = {
    organization?: boolean | OrganizationArgs
    user?: boolean | UserArgs
  }

  export type OrganizationAccessGetPayload<
    S extends boolean | null | undefined | OrganizationAccessArgs,
    U = keyof S
      > = S extends true
        ? OrganizationAccess
    : S extends undefined
    ? never
    : S extends OrganizationAccessArgs | OrganizationAccessFindManyArgs
    ?'include' extends U
    ? OrganizationAccess  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof OrganizationAccess ? OrganizationAccess[P] : never
  } 
    : OrganizationAccess
  : OrganizationAccess


  type OrganizationAccessCountArgs = Merge<
    Omit<OrganizationAccessFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationAccessCountAggregateInputType | true
    }
  >

  export interface OrganizationAccessDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrganizationAccess that matches the filter.
     * @param {OrganizationAccessFindUniqueArgs} args - Arguments to find a OrganizationAccess
     * @example
     * // Get one OrganizationAccess
     * const organizationAccess = await prisma.organizationAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationAccessFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrganizationAccessFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrganizationAccess'> extends True ? CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess | null >, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T> | null >>

    /**
     * Find the first OrganizationAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessFindFirstArgs} args - Arguments to find a OrganizationAccess
     * @example
     * // Get one OrganizationAccess
     * const organizationAccess = await prisma.organizationAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationAccessFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrganizationAccessFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrganizationAccess'> extends True ? CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>> : CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess | null >, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T> | null >>

    /**
     * Find zero or more OrganizationAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationAccesses
     * const organizationAccesses = await prisma.organizationAccess.findMany()
     * 
     * // Get first 10 OrganizationAccesses
     * const organizationAccesses = await prisma.organizationAccess.findMany({ take: 10 })
     * 
     * // Only select the `organizationId`
     * const organizationAccessWithOrganizationIdOnly = await prisma.organizationAccess.findMany({ select: { organizationId: true } })
     * 
    **/
    findMany<T extends OrganizationAccessFindManyArgs>(
      args?: SelectSubset<T, OrganizationAccessFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrganizationAccess>>, PrismaPromise<Array<OrganizationAccessGetPayload<T>>>>

    /**
     * Create a OrganizationAccess.
     * @param {OrganizationAccessCreateArgs} args - Arguments to create a OrganizationAccess.
     * @example
     * // Create one OrganizationAccess
     * const OrganizationAccess = await prisma.organizationAccess.create({
     *   data: {
     *     // ... data to create a OrganizationAccess
     *   }
     * })
     * 
    **/
    create<T extends OrganizationAccessCreateArgs>(
      args: SelectSubset<T, OrganizationAccessCreateArgs>
    ): CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>>

    /**
     * Create many OrganizationAccesses.
     *     @param {OrganizationAccessCreateManyArgs} args - Arguments to create many OrganizationAccesses.
     *     @example
     *     // Create many OrganizationAccesses
     *     const organizationAccess = await prisma.organizationAccess.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationAccessCreateManyArgs>(
      args?: SelectSubset<T, OrganizationAccessCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationAccess.
     * @param {OrganizationAccessDeleteArgs} args - Arguments to delete one OrganizationAccess.
     * @example
     * // Delete one OrganizationAccess
     * const OrganizationAccess = await prisma.organizationAccess.delete({
     *   where: {
     *     // ... filter to delete one OrganizationAccess
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationAccessDeleteArgs>(
      args: SelectSubset<T, OrganizationAccessDeleteArgs>
    ): CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>>

    /**
     * Update one OrganizationAccess.
     * @param {OrganizationAccessUpdateArgs} args - Arguments to update one OrganizationAccess.
     * @example
     * // Update one OrganizationAccess
     * const organizationAccess = await prisma.organizationAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationAccessUpdateArgs>(
      args: SelectSubset<T, OrganizationAccessUpdateArgs>
    ): CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>>

    /**
     * Delete zero or more OrganizationAccesses.
     * @param {OrganizationAccessDeleteManyArgs} args - Arguments to filter OrganizationAccesses to delete.
     * @example
     * // Delete a few OrganizationAccesses
     * const { count } = await prisma.organizationAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationAccessDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationAccessDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationAccesses
     * const organizationAccess = await prisma.organizationAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationAccessUpdateManyArgs>(
      args: SelectSubset<T, OrganizationAccessUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationAccess.
     * @param {OrganizationAccessUpsertArgs} args - Arguments to update or create a OrganizationAccess.
     * @example
     * // Update or create a OrganizationAccess
     * const organizationAccess = await prisma.organizationAccess.upsert({
     *   create: {
     *     // ... data to create a OrganizationAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationAccess we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationAccessUpsertArgs>(
      args: SelectSubset<T, OrganizationAccessUpsertArgs>
    ): CheckSelect<T, Prisma__OrganizationAccessClient<OrganizationAccess>, Prisma__OrganizationAccessClient<OrganizationAccessGetPayload<T>>>

    /**
     * Count the number of OrganizationAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessCountArgs} args - Arguments to filter OrganizationAccesses to count.
     * @example
     * // Count the number of OrganizationAccesses
     * const count = await prisma.organizationAccess.count({
     *   where: {
     *     // ... the filter for the OrganizationAccesses we want to count
     *   }
     * })
    **/
    count<T extends OrganizationAccessCountArgs>(
      args?: Subset<T, OrganizationAccessCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAccessAggregateArgs>(args: Subset<T, OrganizationAccessAggregateArgs>): PrismaPromise<GetOrganizationAccessAggregateType<T>>

    /**
     * Group by OrganizationAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationAccessGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationAccessGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationAccessClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | null >, Prisma__OrganizationClient<OrganizationGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrganizationAccess findUnique
   */
  export type OrganizationAccessFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * Throw an Error if a OrganizationAccess can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrganizationAccess to fetch.
     * 
    **/
    where: OrganizationAccessWhereUniqueInput
  }


  /**
   * OrganizationAccess findFirst
   */
  export type OrganizationAccessFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * Throw an Error if a OrganizationAccess can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrganizationAccess to fetch.
     * 
    **/
    where?: OrganizationAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationAccesses.
     * 
    **/
    cursor?: OrganizationAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationAccesses.
     * 
    **/
    distinct?: Enumerable<OrganizationAccessScalarFieldEnum>
  }


  /**
   * OrganizationAccess findMany
   */
  export type OrganizationAccessFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * Filter, which OrganizationAccesses to fetch.
     * 
    **/
    where?: OrganizationAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<OrganizationAccessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationAccesses.
     * 
    **/
    cursor?: OrganizationAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationAccesses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganizationAccessScalarFieldEnum>
  }


  /**
   * OrganizationAccess create
   */
  export type OrganizationAccessCreateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * The data needed to create a OrganizationAccess.
     * 
    **/
    data: XOR<OrganizationAccessCreateInput, OrganizationAccessUncheckedCreateInput>
  }


  /**
   * OrganizationAccess createMany
   */
  export type OrganizationAccessCreateManyArgs = {
    /**
     * The data used to create many OrganizationAccesses.
     * 
    **/
    data: Enumerable<OrganizationAccessCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrganizationAccess update
   */
  export type OrganizationAccessUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * The data needed to update a OrganizationAccess.
     * 
    **/
    data: XOR<OrganizationAccessUpdateInput, OrganizationAccessUncheckedUpdateInput>
    /**
     * Choose, which OrganizationAccess to update.
     * 
    **/
    where: OrganizationAccessWhereUniqueInput
  }


  /**
   * OrganizationAccess updateMany
   */
  export type OrganizationAccessUpdateManyArgs = {
    /**
     * The data used to update OrganizationAccesses.
     * 
    **/
    data: XOR<OrganizationAccessUpdateManyMutationInput, OrganizationAccessUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationAccesses to update
     * 
    **/
    where?: OrganizationAccessWhereInput
  }


  /**
   * OrganizationAccess upsert
   */
  export type OrganizationAccessUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * The filter to search for the OrganizationAccess to update in case it exists.
     * 
    **/
    where: OrganizationAccessWhereUniqueInput
    /**
     * In case the OrganizationAccess found by the `where` argument doesn't exist, create a new OrganizationAccess with this data.
     * 
    **/
    create: XOR<OrganizationAccessCreateInput, OrganizationAccessUncheckedCreateInput>
    /**
     * In case the OrganizationAccess was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrganizationAccessUpdateInput, OrganizationAccessUncheckedUpdateInput>
  }


  /**
   * OrganizationAccess delete
   */
  export type OrganizationAccessDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
    /**
     * Filter which OrganizationAccess to delete.
     * 
    **/
    where: OrganizationAccessWhereUniqueInput
  }


  /**
   * OrganizationAccess deleteMany
   */
  export type OrganizationAccessDeleteManyArgs = {
    /**
     * Filter which OrganizationAccesses to delete
     * 
    **/
    where?: OrganizationAccessWhereInput
  }


  /**
   * OrganizationAccess without action
   */
  export type OrganizationAccessArgs = {
    /**
     * Select specific fields to fetch from the OrganizationAccess
     * 
    **/
    select?: OrganizationAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrganizationAccessInclude | null
  }



  /**
   * Model Engagement
   */


  export type AggregateEngagement = {
    _count: EngagementCountAggregateOutputType | null
    _avg: EngagementAvgAggregateOutputType | null
    _sum: EngagementSumAggregateOutputType | null
    _min: EngagementMinAggregateOutputType | null
    _max: EngagementMaxAggregateOutputType | null
  }

  export type EngagementAvgAggregateOutputType = {
    crossFunctionalTeamId: number | null
  }

  export type EngagementSumAggregateOutputType = {
    crossFunctionalTeamId: number | null
  }

  export type EngagementMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: string | null
    demographicId: string | null
    engagementDetailId: string | null
    status: string | null
    crossFunctionalTeamId: number | null
    requestorId: string | null
    shortId: string | null
    feedbackConfigId: string | null
    isDeleted: boolean | null
    statusChangedOn: Date | null
  }

  export type EngagementMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    locationId: string | null
    demographicId: string | null
    engagementDetailId: string | null
    status: string | null
    crossFunctionalTeamId: number | null
    requestorId: string | null
    shortId: string | null
    feedbackConfigId: string | null
    isDeleted: boolean | null
    statusChangedOn: Date | null
  }

  export type EngagementCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    createdAt: number
    updatedAt: number
    locationId: number
    demographicId: number
    engagementDetailId: number
    status: number
    crossFunctionalTeamId: number
    requestorId: number
    shortId: number
    feedbackConfigId: number
    isDeleted: number
    statusChangedOn: number
    _all: number
  }


  export type EngagementAvgAggregateInputType = {
    crossFunctionalTeamId?: true
  }

  export type EngagementSumAggregateInputType = {
    crossFunctionalTeamId?: true
  }

  export type EngagementMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    demographicId?: true
    engagementDetailId?: true
    status?: true
    crossFunctionalTeamId?: true
    requestorId?: true
    shortId?: true
    feedbackConfigId?: true
    isDeleted?: true
    statusChangedOn?: true
  }

  export type EngagementMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    demographicId?: true
    engagementDetailId?: true
    status?: true
    crossFunctionalTeamId?: true
    requestorId?: true
    shortId?: true
    feedbackConfigId?: true
    isDeleted?: true
    statusChangedOn?: true
  }

  export type EngagementCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    locationId?: true
    demographicId?: true
    engagementDetailId?: true
    status?: true
    crossFunctionalTeamId?: true
    requestorId?: true
    shortId?: true
    feedbackConfigId?: true
    isDeleted?: true
    statusChangedOn?: true
    _all?: true
  }

  export type EngagementAggregateArgs = {
    /**
     * Filter which Engagement to aggregate.
     * 
    **/
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Engagements
    **/
    _count?: true | EngagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EngagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EngagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementMaxAggregateInputType
  }

  export type GetEngagementAggregateType<T extends EngagementAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagement[P]>
      : GetScalarType<T[P], AggregateEngagement[P]>
  }




  export type EngagementGroupByArgs = {
    where?: EngagementWhereInput
    orderBy?: Enumerable<EngagementOrderByWithAggregationInput>
    by: Array<EngagementScalarFieldEnum>
    having?: EngagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementCountAggregateInputType | true
    _avg?: EngagementAvgAggregateInputType
    _sum?: EngagementSumAggregateInputType
    _min?: EngagementMinAggregateInputType
    _max?: EngagementMaxAggregateInputType
  }


  export type EngagementGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    locationId: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    shortId: string | null
    feedbackConfigId: string | null
    isDeleted: boolean
    statusChangedOn: Date | null
    _count: EngagementCountAggregateOutputType | null
    _avg: EngagementAvgAggregateOutputType | null
    _sum: EngagementSumAggregateOutputType | null
    _min: EngagementMinAggregateOutputType | null
    _max: EngagementMaxAggregateOutputType | null
  }

  type GetEngagementGroupByPayload<T extends EngagementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EngagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementGroupByOutputType[P]>
        }
      >
    >


  export type EngagementSelect = {
    id?: boolean
    organization?: boolean | OrganizationArgs
    organizationId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationArgs
    locationId?: boolean
    demographic?: boolean | DemographicArgs
    demographicId?: boolean
    engagementDetail?: boolean | EngagementDetailArgs
    engagementDetailId?: boolean
    status?: boolean
    crossFunctionalTeam?: boolean | CrossFunctionalTeamsArgs
    crossFunctionalTeamId?: boolean
    requestor?: boolean | RequestorInformationArgs
    requestorId?: boolean
    events?: boolean | EventFindManyArgs
    dueDates?: boolean | DueDateFindManyArgs
    files?: boolean | FileFindManyArgs
    shortId?: boolean
    feedbackConfig?: boolean | FeedbackConfigArgs
    feedbackConfigId?: boolean
    isDeleted?: boolean
    statusChangedOn?: boolean
    _count?: boolean | EngagementCountOutputTypeArgs
  }

  export type EngagementInclude = {
    organization?: boolean | OrganizationArgs
    user?: boolean | UserArgs
    location?: boolean | LocationArgs
    demographic?: boolean | DemographicArgs
    engagementDetail?: boolean | EngagementDetailArgs
    crossFunctionalTeam?: boolean | CrossFunctionalTeamsArgs
    requestor?: boolean | RequestorInformationArgs
    events?: boolean | EventFindManyArgs
    dueDates?: boolean | DueDateFindManyArgs
    files?: boolean | FileFindManyArgs
    feedbackConfig?: boolean | FeedbackConfigArgs
    _count?: boolean | EngagementCountOutputTypeArgs
  }

  export type EngagementGetPayload<
    S extends boolean | null | undefined | EngagementArgs,
    U = keyof S
      > = S extends true
        ? Engagement
    : S extends undefined
    ? never
    : S extends EngagementArgs | EngagementFindManyArgs
    ?'include' extends U
    ? Engagement  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organization' ? OrganizationGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'location' ? LocationGetPayload<S['include'][P]> | null :
        P extends 'demographic' ? DemographicGetPayload<S['include'][P]> :
        P extends 'engagementDetail' ? EngagementDetailGetPayload<S['include'][P]> :
        P extends 'crossFunctionalTeam' ? CrossFunctionalTeamsGetPayload<S['include'][P]> :
        P extends 'requestor' ? RequestorInformationGetPayload<S['include'][P]> :
        P extends 'events' ? Array < EventGetPayload<S['include'][P]>>  :
        P extends 'dueDates' ? Array < DueDateGetPayload<S['include'][P]>>  :
        P extends 'files' ? Array < FileGetPayload<S['include'][P]>>  :
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['include'][P]> | null :
        P extends '_count' ? EngagementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organization' ? OrganizationGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'location' ? LocationGetPayload<S['select'][P]> | null :
        P extends 'demographic' ? DemographicGetPayload<S['select'][P]> :
        P extends 'engagementDetail' ? EngagementDetailGetPayload<S['select'][P]> :
        P extends 'crossFunctionalTeam' ? CrossFunctionalTeamsGetPayload<S['select'][P]> :
        P extends 'requestor' ? RequestorInformationGetPayload<S['select'][P]> :
        P extends 'events' ? Array < EventGetPayload<S['select'][P]>>  :
        P extends 'dueDates' ? Array < DueDateGetPayload<S['select'][P]>>  :
        P extends 'files' ? Array < FileGetPayload<S['select'][P]>>  :
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['select'][P]> | null :
        P extends '_count' ? EngagementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Engagement ? Engagement[P] : never
  } 
    : Engagement
  : Engagement


  type EngagementCountArgs = Merge<
    Omit<EngagementFindManyArgs, 'select' | 'include'> & {
      select?: EngagementCountAggregateInputType | true
    }
  >

  export interface EngagementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Engagement that matches the filter.
     * @param {EngagementFindUniqueArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EngagementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EngagementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Engagement'> extends True ? CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>> : CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>

    /**
     * Find the first Engagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementFindFirstArgs} args - Arguments to find a Engagement
     * @example
     * // Get one Engagement
     * const engagement = await prisma.engagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EngagementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EngagementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Engagement'> extends True ? CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>> : CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>

    /**
     * Find zero or more Engagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Engagements
     * const engagements = await prisma.engagement.findMany()
     * 
     * // Get first 10 Engagements
     * const engagements = await prisma.engagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementWithIdOnly = await prisma.engagement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EngagementFindManyArgs>(
      args?: SelectSubset<T, EngagementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Engagement>>, PrismaPromise<Array<EngagementGetPayload<T>>>>

    /**
     * Create a Engagement.
     * @param {EngagementCreateArgs} args - Arguments to create a Engagement.
     * @example
     * // Create one Engagement
     * const Engagement = await prisma.engagement.create({
     *   data: {
     *     // ... data to create a Engagement
     *   }
     * })
     * 
    **/
    create<T extends EngagementCreateArgs>(
      args: SelectSubset<T, EngagementCreateArgs>
    ): CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>>

    /**
     * Create many Engagements.
     *     @param {EngagementCreateManyArgs} args - Arguments to create many Engagements.
     *     @example
     *     // Create many Engagements
     *     const engagement = await prisma.engagement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EngagementCreateManyArgs>(
      args?: SelectSubset<T, EngagementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Engagement.
     * @param {EngagementDeleteArgs} args - Arguments to delete one Engagement.
     * @example
     * // Delete one Engagement
     * const Engagement = await prisma.engagement.delete({
     *   where: {
     *     // ... filter to delete one Engagement
     *   }
     * })
     * 
    **/
    delete<T extends EngagementDeleteArgs>(
      args: SelectSubset<T, EngagementDeleteArgs>
    ): CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>>

    /**
     * Update one Engagement.
     * @param {EngagementUpdateArgs} args - Arguments to update one Engagement.
     * @example
     * // Update one Engagement
     * const engagement = await prisma.engagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EngagementUpdateArgs>(
      args: SelectSubset<T, EngagementUpdateArgs>
    ): CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>>

    /**
     * Delete zero or more Engagements.
     * @param {EngagementDeleteManyArgs} args - Arguments to filter Engagements to delete.
     * @example
     * // Delete a few Engagements
     * const { count } = await prisma.engagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EngagementDeleteManyArgs>(
      args?: SelectSubset<T, EngagementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Engagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Engagements
     * const engagement = await prisma.engagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EngagementUpdateManyArgs>(
      args: SelectSubset<T, EngagementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Engagement.
     * @param {EngagementUpsertArgs} args - Arguments to update or create a Engagement.
     * @example
     * // Update or create a Engagement
     * const engagement = await prisma.engagement.upsert({
     *   create: {
     *     // ... data to create a Engagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Engagement we want to update
     *   }
     * })
    **/
    upsert<T extends EngagementUpsertArgs>(
      args: SelectSubset<T, EngagementUpsertArgs>
    ): CheckSelect<T, Prisma__EngagementClient<Engagement>, Prisma__EngagementClient<EngagementGetPayload<T>>>

    /**
     * Count the number of Engagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementCountArgs} args - Arguments to filter Engagements to count.
     * @example
     * // Count the number of Engagements
     * const count = await prisma.engagement.count({
     *   where: {
     *     // ... the filter for the Engagements we want to count
     *   }
     * })
    **/
    count<T extends EngagementCountArgs>(
      args?: Subset<T, EngagementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Engagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementAggregateArgs>(args: Subset<T, EngagementAggregateArgs>): PrismaPromise<GetEngagementAggregateType<T>>

    /**
     * Group by Engagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementGroupByArgs['orderBy'] }
        : { orderBy?: EngagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Engagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EngagementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organization<T extends OrganizationArgs = {}>(args?: Subset<T, OrganizationArgs>): CheckSelect<T, Prisma__OrganizationClient<Organization | null >, Prisma__OrganizationClient<OrganizationGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    location<T extends LocationArgs = {}>(args?: Subset<T, LocationArgs>): CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>;

    demographic<T extends DemographicArgs = {}>(args?: Subset<T, DemographicArgs>): CheckSelect<T, Prisma__DemographicClient<Demographic | null >, Prisma__DemographicClient<DemographicGetPayload<T> | null >>;

    engagementDetail<T extends EngagementDetailArgs = {}>(args?: Subset<T, EngagementDetailArgs>): CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail | null >, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T> | null >>;

    crossFunctionalTeam<T extends CrossFunctionalTeamsArgs = {}>(args?: Subset<T, CrossFunctionalTeamsArgs>): CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams | null >, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T> | null >>;

    requestor<T extends RequestorInformationArgs = {}>(args?: Subset<T, RequestorInformationArgs>): CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation | null >, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T> | null >>;

    events<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    dueDates<T extends DueDateFindManyArgs = {}>(args?: Subset<T, DueDateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DueDate>>, PrismaPromise<Array<DueDateGetPayload<T>>>>;

    files<T extends FileFindManyArgs = {}>(args?: Subset<T, FileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<File>>, PrismaPromise<Array<FileGetPayload<T>>>>;

    feedbackConfig<T extends FeedbackConfigArgs = {}>(args?: Subset<T, FeedbackConfigArgs>): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Engagement findUnique
   */
  export type EngagementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * Throw an Error if a Engagement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Engagement to fetch.
     * 
    **/
    where: EngagementWhereUniqueInput
  }


  /**
   * Engagement findFirst
   */
  export type EngagementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * Throw an Error if a Engagement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Engagement to fetch.
     * 
    **/
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Engagements.
     * 
    **/
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Engagements.
     * 
    **/
    distinct?: Enumerable<EngagementScalarFieldEnum>
  }


  /**
   * Engagement findMany
   */
  export type EngagementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * Filter, which Engagements to fetch.
     * 
    **/
    where?: EngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Engagements to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Engagements.
     * 
    **/
    cursor?: EngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Engagements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Engagements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EngagementScalarFieldEnum>
  }


  /**
   * Engagement create
   */
  export type EngagementCreateArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * The data needed to create a Engagement.
     * 
    **/
    data: XOR<EngagementCreateInput, EngagementUncheckedCreateInput>
  }


  /**
   * Engagement createMany
   */
  export type EngagementCreateManyArgs = {
    /**
     * The data used to create many Engagements.
     * 
    **/
    data: Enumerable<EngagementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Engagement update
   */
  export type EngagementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * The data needed to update a Engagement.
     * 
    **/
    data: XOR<EngagementUpdateInput, EngagementUncheckedUpdateInput>
    /**
     * Choose, which Engagement to update.
     * 
    **/
    where: EngagementWhereUniqueInput
  }


  /**
   * Engagement updateMany
   */
  export type EngagementUpdateManyArgs = {
    /**
     * The data used to update Engagements.
     * 
    **/
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyInput>
    /**
     * Filter which Engagements to update
     * 
    **/
    where?: EngagementWhereInput
  }


  /**
   * Engagement upsert
   */
  export type EngagementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * The filter to search for the Engagement to update in case it exists.
     * 
    **/
    where: EngagementWhereUniqueInput
    /**
     * In case the Engagement found by the `where` argument doesn't exist, create a new Engagement with this data.
     * 
    **/
    create: XOR<EngagementCreateInput, EngagementUncheckedCreateInput>
    /**
     * In case the Engagement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EngagementUpdateInput, EngagementUncheckedUpdateInput>
  }


  /**
   * Engagement delete
   */
  export type EngagementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
    /**
     * Filter which Engagement to delete.
     * 
    **/
    where: EngagementWhereUniqueInput
  }


  /**
   * Engagement deleteMany
   */
  export type EngagementDeleteManyArgs = {
    /**
     * Filter which Engagements to delete
     * 
    **/
    where?: EngagementWhereInput
  }


  /**
   * Engagement without action
   */
  export type EngagementArgs = {
    /**
     * Select specific fields to fetch from the Engagement
     * 
    **/
    select?: EngagementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementInclude | null
  }



  /**
   * Model Location
   */


  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    zip: number | null
  }

  export type LocationSumAggregateOutputType = {
    zip: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    addressOne: string | null
    addressTwo: string | null
    city: string | null
    state: string | null
    zip: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    addressOne: string | null
    addressTwo: string | null
    city: string | null
    state: string | null
    zip: number | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    addressOne: number
    addressTwo: number
    city: number
    state: number
    zip: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    zip?: true
  }

  export type LocationSumAggregateInputType = {
    zip?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which Location to aggregate.
     * 
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     * 
    **/
    orderBy?: Enumerable<LocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs = {
    where?: LocationWhereInput
    orderBy?: Enumerable<LocationOrderByWithAggregationInput>
    by: Array<LocationScalarFieldEnum>
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    id: string
    addressOne: string
    addressTwo: string | null
    city: string
    state: string
    zip: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect = {
    id?: boolean
    addressOne?: boolean
    addressTwo?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    engagement?: boolean | EngagementArgs
  }

  export type LocationInclude = {
    engagement?: boolean | EngagementArgs
  }

  export type LocationGetPayload<
    S extends boolean | null | undefined | LocationArgs,
    U = keyof S
      > = S extends true
        ? Location
    : S extends undefined
    ? never
    : S extends LocationArgs | LocationFindManyArgs
    ?'include' extends U
    ? Location  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :  P extends keyof Location ? Location[P] : never
  } 
    : Location
  : Location


  type LocationCountArgs = Merge<
    Omit<LocationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface LocationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LocationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LocationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Location'> extends True ? CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>> : CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LocationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LocationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Location'> extends True ? CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>> : CheckSelect<T, Prisma__LocationClient<Location | null >, Prisma__LocationClient<LocationGetPayload<T> | null >>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LocationFindManyArgs>(
      args?: SelectSubset<T, LocationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Location>>, PrismaPromise<Array<LocationGetPayload<T>>>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends LocationCreateArgs>(
      args: SelectSubset<T, LocationCreateArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Create many Locations.
     *     @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LocationCreateManyArgs>(
      args?: SelectSubset<T, LocationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends LocationDeleteArgs>(
      args: SelectSubset<T, LocationDeleteArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LocationUpdateArgs>(
      args: SelectSubset<T, LocationUpdateArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LocationDeleteManyArgs>(
      args?: SelectSubset<T, LocationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LocationUpdateManyArgs>(
      args: SelectSubset<T, LocationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends LocationUpsertArgs>(
      args: SelectSubset<T, LocationUpsertArgs>
    ): CheckSelect<T, Prisma__LocationClient<Location>, Prisma__LocationClient<LocationGetPayload<T>>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LocationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * Throw an Error if a Location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Location to fetch.
     * 
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * Throw an Error if a Location can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Location to fetch.
     * 
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     * 
    **/
    orderBy?: Enumerable<LocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     * 
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     * 
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * Location findMany
   */
  export type LocationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * Filter, which Locations to fetch.
     * 
    **/
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     * 
    **/
    orderBy?: Enumerable<LocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     * 
    **/
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * Location create
   */
  export type LocationCreateArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * The data needed to create a Location.
     * 
    **/
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }


  /**
   * Location createMany
   */
  export type LocationCreateManyArgs = {
    /**
     * The data used to create many Locations.
     * 
    **/
    data: Enumerable<LocationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Location update
   */
  export type LocationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * The data needed to update a Location.
     * 
    **/
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     * 
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs = {
    /**
     * The data used to update Locations.
     * 
    **/
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     * 
    **/
    where?: LocationWhereInput
  }


  /**
   * Location upsert
   */
  export type LocationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * The filter to search for the Location to update in case it exists.
     * 
    **/
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     * 
    **/
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }


  /**
   * Location delete
   */
  export type LocationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
    /**
     * Filter which Location to delete.
     * 
    **/
    where: LocationWhereUniqueInput
  }


  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs = {
    /**
     * Filter which Locations to delete
     * 
    **/
    where?: LocationWhereInput
  }


  /**
   * Location without action
   */
  export type LocationArgs = {
    /**
     * Select specific fields to fetch from the Location
     * 
    **/
    select?: LocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LocationInclude | null
  }



  /**
   * Model EngagementDetail
   */


  export type AggregateEngagementDetail = {
    _count: EngagementDetailCountAggregateOutputType | null
    _min: EngagementDetailMinAggregateOutputType | null
    _max: EngagementDetailMaxAggregateOutputType | null
  }

  export type EngagementDetailMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    description: string | null
    associatedProgram: string | null
    armyImpact: string | null
    fundingDetails: string | null
    otherInformation: string | null
  }

  export type EngagementDetailMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    description: string | null
    associatedProgram: string | null
    armyImpact: string | null
    fundingDetails: string | null
    otherInformation: string | null
  }

  export type EngagementDetailCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    description: number
    associatedProgram: number
    armyImpact: number
    fundingDetails: number
    otherInformation: number
    _all: number
  }


  export type EngagementDetailMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    description?: true
    associatedProgram?: true
    armyImpact?: true
    fundingDetails?: true
    otherInformation?: true
  }

  export type EngagementDetailMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    description?: true
    associatedProgram?: true
    armyImpact?: true
    fundingDetails?: true
    otherInformation?: true
  }

  export type EngagementDetailCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    description?: true
    associatedProgram?: true
    armyImpact?: true
    fundingDetails?: true
    otherInformation?: true
    _all?: true
  }

  export type EngagementDetailAggregateArgs = {
    /**
     * Filter which EngagementDetail to aggregate.
     * 
    **/
    where?: EngagementDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EngagementDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EngagementDetails
    **/
    _count?: true | EngagementDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementDetailMaxAggregateInputType
  }

  export type GetEngagementDetailAggregateType<T extends EngagementDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagementDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagementDetail[P]>
      : GetScalarType<T[P], AggregateEngagementDetail[P]>
  }




  export type EngagementDetailGroupByArgs = {
    where?: EngagementDetailWhereInput
    orderBy?: Enumerable<EngagementDetailOrderByWithAggregationInput>
    by: Array<EngagementDetailScalarFieldEnum>
    having?: EngagementDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementDetailCountAggregateInputType | true
    _min?: EngagementDetailMinAggregateInputType
    _max?: EngagementDetailMaxAggregateInputType
  }


  export type EngagementDetailGroupByOutputType = {
    id: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails: string | null
    otherInformation: string | null
    _count: EngagementDetailCountAggregateOutputType | null
    _min: EngagementDetailMinAggregateOutputType | null
    _max: EngagementDetailMaxAggregateOutputType | null
  }

  type GetEngagementDetailGroupByPayload<T extends EngagementDetailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EngagementDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementDetailGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementDetailGroupByOutputType[P]>
        }
      >
    >


  export type EngagementDetailSelect = {
    id?: boolean
    title?: boolean
    summary?: boolean
    description?: boolean
    associatedProgram?: boolean
    armyImpact?: boolean
    fundingDetails?: boolean
    otherInformation?: boolean
    engagement?: boolean | EngagementArgs
  }

  export type EngagementDetailInclude = {
    engagement?: boolean | EngagementArgs
  }

  export type EngagementDetailGetPayload<
    S extends boolean | null | undefined | EngagementDetailArgs,
    U = keyof S
      > = S extends true
        ? EngagementDetail
    : S extends undefined
    ? never
    : S extends EngagementDetailArgs | EngagementDetailFindManyArgs
    ?'include' extends U
    ? EngagementDetail  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :  P extends keyof EngagementDetail ? EngagementDetail[P] : never
  } 
    : EngagementDetail
  : EngagementDetail


  type EngagementDetailCountArgs = Merge<
    Omit<EngagementDetailFindManyArgs, 'select' | 'include'> & {
      select?: EngagementDetailCountAggregateInputType | true
    }
  >

  export interface EngagementDetailDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EngagementDetail that matches the filter.
     * @param {EngagementDetailFindUniqueArgs} args - Arguments to find a EngagementDetail
     * @example
     * // Get one EngagementDetail
     * const engagementDetail = await prisma.engagementDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EngagementDetailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EngagementDetailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EngagementDetail'> extends True ? CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>> : CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail | null >, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T> | null >>

    /**
     * Find the first EngagementDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailFindFirstArgs} args - Arguments to find a EngagementDetail
     * @example
     * // Get one EngagementDetail
     * const engagementDetail = await prisma.engagementDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EngagementDetailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EngagementDetailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EngagementDetail'> extends True ? CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>> : CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail | null >, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T> | null >>

    /**
     * Find zero or more EngagementDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EngagementDetails
     * const engagementDetails = await prisma.engagementDetail.findMany()
     * 
     * // Get first 10 EngagementDetails
     * const engagementDetails = await prisma.engagementDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementDetailWithIdOnly = await prisma.engagementDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EngagementDetailFindManyArgs>(
      args?: SelectSubset<T, EngagementDetailFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EngagementDetail>>, PrismaPromise<Array<EngagementDetailGetPayload<T>>>>

    /**
     * Create a EngagementDetail.
     * @param {EngagementDetailCreateArgs} args - Arguments to create a EngagementDetail.
     * @example
     * // Create one EngagementDetail
     * const EngagementDetail = await prisma.engagementDetail.create({
     *   data: {
     *     // ... data to create a EngagementDetail
     *   }
     * })
     * 
    **/
    create<T extends EngagementDetailCreateArgs>(
      args: SelectSubset<T, EngagementDetailCreateArgs>
    ): CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>>

    /**
     * Create many EngagementDetails.
     *     @param {EngagementDetailCreateManyArgs} args - Arguments to create many EngagementDetails.
     *     @example
     *     // Create many EngagementDetails
     *     const engagementDetail = await prisma.engagementDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EngagementDetailCreateManyArgs>(
      args?: SelectSubset<T, EngagementDetailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EngagementDetail.
     * @param {EngagementDetailDeleteArgs} args - Arguments to delete one EngagementDetail.
     * @example
     * // Delete one EngagementDetail
     * const EngagementDetail = await prisma.engagementDetail.delete({
     *   where: {
     *     // ... filter to delete one EngagementDetail
     *   }
     * })
     * 
    **/
    delete<T extends EngagementDetailDeleteArgs>(
      args: SelectSubset<T, EngagementDetailDeleteArgs>
    ): CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>>

    /**
     * Update one EngagementDetail.
     * @param {EngagementDetailUpdateArgs} args - Arguments to update one EngagementDetail.
     * @example
     * // Update one EngagementDetail
     * const engagementDetail = await prisma.engagementDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EngagementDetailUpdateArgs>(
      args: SelectSubset<T, EngagementDetailUpdateArgs>
    ): CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>>

    /**
     * Delete zero or more EngagementDetails.
     * @param {EngagementDetailDeleteManyArgs} args - Arguments to filter EngagementDetails to delete.
     * @example
     * // Delete a few EngagementDetails
     * const { count } = await prisma.engagementDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EngagementDetailDeleteManyArgs>(
      args?: SelectSubset<T, EngagementDetailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EngagementDetails
     * const engagementDetail = await prisma.engagementDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EngagementDetailUpdateManyArgs>(
      args: SelectSubset<T, EngagementDetailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EngagementDetail.
     * @param {EngagementDetailUpsertArgs} args - Arguments to update or create a EngagementDetail.
     * @example
     * // Update or create a EngagementDetail
     * const engagementDetail = await prisma.engagementDetail.upsert({
     *   create: {
     *     // ... data to create a EngagementDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EngagementDetail we want to update
     *   }
     * })
    **/
    upsert<T extends EngagementDetailUpsertArgs>(
      args: SelectSubset<T, EngagementDetailUpsertArgs>
    ): CheckSelect<T, Prisma__EngagementDetailClient<EngagementDetail>, Prisma__EngagementDetailClient<EngagementDetailGetPayload<T>>>

    /**
     * Count the number of EngagementDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailCountArgs} args - Arguments to filter EngagementDetails to count.
     * @example
     * // Count the number of EngagementDetails
     * const count = await prisma.engagementDetail.count({
     *   where: {
     *     // ... the filter for the EngagementDetails we want to count
     *   }
     * })
    **/
    count<T extends EngagementDetailCountArgs>(
      args?: Subset<T, EngagementDetailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EngagementDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementDetailAggregateArgs>(args: Subset<T, EngagementDetailAggregateArgs>): PrismaPromise<GetEngagementDetailAggregateType<T>>

    /**
     * Group by EngagementDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementDetailGroupByArgs['orderBy'] }
        : { orderBy?: EngagementDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementDetailGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EngagementDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EngagementDetailClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EngagementDetail findUnique
   */
  export type EngagementDetailFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * Throw an Error if a EngagementDetail can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EngagementDetail to fetch.
     * 
    **/
    where: EngagementDetailWhereUniqueInput
  }


  /**
   * EngagementDetail findFirst
   */
  export type EngagementDetailFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * Throw an Error if a EngagementDetail can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EngagementDetail to fetch.
     * 
    **/
    where?: EngagementDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementDetails.
     * 
    **/
    cursor?: EngagementDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementDetails.
     * 
    **/
    distinct?: Enumerable<EngagementDetailScalarFieldEnum>
  }


  /**
   * EngagementDetail findMany
   */
  export type EngagementDetailFindManyArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * Filter, which EngagementDetails to fetch.
     * 
    **/
    where?: EngagementDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDetailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EngagementDetails.
     * 
    **/
    cursor?: EngagementDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EngagementDetailScalarFieldEnum>
  }


  /**
   * EngagementDetail create
   */
  export type EngagementDetailCreateArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * The data needed to create a EngagementDetail.
     * 
    **/
    data: XOR<EngagementDetailCreateInput, EngagementDetailUncheckedCreateInput>
  }


  /**
   * EngagementDetail createMany
   */
  export type EngagementDetailCreateManyArgs = {
    /**
     * The data used to create many EngagementDetails.
     * 
    **/
    data: Enumerable<EngagementDetailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EngagementDetail update
   */
  export type EngagementDetailUpdateArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * The data needed to update a EngagementDetail.
     * 
    **/
    data: XOR<EngagementDetailUpdateInput, EngagementDetailUncheckedUpdateInput>
    /**
     * Choose, which EngagementDetail to update.
     * 
    **/
    where: EngagementDetailWhereUniqueInput
  }


  /**
   * EngagementDetail updateMany
   */
  export type EngagementDetailUpdateManyArgs = {
    /**
     * The data used to update EngagementDetails.
     * 
    **/
    data: XOR<EngagementDetailUpdateManyMutationInput, EngagementDetailUncheckedUpdateManyInput>
    /**
     * Filter which EngagementDetails to update
     * 
    **/
    where?: EngagementDetailWhereInput
  }


  /**
   * EngagementDetail upsert
   */
  export type EngagementDetailUpsertArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * The filter to search for the EngagementDetail to update in case it exists.
     * 
    **/
    where: EngagementDetailWhereUniqueInput
    /**
     * In case the EngagementDetail found by the `where` argument doesn't exist, create a new EngagementDetail with this data.
     * 
    **/
    create: XOR<EngagementDetailCreateInput, EngagementDetailUncheckedCreateInput>
    /**
     * In case the EngagementDetail was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EngagementDetailUpdateInput, EngagementDetailUncheckedUpdateInput>
  }


  /**
   * EngagementDetail delete
   */
  export type EngagementDetailDeleteArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
    /**
     * Filter which EngagementDetail to delete.
     * 
    **/
    where: EngagementDetailWhereUniqueInput
  }


  /**
   * EngagementDetail deleteMany
   */
  export type EngagementDetailDeleteManyArgs = {
    /**
     * Filter which EngagementDetails to delete
     * 
    **/
    where?: EngagementDetailWhereInput
  }


  /**
   * EngagementDetail without action
   */
  export type EngagementDetailArgs = {
    /**
     * Select specific fields to fetch from the EngagementDetail
     * 
    **/
    select?: EngagementDetailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDetailInclude | null
  }



  /**
   * Model CrossFunctionalTeams
   */


  export type AggregateCrossFunctionalTeams = {
    _count: CrossFunctionalTeamsCountAggregateOutputType | null
    _avg: CrossFunctionalTeamsAvgAggregateOutputType | null
    _sum: CrossFunctionalTeamsSumAggregateOutputType | null
    _min: CrossFunctionalTeamsMinAggregateOutputType | null
    _max: CrossFunctionalTeamsMaxAggregateOutputType | null
  }

  export type CrossFunctionalTeamsAvgAggregateOutputType = {
    id: number | null
  }

  export type CrossFunctionalTeamsSumAggregateOutputType = {
    id: number | null
  }

  export type CrossFunctionalTeamsMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrossFunctionalTeamsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrossFunctionalTeamsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrossFunctionalTeamsAvgAggregateInputType = {
    id?: true
  }

  export type CrossFunctionalTeamsSumAggregateInputType = {
    id?: true
  }

  export type CrossFunctionalTeamsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrossFunctionalTeamsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrossFunctionalTeamsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrossFunctionalTeamsAggregateArgs = {
    /**
     * Filter which CrossFunctionalTeams to aggregate.
     * 
    **/
    where?: CrossFunctionalTeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossFunctionalTeams to fetch.
     * 
    **/
    orderBy?: Enumerable<CrossFunctionalTeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CrossFunctionalTeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossFunctionalTeams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossFunctionalTeams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrossFunctionalTeams
    **/
    _count?: true | CrossFunctionalTeamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrossFunctionalTeamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrossFunctionalTeamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrossFunctionalTeamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrossFunctionalTeamsMaxAggregateInputType
  }

  export type GetCrossFunctionalTeamsAggregateType<T extends CrossFunctionalTeamsAggregateArgs> = {
        [P in keyof T & keyof AggregateCrossFunctionalTeams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrossFunctionalTeams[P]>
      : GetScalarType<T[P], AggregateCrossFunctionalTeams[P]>
  }




  export type CrossFunctionalTeamsGroupByArgs = {
    where?: CrossFunctionalTeamsWhereInput
    orderBy?: Enumerable<CrossFunctionalTeamsOrderByWithAggregationInput>
    by: Array<CrossFunctionalTeamsScalarFieldEnum>
    having?: CrossFunctionalTeamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrossFunctionalTeamsCountAggregateInputType | true
    _avg?: CrossFunctionalTeamsAvgAggregateInputType
    _sum?: CrossFunctionalTeamsSumAggregateInputType
    _min?: CrossFunctionalTeamsMinAggregateInputType
    _max?: CrossFunctionalTeamsMaxAggregateInputType
  }


  export type CrossFunctionalTeamsGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CrossFunctionalTeamsCountAggregateOutputType | null
    _avg: CrossFunctionalTeamsAvgAggregateOutputType | null
    _sum: CrossFunctionalTeamsSumAggregateOutputType | null
    _min: CrossFunctionalTeamsMinAggregateOutputType | null
    _max: CrossFunctionalTeamsMaxAggregateOutputType | null
  }

  type GetCrossFunctionalTeamsGroupByPayload<T extends CrossFunctionalTeamsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CrossFunctionalTeamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrossFunctionalTeamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrossFunctionalTeamsGroupByOutputType[P]>
            : GetScalarType<T[P], CrossFunctionalTeamsGroupByOutputType[P]>
        }
      >
    >


  export type CrossFunctionalTeamsSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    engagements?: boolean | EngagementFindManyArgs
    _count?: boolean | CrossFunctionalTeamsCountOutputTypeArgs
  }

  export type CrossFunctionalTeamsInclude = {
    engagements?: boolean | EngagementFindManyArgs
    _count?: boolean | CrossFunctionalTeamsCountOutputTypeArgs
  }

  export type CrossFunctionalTeamsGetPayload<
    S extends boolean | null | undefined | CrossFunctionalTeamsArgs,
    U = keyof S
      > = S extends true
        ? CrossFunctionalTeams
    : S extends undefined
    ? never
    : S extends CrossFunctionalTeamsArgs | CrossFunctionalTeamsFindManyArgs
    ?'include' extends U
    ? CrossFunctionalTeams  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagements' ? Array < EngagementGetPayload<S['include'][P]>>  :
        P extends '_count' ? CrossFunctionalTeamsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagements' ? Array < EngagementGetPayload<S['select'][P]>>  :
        P extends '_count' ? CrossFunctionalTeamsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CrossFunctionalTeams ? CrossFunctionalTeams[P] : never
  } 
    : CrossFunctionalTeams
  : CrossFunctionalTeams


  type CrossFunctionalTeamsCountArgs = Merge<
    Omit<CrossFunctionalTeamsFindManyArgs, 'select' | 'include'> & {
      select?: CrossFunctionalTeamsCountAggregateInputType | true
    }
  >

  export interface CrossFunctionalTeamsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CrossFunctionalTeams that matches the filter.
     * @param {CrossFunctionalTeamsFindUniqueArgs} args - Arguments to find a CrossFunctionalTeams
     * @example
     * // Get one CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CrossFunctionalTeamsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CrossFunctionalTeamsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CrossFunctionalTeams'> extends True ? CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>> : CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams | null >, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T> | null >>

    /**
     * Find the first CrossFunctionalTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsFindFirstArgs} args - Arguments to find a CrossFunctionalTeams
     * @example
     * // Get one CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CrossFunctionalTeamsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CrossFunctionalTeamsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CrossFunctionalTeams'> extends True ? CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>> : CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams | null >, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T> | null >>

    /**
     * Find zero or more CrossFunctionalTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.findMany()
     * 
     * // Get first 10 CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crossFunctionalTeamsWithIdOnly = await prisma.crossFunctionalTeams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CrossFunctionalTeamsFindManyArgs>(
      args?: SelectSubset<T, CrossFunctionalTeamsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CrossFunctionalTeams>>, PrismaPromise<Array<CrossFunctionalTeamsGetPayload<T>>>>

    /**
     * Create a CrossFunctionalTeams.
     * @param {CrossFunctionalTeamsCreateArgs} args - Arguments to create a CrossFunctionalTeams.
     * @example
     * // Create one CrossFunctionalTeams
     * const CrossFunctionalTeams = await prisma.crossFunctionalTeams.create({
     *   data: {
     *     // ... data to create a CrossFunctionalTeams
     *   }
     * })
     * 
    **/
    create<T extends CrossFunctionalTeamsCreateArgs>(
      args: SelectSubset<T, CrossFunctionalTeamsCreateArgs>
    ): CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>>

    /**
     * Create many CrossFunctionalTeams.
     *     @param {CrossFunctionalTeamsCreateManyArgs} args - Arguments to create many CrossFunctionalTeams.
     *     @example
     *     // Create many CrossFunctionalTeams
     *     const crossFunctionalTeams = await prisma.crossFunctionalTeams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CrossFunctionalTeamsCreateManyArgs>(
      args?: SelectSubset<T, CrossFunctionalTeamsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CrossFunctionalTeams.
     * @param {CrossFunctionalTeamsDeleteArgs} args - Arguments to delete one CrossFunctionalTeams.
     * @example
     * // Delete one CrossFunctionalTeams
     * const CrossFunctionalTeams = await prisma.crossFunctionalTeams.delete({
     *   where: {
     *     // ... filter to delete one CrossFunctionalTeams
     *   }
     * })
     * 
    **/
    delete<T extends CrossFunctionalTeamsDeleteArgs>(
      args: SelectSubset<T, CrossFunctionalTeamsDeleteArgs>
    ): CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>>

    /**
     * Update one CrossFunctionalTeams.
     * @param {CrossFunctionalTeamsUpdateArgs} args - Arguments to update one CrossFunctionalTeams.
     * @example
     * // Update one CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CrossFunctionalTeamsUpdateArgs>(
      args: SelectSubset<T, CrossFunctionalTeamsUpdateArgs>
    ): CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>>

    /**
     * Delete zero or more CrossFunctionalTeams.
     * @param {CrossFunctionalTeamsDeleteManyArgs} args - Arguments to filter CrossFunctionalTeams to delete.
     * @example
     * // Delete a few CrossFunctionalTeams
     * const { count } = await prisma.crossFunctionalTeams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CrossFunctionalTeamsDeleteManyArgs>(
      args?: SelectSubset<T, CrossFunctionalTeamsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrossFunctionalTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CrossFunctionalTeamsUpdateManyArgs>(
      args: SelectSubset<T, CrossFunctionalTeamsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CrossFunctionalTeams.
     * @param {CrossFunctionalTeamsUpsertArgs} args - Arguments to update or create a CrossFunctionalTeams.
     * @example
     * // Update or create a CrossFunctionalTeams
     * const crossFunctionalTeams = await prisma.crossFunctionalTeams.upsert({
     *   create: {
     *     // ... data to create a CrossFunctionalTeams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrossFunctionalTeams we want to update
     *   }
     * })
    **/
    upsert<T extends CrossFunctionalTeamsUpsertArgs>(
      args: SelectSubset<T, CrossFunctionalTeamsUpsertArgs>
    ): CheckSelect<T, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeams>, Prisma__CrossFunctionalTeamsClient<CrossFunctionalTeamsGetPayload<T>>>

    /**
     * Count the number of CrossFunctionalTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsCountArgs} args - Arguments to filter CrossFunctionalTeams to count.
     * @example
     * // Count the number of CrossFunctionalTeams
     * const count = await prisma.crossFunctionalTeams.count({
     *   where: {
     *     // ... the filter for the CrossFunctionalTeams we want to count
     *   }
     * })
    **/
    count<T extends CrossFunctionalTeamsCountArgs>(
      args?: Subset<T, CrossFunctionalTeamsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrossFunctionalTeamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrossFunctionalTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrossFunctionalTeamsAggregateArgs>(args: Subset<T, CrossFunctionalTeamsAggregateArgs>): PrismaPromise<GetCrossFunctionalTeamsAggregateType<T>>

    /**
     * Group by CrossFunctionalTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossFunctionalTeamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrossFunctionalTeamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrossFunctionalTeamsGroupByArgs['orderBy'] }
        : { orderBy?: CrossFunctionalTeamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrossFunctionalTeamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrossFunctionalTeamsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrossFunctionalTeams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CrossFunctionalTeamsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagements<T extends EngagementFindManyArgs = {}>(args?: Subset<T, EngagementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Engagement>>, PrismaPromise<Array<EngagementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CrossFunctionalTeams findUnique
   */
  export type CrossFunctionalTeamsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * Throw an Error if a CrossFunctionalTeams can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CrossFunctionalTeams to fetch.
     * 
    **/
    where: CrossFunctionalTeamsWhereUniqueInput
  }


  /**
   * CrossFunctionalTeams findFirst
   */
  export type CrossFunctionalTeamsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * Throw an Error if a CrossFunctionalTeams can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CrossFunctionalTeams to fetch.
     * 
    **/
    where?: CrossFunctionalTeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossFunctionalTeams to fetch.
     * 
    **/
    orderBy?: Enumerable<CrossFunctionalTeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrossFunctionalTeams.
     * 
    **/
    cursor?: CrossFunctionalTeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossFunctionalTeams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossFunctionalTeams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrossFunctionalTeams.
     * 
    **/
    distinct?: Enumerable<CrossFunctionalTeamsScalarFieldEnum>
  }


  /**
   * CrossFunctionalTeams findMany
   */
  export type CrossFunctionalTeamsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * Filter, which CrossFunctionalTeams to fetch.
     * 
    **/
    where?: CrossFunctionalTeamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossFunctionalTeams to fetch.
     * 
    **/
    orderBy?: Enumerable<CrossFunctionalTeamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrossFunctionalTeams.
     * 
    **/
    cursor?: CrossFunctionalTeamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossFunctionalTeams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossFunctionalTeams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CrossFunctionalTeamsScalarFieldEnum>
  }


  /**
   * CrossFunctionalTeams create
   */
  export type CrossFunctionalTeamsCreateArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * The data needed to create a CrossFunctionalTeams.
     * 
    **/
    data: XOR<CrossFunctionalTeamsCreateInput, CrossFunctionalTeamsUncheckedCreateInput>
  }


  /**
   * CrossFunctionalTeams createMany
   */
  export type CrossFunctionalTeamsCreateManyArgs = {
    /**
     * The data used to create many CrossFunctionalTeams.
     * 
    **/
    data: Enumerable<CrossFunctionalTeamsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CrossFunctionalTeams update
   */
  export type CrossFunctionalTeamsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * The data needed to update a CrossFunctionalTeams.
     * 
    **/
    data: XOR<CrossFunctionalTeamsUpdateInput, CrossFunctionalTeamsUncheckedUpdateInput>
    /**
     * Choose, which CrossFunctionalTeams to update.
     * 
    **/
    where: CrossFunctionalTeamsWhereUniqueInput
  }


  /**
   * CrossFunctionalTeams updateMany
   */
  export type CrossFunctionalTeamsUpdateManyArgs = {
    /**
     * The data used to update CrossFunctionalTeams.
     * 
    **/
    data: XOR<CrossFunctionalTeamsUpdateManyMutationInput, CrossFunctionalTeamsUncheckedUpdateManyInput>
    /**
     * Filter which CrossFunctionalTeams to update
     * 
    **/
    where?: CrossFunctionalTeamsWhereInput
  }


  /**
   * CrossFunctionalTeams upsert
   */
  export type CrossFunctionalTeamsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * The filter to search for the CrossFunctionalTeams to update in case it exists.
     * 
    **/
    where: CrossFunctionalTeamsWhereUniqueInput
    /**
     * In case the CrossFunctionalTeams found by the `where` argument doesn't exist, create a new CrossFunctionalTeams with this data.
     * 
    **/
    create: XOR<CrossFunctionalTeamsCreateInput, CrossFunctionalTeamsUncheckedCreateInput>
    /**
     * In case the CrossFunctionalTeams was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CrossFunctionalTeamsUpdateInput, CrossFunctionalTeamsUncheckedUpdateInput>
  }


  /**
   * CrossFunctionalTeams delete
   */
  export type CrossFunctionalTeamsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
    /**
     * Filter which CrossFunctionalTeams to delete.
     * 
    **/
    where: CrossFunctionalTeamsWhereUniqueInput
  }


  /**
   * CrossFunctionalTeams deleteMany
   */
  export type CrossFunctionalTeamsDeleteManyArgs = {
    /**
     * Filter which CrossFunctionalTeams to delete
     * 
    **/
    where?: CrossFunctionalTeamsWhereInput
  }


  /**
   * CrossFunctionalTeams without action
   */
  export type CrossFunctionalTeamsArgs = {
    /**
     * Select specific fields to fetch from the CrossFunctionalTeams
     * 
    **/
    select?: CrossFunctionalTeamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CrossFunctionalTeamsInclude | null
  }



  /**
   * Model Demographic
   */


  export type AggregateDemographic = {
    _count: DemographicCountAggregateOutputType | null
    _avg: DemographicAvgAggregateOutputType | null
    _sum: DemographicSumAggregateOutputType | null
    _min: DemographicMinAggregateOutputType | null
    _max: DemographicMaxAggregateOutputType | null
  }

  export type DemographicAvgAggregateOutputType = {
    soldiersNeeded: number | null
  }

  export type DemographicSumAggregateOutputType = {
    soldiersNeeded: number | null
  }

  export type DemographicMinAggregateOutputType = {
    id: string | null
    soldierInput: string | null
    soldiersNeeded: number | null
    mos: string | null
  }

  export type DemographicMaxAggregateOutputType = {
    id: string | null
    soldierInput: string | null
    soldiersNeeded: number | null
    mos: string | null
  }

  export type DemographicCountAggregateOutputType = {
    id: number
    soldierInput: number
    soldiersNeeded: number
    mos: number
    _all: number
  }


  export type DemographicAvgAggregateInputType = {
    soldiersNeeded?: true
  }

  export type DemographicSumAggregateInputType = {
    soldiersNeeded?: true
  }

  export type DemographicMinAggregateInputType = {
    id?: true
    soldierInput?: true
    soldiersNeeded?: true
    mos?: true
  }

  export type DemographicMaxAggregateInputType = {
    id?: true
    soldierInput?: true
    soldiersNeeded?: true
    mos?: true
  }

  export type DemographicCountAggregateInputType = {
    id?: true
    soldierInput?: true
    soldiersNeeded?: true
    mos?: true
    _all?: true
  }

  export type DemographicAggregateArgs = {
    /**
     * Filter which Demographic to aggregate.
     * 
    **/
    where?: DemographicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     * 
    **/
    orderBy?: Enumerable<DemographicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DemographicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Demographics
    **/
    _count?: true | DemographicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DemographicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DemographicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemographicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemographicMaxAggregateInputType
  }

  export type GetDemographicAggregateType<T extends DemographicAggregateArgs> = {
        [P in keyof T & keyof AggregateDemographic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemographic[P]>
      : GetScalarType<T[P], AggregateDemographic[P]>
  }




  export type DemographicGroupByArgs = {
    where?: DemographicWhereInput
    orderBy?: Enumerable<DemographicOrderByWithAggregationInput>
    by: Array<DemographicScalarFieldEnum>
    having?: DemographicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemographicCountAggregateInputType | true
    _avg?: DemographicAvgAggregateInputType
    _sum?: DemographicSumAggregateInputType
    _min?: DemographicMinAggregateInputType
    _max?: DemographicMaxAggregateInputType
  }


  export type DemographicGroupByOutputType = {
    id: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    _count: DemographicCountAggregateOutputType | null
    _avg: DemographicAvgAggregateOutputType | null
    _sum: DemographicSumAggregateOutputType | null
    _min: DemographicMinAggregateOutputType | null
    _max: DemographicMaxAggregateOutputType | null
  }

  type GetDemographicGroupByPayload<T extends DemographicGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DemographicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemographicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemographicGroupByOutputType[P]>
            : GetScalarType<T[P], DemographicGroupByOutputType[P]>
        }
      >
    >


  export type DemographicSelect = {
    id?: boolean
    soldierInput?: boolean
    soldiersNeeded?: boolean
    mos?: boolean
    engagement?: boolean | EngagementArgs
    requirements?: boolean | RequirementFindManyArgs
    _count?: boolean | DemographicCountOutputTypeArgs
  }

  export type DemographicInclude = {
    engagement?: boolean | EngagementArgs
    requirements?: boolean | RequirementFindManyArgs
    _count?: boolean | DemographicCountOutputTypeArgs
  }

  export type DemographicGetPayload<
    S extends boolean | null | undefined | DemographicArgs,
    U = keyof S
      > = S extends true
        ? Demographic
    : S extends undefined
    ? never
    : S extends DemographicArgs | DemographicFindManyArgs
    ?'include' extends U
    ? Demographic  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :
        P extends 'requirements' ? Array < RequirementGetPayload<S['include'][P]>>  :
        P extends '_count' ? DemographicCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :
        P extends 'requirements' ? Array < RequirementGetPayload<S['select'][P]>>  :
        P extends '_count' ? DemographicCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Demographic ? Demographic[P] : never
  } 
    : Demographic
  : Demographic


  type DemographicCountArgs = Merge<
    Omit<DemographicFindManyArgs, 'select' | 'include'> & {
      select?: DemographicCountAggregateInputType | true
    }
  >

  export interface DemographicDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Demographic that matches the filter.
     * @param {DemographicFindUniqueArgs} args - Arguments to find a Demographic
     * @example
     * // Get one Demographic
     * const demographic = await prisma.demographic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DemographicFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DemographicFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Demographic'> extends True ? CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>> : CheckSelect<T, Prisma__DemographicClient<Demographic | null >, Prisma__DemographicClient<DemographicGetPayload<T> | null >>

    /**
     * Find the first Demographic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicFindFirstArgs} args - Arguments to find a Demographic
     * @example
     * // Get one Demographic
     * const demographic = await prisma.demographic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DemographicFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DemographicFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Demographic'> extends True ? CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>> : CheckSelect<T, Prisma__DemographicClient<Demographic | null >, Prisma__DemographicClient<DemographicGetPayload<T> | null >>

    /**
     * Find zero or more Demographics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demographics
     * const demographics = await prisma.demographic.findMany()
     * 
     * // Get first 10 Demographics
     * const demographics = await prisma.demographic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demographicWithIdOnly = await prisma.demographic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DemographicFindManyArgs>(
      args?: SelectSubset<T, DemographicFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Demographic>>, PrismaPromise<Array<DemographicGetPayload<T>>>>

    /**
     * Create a Demographic.
     * @param {DemographicCreateArgs} args - Arguments to create a Demographic.
     * @example
     * // Create one Demographic
     * const Demographic = await prisma.demographic.create({
     *   data: {
     *     // ... data to create a Demographic
     *   }
     * })
     * 
    **/
    create<T extends DemographicCreateArgs>(
      args: SelectSubset<T, DemographicCreateArgs>
    ): CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>>

    /**
     * Create many Demographics.
     *     @param {DemographicCreateManyArgs} args - Arguments to create many Demographics.
     *     @example
     *     // Create many Demographics
     *     const demographic = await prisma.demographic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DemographicCreateManyArgs>(
      args?: SelectSubset<T, DemographicCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Demographic.
     * @param {DemographicDeleteArgs} args - Arguments to delete one Demographic.
     * @example
     * // Delete one Demographic
     * const Demographic = await prisma.demographic.delete({
     *   where: {
     *     // ... filter to delete one Demographic
     *   }
     * })
     * 
    **/
    delete<T extends DemographicDeleteArgs>(
      args: SelectSubset<T, DemographicDeleteArgs>
    ): CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>>

    /**
     * Update one Demographic.
     * @param {DemographicUpdateArgs} args - Arguments to update one Demographic.
     * @example
     * // Update one Demographic
     * const demographic = await prisma.demographic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DemographicUpdateArgs>(
      args: SelectSubset<T, DemographicUpdateArgs>
    ): CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>>

    /**
     * Delete zero or more Demographics.
     * @param {DemographicDeleteManyArgs} args - Arguments to filter Demographics to delete.
     * @example
     * // Delete a few Demographics
     * const { count } = await prisma.demographic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DemographicDeleteManyArgs>(
      args?: SelectSubset<T, DemographicDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demographics
     * const demographic = await prisma.demographic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DemographicUpdateManyArgs>(
      args: SelectSubset<T, DemographicUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Demographic.
     * @param {DemographicUpsertArgs} args - Arguments to update or create a Demographic.
     * @example
     * // Update or create a Demographic
     * const demographic = await prisma.demographic.upsert({
     *   create: {
     *     // ... data to create a Demographic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demographic we want to update
     *   }
     * })
    **/
    upsert<T extends DemographicUpsertArgs>(
      args: SelectSubset<T, DemographicUpsertArgs>
    ): CheckSelect<T, Prisma__DemographicClient<Demographic>, Prisma__DemographicClient<DemographicGetPayload<T>>>

    /**
     * Count the number of Demographics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicCountArgs} args - Arguments to filter Demographics to count.
     * @example
     * // Count the number of Demographics
     * const count = await prisma.demographic.count({
     *   where: {
     *     // ... the filter for the Demographics we want to count
     *   }
     * })
    **/
    count<T extends DemographicCountArgs>(
      args?: Subset<T, DemographicCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemographicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demographic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemographicAggregateArgs>(args: Subset<T, DemographicAggregateArgs>): PrismaPromise<GetDemographicAggregateType<T>>

    /**
     * Group by Demographic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemographicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DemographicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DemographicGroupByArgs['orderBy'] }
        : { orderBy?: DemographicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DemographicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemographicGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Demographic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DemographicClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    requirements<T extends RequirementFindManyArgs = {}>(args?: Subset<T, RequirementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Requirement>>, PrismaPromise<Array<RequirementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Demographic findUnique
   */
  export type DemographicFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * Throw an Error if a Demographic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Demographic to fetch.
     * 
    **/
    where: DemographicWhereUniqueInput
  }


  /**
   * Demographic findFirst
   */
  export type DemographicFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * Throw an Error if a Demographic can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Demographic to fetch.
     * 
    **/
    where?: DemographicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     * 
    **/
    orderBy?: Enumerable<DemographicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Demographics.
     * 
    **/
    cursor?: DemographicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Demographics.
     * 
    **/
    distinct?: Enumerable<DemographicScalarFieldEnum>
  }


  /**
   * Demographic findMany
   */
  export type DemographicFindManyArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * Filter, which Demographics to fetch.
     * 
    **/
    where?: DemographicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Demographics to fetch.
     * 
    **/
    orderBy?: Enumerable<DemographicOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Demographics.
     * 
    **/
    cursor?: DemographicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Demographics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Demographics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DemographicScalarFieldEnum>
  }


  /**
   * Demographic create
   */
  export type DemographicCreateArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * The data needed to create a Demographic.
     * 
    **/
    data: XOR<DemographicCreateInput, DemographicUncheckedCreateInput>
  }


  /**
   * Demographic createMany
   */
  export type DemographicCreateManyArgs = {
    /**
     * The data used to create many Demographics.
     * 
    **/
    data: Enumerable<DemographicCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Demographic update
   */
  export type DemographicUpdateArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * The data needed to update a Demographic.
     * 
    **/
    data: XOR<DemographicUpdateInput, DemographicUncheckedUpdateInput>
    /**
     * Choose, which Demographic to update.
     * 
    **/
    where: DemographicWhereUniqueInput
  }


  /**
   * Demographic updateMany
   */
  export type DemographicUpdateManyArgs = {
    /**
     * The data used to update Demographics.
     * 
    **/
    data: XOR<DemographicUpdateManyMutationInput, DemographicUncheckedUpdateManyInput>
    /**
     * Filter which Demographics to update
     * 
    **/
    where?: DemographicWhereInput
  }


  /**
   * Demographic upsert
   */
  export type DemographicUpsertArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * The filter to search for the Demographic to update in case it exists.
     * 
    **/
    where: DemographicWhereUniqueInput
    /**
     * In case the Demographic found by the `where` argument doesn't exist, create a new Demographic with this data.
     * 
    **/
    create: XOR<DemographicCreateInput, DemographicUncheckedCreateInput>
    /**
     * In case the Demographic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DemographicUpdateInput, DemographicUncheckedUpdateInput>
  }


  /**
   * Demographic delete
   */
  export type DemographicDeleteArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
    /**
     * Filter which Demographic to delete.
     * 
    **/
    where: DemographicWhereUniqueInput
  }


  /**
   * Demographic deleteMany
   */
  export type DemographicDeleteManyArgs = {
    /**
     * Filter which Demographics to delete
     * 
    **/
    where?: DemographicWhereInput
  }


  /**
   * Demographic without action
   */
  export type DemographicArgs = {
    /**
     * Select specific fields to fetch from the Demographic
     * 
    **/
    select?: DemographicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DemographicInclude | null
  }



  /**
   * Model Requirement
   */


  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  export type RequirementMinAggregateOutputType = {
    id: string | null
    content: string | null
  }

  export type RequirementMaxAggregateOutputType = {
    id: string | null
    content: string | null
  }

  export type RequirementCountAggregateOutputType = {
    id: number
    content: number
    _all: number
  }


  export type RequirementMinAggregateInputType = {
    id?: true
    content?: true
  }

  export type RequirementMaxAggregateInputType = {
    id?: true
    content?: true
  }

  export type RequirementCountAggregateInputType = {
    id?: true
    content?: true
    _all?: true
  }

  export type RequirementAggregateArgs = {
    /**
     * Filter which Requirement to aggregate.
     * 
    **/
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     * 
    **/
    orderBy?: Enumerable<RequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requirements
    **/
    _count?: true | RequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementMaxAggregateInputType
  }

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement[P]>
      : GetScalarType<T[P], AggregateRequirement[P]>
  }




  export type RequirementGroupByArgs = {
    where?: RequirementWhereInput
    orderBy?: Enumerable<RequirementOrderByWithAggregationInput>
    by: Array<RequirementScalarFieldEnum>
    having?: RequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementCountAggregateInputType | true
    _min?: RequirementMinAggregateInputType
    _max?: RequirementMaxAggregateInputType
  }


  export type RequirementGroupByOutputType = {
    id: string
    content: string
    _count: RequirementCountAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>
        }
      >
    >


  export type RequirementSelect = {
    id?: boolean
    content?: boolean
    demographics?: boolean | DemographicFindManyArgs
    _count?: boolean | RequirementCountOutputTypeArgs
  }

  export type RequirementInclude = {
    demographics?: boolean | DemographicFindManyArgs
    _count?: boolean | RequirementCountOutputTypeArgs
  }

  export type RequirementGetPayload<
    S extends boolean | null | undefined | RequirementArgs,
    U = keyof S
      > = S extends true
        ? Requirement
    : S extends undefined
    ? never
    : S extends RequirementArgs | RequirementFindManyArgs
    ?'include' extends U
    ? Requirement  & {
    [P in TrueKeys<S['include']>]:
        P extends 'demographics' ? Array < DemographicGetPayload<S['include'][P]>>  :
        P extends '_count' ? RequirementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'demographics' ? Array < DemographicGetPayload<S['select'][P]>>  :
        P extends '_count' ? RequirementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Requirement ? Requirement[P] : never
  } 
    : Requirement
  : Requirement


  type RequirementCountArgs = Merge<
    Omit<RequirementFindManyArgs, 'select' | 'include'> & {
      select?: RequirementCountAggregateInputType | true
    }
  >

  export interface RequirementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequirementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequirementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Requirement'> extends True ? CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>> : CheckSelect<T, Prisma__RequirementClient<Requirement | null >, Prisma__RequirementClient<RequirementGetPayload<T> | null >>

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequirementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequirementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Requirement'> extends True ? CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>> : CheckSelect<T, Prisma__RequirementClient<Requirement | null >, Prisma__RequirementClient<RequirementGetPayload<T> | null >>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequirementFindManyArgs>(
      args?: SelectSubset<T, RequirementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Requirement>>, PrismaPromise<Array<RequirementGetPayload<T>>>>

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     * 
    **/
    create<T extends RequirementCreateArgs>(
      args: SelectSubset<T, RequirementCreateArgs>
    ): CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>>

    /**
     * Create many Requirements.
     *     @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     *     @example
     *     // Create many Requirements
     *     const requirement = await prisma.requirement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequirementCreateManyArgs>(
      args?: SelectSubset<T, RequirementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     * 
    **/
    delete<T extends RequirementDeleteArgs>(
      args: SelectSubset<T, RequirementDeleteArgs>
    ): CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>>

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequirementUpdateArgs>(
      args: SelectSubset<T, RequirementUpdateArgs>
    ): CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>>

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequirementDeleteManyArgs>(
      args?: SelectSubset<T, RequirementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequirementUpdateManyArgs>(
      args: SelectSubset<T, RequirementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
    **/
    upsert<T extends RequirementUpsertArgs>(
      args: SelectSubset<T, RequirementUpsertArgs>
    ): CheckSelect<T, Prisma__RequirementClient<Requirement>, Prisma__RequirementClient<RequirementGetPayload<T>>>

    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAggregateArgs>(args: Subset<T, RequirementAggregateArgs>): PrismaPromise<GetRequirementAggregateType<T>>

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequirementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    demographics<T extends DemographicFindManyArgs = {}>(args?: Subset<T, DemographicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Demographic>>, PrismaPromise<Array<DemographicGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * Throw an Error if a Requirement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Requirement to fetch.
     * 
    **/
    where: RequirementWhereUniqueInput
  }


  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * Throw an Error if a Requirement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Requirement to fetch.
     * 
    **/
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     * 
    **/
    orderBy?: Enumerable<RequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     * 
    **/
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     * 
    **/
    distinct?: Enumerable<RequirementScalarFieldEnum>
  }


  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * Filter, which Requirements to fetch.
     * 
    **/
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     * 
    **/
    orderBy?: Enumerable<RequirementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requirements.
     * 
    **/
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequirementScalarFieldEnum>
  }


  /**
   * Requirement create
   */
  export type RequirementCreateArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * The data needed to create a Requirement.
     * 
    **/
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
  }


  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs = {
    /**
     * The data used to create many Requirements.
     * 
    **/
    data: Enumerable<RequirementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Requirement update
   */
  export type RequirementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * The data needed to update a Requirement.
     * 
    **/
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
    /**
     * Choose, which Requirement to update.
     * 
    **/
    where: RequirementWhereUniqueInput
  }


  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs = {
    /**
     * The data used to update Requirements.
     * 
    **/
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     * 
    **/
    where?: RequirementWhereInput
  }


  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * The filter to search for the Requirement to update in case it exists.
     * 
    **/
    where: RequirementWhereUniqueInput
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     * 
    **/
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
  }


  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
    /**
     * Filter which Requirement to delete.
     * 
    **/
    where: RequirementWhereUniqueInput
  }


  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs = {
    /**
     * Filter which Requirements to delete
     * 
    **/
    where?: RequirementWhereInput
  }


  /**
   * Requirement without action
   */
  export type RequirementArgs = {
    /**
     * Select specific fields to fetch from the Requirement
     * 
    **/
    select?: RequirementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequirementInclude | null
  }



  /**
   * Model RequestorInformation
   */


  export type AggregateRequestorInformation = {
    _count: RequestorInformationCountAggregateOutputType | null
    _min: RequestorInformationMinAggregateOutputType | null
    _max: RequestorInformationMaxAggregateOutputType | null
  }

  export type RequestorInformationMinAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    title: string | null
    email: string | null
    phone: string | null
  }

  export type RequestorInformationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    organization: string | null
    title: string | null
    email: string | null
    phone: string | null
  }

  export type RequestorInformationCountAggregateOutputType = {
    id: number
    name: number
    organization: number
    title: number
    email: number
    phone: number
    _all: number
  }


  export type RequestorInformationMinAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    title?: true
    email?: true
    phone?: true
  }

  export type RequestorInformationMaxAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    title?: true
    email?: true
    phone?: true
  }

  export type RequestorInformationCountAggregateInputType = {
    id?: true
    name?: true
    organization?: true
    title?: true
    email?: true
    phone?: true
    _all?: true
  }

  export type RequestorInformationAggregateArgs = {
    /**
     * Filter which RequestorInformation to aggregate.
     * 
    **/
    where?: RequestorInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestorInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestorInformationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RequestorInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestorInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestorInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestorInformations
    **/
    _count?: true | RequestorInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestorInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestorInformationMaxAggregateInputType
  }

  export type GetRequestorInformationAggregateType<T extends RequestorInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestorInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestorInformation[P]>
      : GetScalarType<T[P], AggregateRequestorInformation[P]>
  }




  export type RequestorInformationGroupByArgs = {
    where?: RequestorInformationWhereInput
    orderBy?: Enumerable<RequestorInformationOrderByWithAggregationInput>
    by: Array<RequestorInformationScalarFieldEnum>
    having?: RequestorInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestorInformationCountAggregateInputType | true
    _min?: RequestorInformationMinAggregateInputType
    _max?: RequestorInformationMaxAggregateInputType
  }


  export type RequestorInformationGroupByOutputType = {
    id: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
    _count: RequestorInformationCountAggregateOutputType | null
    _min: RequestorInformationMinAggregateOutputType | null
    _max: RequestorInformationMaxAggregateOutputType | null
  }

  type GetRequestorInformationGroupByPayload<T extends RequestorInformationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RequestorInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestorInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestorInformationGroupByOutputType[P]>
            : GetScalarType<T[P], RequestorInformationGroupByOutputType[P]>
        }
      >
    >


  export type RequestorInformationSelect = {
    id?: boolean
    name?: boolean
    organization?: boolean
    title?: boolean
    email?: boolean
    phone?: boolean
    engagement?: boolean | EngagementArgs
  }

  export type RequestorInformationInclude = {
    engagement?: boolean | EngagementArgs
  }

  export type RequestorInformationGetPayload<
    S extends boolean | null | undefined | RequestorInformationArgs,
    U = keyof S
      > = S extends true
        ? RequestorInformation
    : S extends undefined
    ? never
    : S extends RequestorInformationArgs | RequestorInformationFindManyArgs
    ?'include' extends U
    ? RequestorInformation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :  P extends keyof RequestorInformation ? RequestorInformation[P] : never
  } 
    : RequestorInformation
  : RequestorInformation


  type RequestorInformationCountArgs = Merge<
    Omit<RequestorInformationFindManyArgs, 'select' | 'include'> & {
      select?: RequestorInformationCountAggregateInputType | true
    }
  >

  export interface RequestorInformationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RequestorInformation that matches the filter.
     * @param {RequestorInformationFindUniqueArgs} args - Arguments to find a RequestorInformation
     * @example
     * // Get one RequestorInformation
     * const requestorInformation = await prisma.requestorInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestorInformationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestorInformationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RequestorInformation'> extends True ? CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>> : CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation | null >, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T> | null >>

    /**
     * Find the first RequestorInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationFindFirstArgs} args - Arguments to find a RequestorInformation
     * @example
     * // Get one RequestorInformation
     * const requestorInformation = await prisma.requestorInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestorInformationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestorInformationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RequestorInformation'> extends True ? CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>> : CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation | null >, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T> | null >>

    /**
     * Find zero or more RequestorInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestorInformations
     * const requestorInformations = await prisma.requestorInformation.findMany()
     * 
     * // Get first 10 RequestorInformations
     * const requestorInformations = await prisma.requestorInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestorInformationWithIdOnly = await prisma.requestorInformation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestorInformationFindManyArgs>(
      args?: SelectSubset<T, RequestorInformationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RequestorInformation>>, PrismaPromise<Array<RequestorInformationGetPayload<T>>>>

    /**
     * Create a RequestorInformation.
     * @param {RequestorInformationCreateArgs} args - Arguments to create a RequestorInformation.
     * @example
     * // Create one RequestorInformation
     * const RequestorInformation = await prisma.requestorInformation.create({
     *   data: {
     *     // ... data to create a RequestorInformation
     *   }
     * })
     * 
    **/
    create<T extends RequestorInformationCreateArgs>(
      args: SelectSubset<T, RequestorInformationCreateArgs>
    ): CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>>

    /**
     * Create many RequestorInformations.
     *     @param {RequestorInformationCreateManyArgs} args - Arguments to create many RequestorInformations.
     *     @example
     *     // Create many RequestorInformations
     *     const requestorInformation = await prisma.requestorInformation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestorInformationCreateManyArgs>(
      args?: SelectSubset<T, RequestorInformationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RequestorInformation.
     * @param {RequestorInformationDeleteArgs} args - Arguments to delete one RequestorInformation.
     * @example
     * // Delete one RequestorInformation
     * const RequestorInformation = await prisma.requestorInformation.delete({
     *   where: {
     *     // ... filter to delete one RequestorInformation
     *   }
     * })
     * 
    **/
    delete<T extends RequestorInformationDeleteArgs>(
      args: SelectSubset<T, RequestorInformationDeleteArgs>
    ): CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>>

    /**
     * Update one RequestorInformation.
     * @param {RequestorInformationUpdateArgs} args - Arguments to update one RequestorInformation.
     * @example
     * // Update one RequestorInformation
     * const requestorInformation = await prisma.requestorInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestorInformationUpdateArgs>(
      args: SelectSubset<T, RequestorInformationUpdateArgs>
    ): CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>>

    /**
     * Delete zero or more RequestorInformations.
     * @param {RequestorInformationDeleteManyArgs} args - Arguments to filter RequestorInformations to delete.
     * @example
     * // Delete a few RequestorInformations
     * const { count } = await prisma.requestorInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestorInformationDeleteManyArgs>(
      args?: SelectSubset<T, RequestorInformationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestorInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestorInformations
     * const requestorInformation = await prisma.requestorInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestorInformationUpdateManyArgs>(
      args: SelectSubset<T, RequestorInformationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestorInformation.
     * @param {RequestorInformationUpsertArgs} args - Arguments to update or create a RequestorInformation.
     * @example
     * // Update or create a RequestorInformation
     * const requestorInformation = await prisma.requestorInformation.upsert({
     *   create: {
     *     // ... data to create a RequestorInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestorInformation we want to update
     *   }
     * })
    **/
    upsert<T extends RequestorInformationUpsertArgs>(
      args: SelectSubset<T, RequestorInformationUpsertArgs>
    ): CheckSelect<T, Prisma__RequestorInformationClient<RequestorInformation>, Prisma__RequestorInformationClient<RequestorInformationGetPayload<T>>>

    /**
     * Count the number of RequestorInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationCountArgs} args - Arguments to filter RequestorInformations to count.
     * @example
     * // Count the number of RequestorInformations
     * const count = await prisma.requestorInformation.count({
     *   where: {
     *     // ... the filter for the RequestorInformations we want to count
     *   }
     * })
    **/
    count<T extends RequestorInformationCountArgs>(
      args?: Subset<T, RequestorInformationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestorInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestorInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestorInformationAggregateArgs>(args: Subset<T, RequestorInformationAggregateArgs>): PrismaPromise<GetRequestorInformationAggregateType<T>>

    /**
     * Group by RequestorInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestorInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestorInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestorInformationGroupByArgs['orderBy'] }
        : { orderBy?: RequestorInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestorInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestorInformationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestorInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestorInformationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RequestorInformation findUnique
   */
  export type RequestorInformationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * Throw an Error if a RequestorInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestorInformation to fetch.
     * 
    **/
    where: RequestorInformationWhereUniqueInput
  }


  /**
   * RequestorInformation findFirst
   */
  export type RequestorInformationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * Throw an Error if a RequestorInformation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RequestorInformation to fetch.
     * 
    **/
    where?: RequestorInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestorInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestorInformationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestorInformations.
     * 
    **/
    cursor?: RequestorInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestorInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestorInformations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestorInformations.
     * 
    **/
    distinct?: Enumerable<RequestorInformationScalarFieldEnum>
  }


  /**
   * RequestorInformation findMany
   */
  export type RequestorInformationFindManyArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * Filter, which RequestorInformations to fetch.
     * 
    **/
    where?: RequestorInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestorInformations to fetch.
     * 
    **/
    orderBy?: Enumerable<RequestorInformationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestorInformations.
     * 
    **/
    cursor?: RequestorInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestorInformations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestorInformations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RequestorInformationScalarFieldEnum>
  }


  /**
   * RequestorInformation create
   */
  export type RequestorInformationCreateArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * The data needed to create a RequestorInformation.
     * 
    **/
    data: XOR<RequestorInformationCreateInput, RequestorInformationUncheckedCreateInput>
  }


  /**
   * RequestorInformation createMany
   */
  export type RequestorInformationCreateManyArgs = {
    /**
     * The data used to create many RequestorInformations.
     * 
    **/
    data: Enumerable<RequestorInformationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RequestorInformation update
   */
  export type RequestorInformationUpdateArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * The data needed to update a RequestorInformation.
     * 
    **/
    data: XOR<RequestorInformationUpdateInput, RequestorInformationUncheckedUpdateInput>
    /**
     * Choose, which RequestorInformation to update.
     * 
    **/
    where: RequestorInformationWhereUniqueInput
  }


  /**
   * RequestorInformation updateMany
   */
  export type RequestorInformationUpdateManyArgs = {
    /**
     * The data used to update RequestorInformations.
     * 
    **/
    data: XOR<RequestorInformationUpdateManyMutationInput, RequestorInformationUncheckedUpdateManyInput>
    /**
     * Filter which RequestorInformations to update
     * 
    **/
    where?: RequestorInformationWhereInput
  }


  /**
   * RequestorInformation upsert
   */
  export type RequestorInformationUpsertArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * The filter to search for the RequestorInformation to update in case it exists.
     * 
    **/
    where: RequestorInformationWhereUniqueInput
    /**
     * In case the RequestorInformation found by the `where` argument doesn't exist, create a new RequestorInformation with this data.
     * 
    **/
    create: XOR<RequestorInformationCreateInput, RequestorInformationUncheckedCreateInput>
    /**
     * In case the RequestorInformation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RequestorInformationUpdateInput, RequestorInformationUncheckedUpdateInput>
  }


  /**
   * RequestorInformation delete
   */
  export type RequestorInformationDeleteArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
    /**
     * Filter which RequestorInformation to delete.
     * 
    **/
    where: RequestorInformationWhereUniqueInput
  }


  /**
   * RequestorInformation deleteMany
   */
  export type RequestorInformationDeleteManyArgs = {
    /**
     * Filter which RequestorInformations to delete
     * 
    **/
    where?: RequestorInformationWhereInput
  }


  /**
   * RequestorInformation without action
   */
  export type RequestorInformationArgs = {
    /**
     * Select specific fields to fetch from the RequestorInformation
     * 
    **/
    select?: RequestorInformationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RequestorInformationInclude | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    title: string | null
    description: string | null
    engagementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    title: string | null
    description: string | null
    engagementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    title: number
    description: number
    engagementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    title?: true
    description?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    title?: true
    description?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    title?: true
    description?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs = {
    /**
     * Filter which Event to aggregate.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithAggregationInput>
    by: Array<EventScalarFieldEnum>
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    title: string
    description: string
    engagementId: string
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    title?: boolean
    description?: boolean
    engagement?: boolean | EngagementArgs
    engagementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude = {
    engagement?: boolean | EngagementArgs
  }

  export type EventGetPayload<
    S extends boolean | null | undefined | EventArgs,
    U = keyof S
      > = S extends true
        ? Event
    : S extends undefined
    ? never
    : S extends EventArgs | EventFindManyArgs
    ?'include' extends U
    ? Event  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :  P extends keyof Event ? Event[P] : never
  } 
    : Event
  : Event


  type EventCountArgs = Merge<
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }
  >

  export interface EventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event findFirst
   */
  export type EventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     * 
    **/
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to create a Event.
     * 
    **/
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs = {
    /**
     * The data used to create many Events.
     * 
    **/
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to update a Event.
     * 
    **/
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs = {
    /**
     * The data used to update Events.
     * 
    **/
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     * 
    **/
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The filter to search for the Event to update in case it exists.
     * 
    **/
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     * 
    **/
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter which Event to delete.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs = {
    /**
     * Filter which Events to delete
     * 
    **/
    where?: EventWhereInput
  }


  /**
   * Event without action
   */
  export type EventArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
  }



  /**
   * Model DueDate
   */


  export type AggregateDueDate = {
    _count: DueDateCountAggregateOutputType | null
    _min: DueDateMinAggregateOutputType | null
    _max: DueDateMaxAggregateOutputType | null
  }

  export type DueDateMinAggregateOutputType = {
    id: string | null
    title: string | null
    dueDate: Date | null
    engagementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDateMaxAggregateOutputType = {
    id: string | null
    title: string | null
    dueDate: Date | null
    engagementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DueDateCountAggregateOutputType = {
    id: number
    title: number
    dueDate: number
    engagementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DueDateMinAggregateInputType = {
    id?: true
    title?: true
    dueDate?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDateMaxAggregateInputType = {
    id?: true
    title?: true
    dueDate?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DueDateCountAggregateInputType = {
    id?: true
    title?: true
    dueDate?: true
    engagementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DueDateAggregateArgs = {
    /**
     * Filter which DueDate to aggregate.
     * 
    **/
    where?: DueDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDates to fetch.
     * 
    **/
    orderBy?: Enumerable<DueDateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DueDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DueDates
    **/
    _count?: true | DueDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DueDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DueDateMaxAggregateInputType
  }

  export type GetDueDateAggregateType<T extends DueDateAggregateArgs> = {
        [P in keyof T & keyof AggregateDueDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDueDate[P]>
      : GetScalarType<T[P], AggregateDueDate[P]>
  }




  export type DueDateGroupByArgs = {
    where?: DueDateWhereInput
    orderBy?: Enumerable<DueDateOrderByWithAggregationInput>
    by: Array<DueDateScalarFieldEnum>
    having?: DueDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DueDateCountAggregateInputType | true
    _min?: DueDateMinAggregateInputType
    _max?: DueDateMaxAggregateInputType
  }


  export type DueDateGroupByOutputType = {
    id: string
    title: string
    dueDate: Date
    engagementId: string
    createdAt: Date
    updatedAt: Date
    _count: DueDateCountAggregateOutputType | null
    _min: DueDateMinAggregateOutputType | null
    _max: DueDateMaxAggregateOutputType | null
  }

  type GetDueDateGroupByPayload<T extends DueDateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DueDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DueDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DueDateGroupByOutputType[P]>
            : GetScalarType<T[P], DueDateGroupByOutputType[P]>
        }
      >
    >


  export type DueDateSelect = {
    id?: boolean
    title?: boolean
    dueDate?: boolean
    engagement?: boolean | EngagementArgs
    engagementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DueDateInclude = {
    engagement?: boolean | EngagementArgs
  }

  export type DueDateGetPayload<
    S extends boolean | null | undefined | DueDateArgs,
    U = keyof S
      > = S extends true
        ? DueDate
    : S extends undefined
    ? never
    : S extends DueDateArgs | DueDateFindManyArgs
    ?'include' extends U
    ? DueDate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :  P extends keyof DueDate ? DueDate[P] : never
  } 
    : DueDate
  : DueDate


  type DueDateCountArgs = Merge<
    Omit<DueDateFindManyArgs, 'select' | 'include'> & {
      select?: DueDateCountAggregateInputType | true
    }
  >

  export interface DueDateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DueDate that matches the filter.
     * @param {DueDateFindUniqueArgs} args - Arguments to find a DueDate
     * @example
     * // Get one DueDate
     * const dueDate = await prisma.dueDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DueDateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DueDateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DueDate'> extends True ? CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>> : CheckSelect<T, Prisma__DueDateClient<DueDate | null >, Prisma__DueDateClient<DueDateGetPayload<T> | null >>

    /**
     * Find the first DueDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateFindFirstArgs} args - Arguments to find a DueDate
     * @example
     * // Get one DueDate
     * const dueDate = await prisma.dueDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DueDateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DueDateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DueDate'> extends True ? CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>> : CheckSelect<T, Prisma__DueDateClient<DueDate | null >, Prisma__DueDateClient<DueDateGetPayload<T> | null >>

    /**
     * Find zero or more DueDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DueDates
     * const dueDates = await prisma.dueDate.findMany()
     * 
     * // Get first 10 DueDates
     * const dueDates = await prisma.dueDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dueDateWithIdOnly = await prisma.dueDate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DueDateFindManyArgs>(
      args?: SelectSubset<T, DueDateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DueDate>>, PrismaPromise<Array<DueDateGetPayload<T>>>>

    /**
     * Create a DueDate.
     * @param {DueDateCreateArgs} args - Arguments to create a DueDate.
     * @example
     * // Create one DueDate
     * const DueDate = await prisma.dueDate.create({
     *   data: {
     *     // ... data to create a DueDate
     *   }
     * })
     * 
    **/
    create<T extends DueDateCreateArgs>(
      args: SelectSubset<T, DueDateCreateArgs>
    ): CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>>

    /**
     * Create many DueDates.
     *     @param {DueDateCreateManyArgs} args - Arguments to create many DueDates.
     *     @example
     *     // Create many DueDates
     *     const dueDate = await prisma.dueDate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DueDateCreateManyArgs>(
      args?: SelectSubset<T, DueDateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DueDate.
     * @param {DueDateDeleteArgs} args - Arguments to delete one DueDate.
     * @example
     * // Delete one DueDate
     * const DueDate = await prisma.dueDate.delete({
     *   where: {
     *     // ... filter to delete one DueDate
     *   }
     * })
     * 
    **/
    delete<T extends DueDateDeleteArgs>(
      args: SelectSubset<T, DueDateDeleteArgs>
    ): CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>>

    /**
     * Update one DueDate.
     * @param {DueDateUpdateArgs} args - Arguments to update one DueDate.
     * @example
     * // Update one DueDate
     * const dueDate = await prisma.dueDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DueDateUpdateArgs>(
      args: SelectSubset<T, DueDateUpdateArgs>
    ): CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>>

    /**
     * Delete zero or more DueDates.
     * @param {DueDateDeleteManyArgs} args - Arguments to filter DueDates to delete.
     * @example
     * // Delete a few DueDates
     * const { count } = await prisma.dueDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DueDateDeleteManyArgs>(
      args?: SelectSubset<T, DueDateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DueDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DueDates
     * const dueDate = await prisma.dueDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DueDateUpdateManyArgs>(
      args: SelectSubset<T, DueDateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DueDate.
     * @param {DueDateUpsertArgs} args - Arguments to update or create a DueDate.
     * @example
     * // Update or create a DueDate
     * const dueDate = await prisma.dueDate.upsert({
     *   create: {
     *     // ... data to create a DueDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DueDate we want to update
     *   }
     * })
    **/
    upsert<T extends DueDateUpsertArgs>(
      args: SelectSubset<T, DueDateUpsertArgs>
    ): CheckSelect<T, Prisma__DueDateClient<DueDate>, Prisma__DueDateClient<DueDateGetPayload<T>>>

    /**
     * Count the number of DueDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateCountArgs} args - Arguments to filter DueDates to count.
     * @example
     * // Count the number of DueDates
     * const count = await prisma.dueDate.count({
     *   where: {
     *     // ... the filter for the DueDates we want to count
     *   }
     * })
    **/
    count<T extends DueDateCountArgs>(
      args?: Subset<T, DueDateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DueDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DueDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DueDateAggregateArgs>(args: Subset<T, DueDateAggregateArgs>): PrismaPromise<GetDueDateAggregateType<T>>

    /**
     * Group by DueDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DueDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DueDateGroupByArgs['orderBy'] }
        : { orderBy?: DueDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DueDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDueDateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DueDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DueDateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DueDate findUnique
   */
  export type DueDateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * Throw an Error if a DueDate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DueDate to fetch.
     * 
    **/
    where: DueDateWhereUniqueInput
  }


  /**
   * DueDate findFirst
   */
  export type DueDateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * Throw an Error if a DueDate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DueDate to fetch.
     * 
    **/
    where?: DueDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDates to fetch.
     * 
    **/
    orderBy?: Enumerable<DueDateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDates.
     * 
    **/
    cursor?: DueDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDates.
     * 
    **/
    distinct?: Enumerable<DueDateScalarFieldEnum>
  }


  /**
   * DueDate findMany
   */
  export type DueDateFindManyArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * Filter, which DueDates to fetch.
     * 
    **/
    where?: DueDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDates to fetch.
     * 
    **/
    orderBy?: Enumerable<DueDateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DueDates.
     * 
    **/
    cursor?: DueDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DueDateScalarFieldEnum>
  }


  /**
   * DueDate create
   */
  export type DueDateCreateArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * The data needed to create a DueDate.
     * 
    **/
    data: XOR<DueDateCreateInput, DueDateUncheckedCreateInput>
  }


  /**
   * DueDate createMany
   */
  export type DueDateCreateManyArgs = {
    /**
     * The data used to create many DueDates.
     * 
    **/
    data: Enumerable<DueDateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DueDate update
   */
  export type DueDateUpdateArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * The data needed to update a DueDate.
     * 
    **/
    data: XOR<DueDateUpdateInput, DueDateUncheckedUpdateInput>
    /**
     * Choose, which DueDate to update.
     * 
    **/
    where: DueDateWhereUniqueInput
  }


  /**
   * DueDate updateMany
   */
  export type DueDateUpdateManyArgs = {
    /**
     * The data used to update DueDates.
     * 
    **/
    data: XOR<DueDateUpdateManyMutationInput, DueDateUncheckedUpdateManyInput>
    /**
     * Filter which DueDates to update
     * 
    **/
    where?: DueDateWhereInput
  }


  /**
   * DueDate upsert
   */
  export type DueDateUpsertArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * The filter to search for the DueDate to update in case it exists.
     * 
    **/
    where: DueDateWhereUniqueInput
    /**
     * In case the DueDate found by the `where` argument doesn't exist, create a new DueDate with this data.
     * 
    **/
    create: XOR<DueDateCreateInput, DueDateUncheckedCreateInput>
    /**
     * In case the DueDate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DueDateUpdateInput, DueDateUncheckedUpdateInput>
  }


  /**
   * DueDate delete
   */
  export type DueDateDeleteArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
    /**
     * Filter which DueDate to delete.
     * 
    **/
    where: DueDateWhereUniqueInput
  }


  /**
   * DueDate deleteMany
   */
  export type DueDateDeleteManyArgs = {
    /**
     * Filter which DueDates to delete
     * 
    **/
    where?: DueDateWhereInput
  }


  /**
   * DueDate without action
   */
  export type DueDateArgs = {
    /**
     * Select specific fields to fetch from the DueDate
     * 
    **/
    select?: DueDateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DueDateInclude | null
  }



  /**
   * Model FeedbackConfig
   */


  export type AggregateFeedbackConfig = {
    _count: FeedbackConfigCountAggregateOutputType | null
    _min: FeedbackConfigMinAggregateOutputType | null
    _max: FeedbackConfigMaxAggregateOutputType | null
  }

  export type FeedbackConfigMinAggregateOutputType = {
    id: string | null
    feedbackType: FeedbackTypes | null
    isHumanResearch: boolean | null
    hasSubmissions: boolean | null
    freeFormQuestion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackConfigMaxAggregateOutputType = {
    id: string | null
    feedbackType: FeedbackTypes | null
    isHumanResearch: boolean | null
    hasSubmissions: boolean | null
    freeFormQuestion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackConfigCountAggregateOutputType = {
    id: number
    feedbackType: number
    isHumanResearch: number
    hasSubmissions: number
    freeFormQuestion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackConfigMinAggregateInputType = {
    id?: true
    feedbackType?: true
    isHumanResearch?: true
    hasSubmissions?: true
    freeFormQuestion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackConfigMaxAggregateInputType = {
    id?: true
    feedbackType?: true
    isHumanResearch?: true
    hasSubmissions?: true
    freeFormQuestion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackConfigCountAggregateInputType = {
    id?: true
    feedbackType?: true
    isHumanResearch?: true
    hasSubmissions?: true
    freeFormQuestion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackConfigAggregateArgs = {
    /**
     * Filter which FeedbackConfig to aggregate.
     * 
    **/
    where?: FeedbackConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackConfigs to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackConfigOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeedbackConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackConfigs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackConfigs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackConfigs
    **/
    _count?: true | FeedbackConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackConfigMaxAggregateInputType
  }

  export type GetFeedbackConfigAggregateType<T extends FeedbackConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackConfig[P]>
      : GetScalarType<T[P], AggregateFeedbackConfig[P]>
  }




  export type FeedbackConfigGroupByArgs = {
    where?: FeedbackConfigWhereInput
    orderBy?: Enumerable<FeedbackConfigOrderByWithAggregationInput>
    by: Array<FeedbackConfigScalarFieldEnum>
    having?: FeedbackConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackConfigCountAggregateInputType | true
    _min?: FeedbackConfigMinAggregateInputType
    _max?: FeedbackConfigMaxAggregateInputType
  }


  export type FeedbackConfigGroupByOutputType = {
    id: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    freeFormQuestion: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeedbackConfigCountAggregateOutputType | null
    _min: FeedbackConfigMinAggregateOutputType | null
    _max: FeedbackConfigMaxAggregateOutputType | null
  }

  type GetFeedbackConfigGroupByPayload<T extends FeedbackConfigGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeedbackConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackConfigGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackConfigGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackConfigSelect = {
    id?: boolean
    feedbackType?: boolean
    isHumanResearch?: boolean
    hasSubmissions?: boolean
    engagement?: boolean | EngagementArgs
    testFeedbackSubmissions?: boolean | TestFeedbackSubmissionFindManyArgs
    inputFeedbackSubmissions?: boolean | InputFeedbackSubmissionFindManyArgs
    freeFeedbackSubmissions?: boolean | FreeFeedbackSubmissionFindManyArgs
    freeFormQuestion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | FeedbackConfigCountOutputTypeArgs
  }

  export type FeedbackConfigInclude = {
    engagement?: boolean | EngagementArgs
    testFeedbackSubmissions?: boolean | TestFeedbackSubmissionFindManyArgs
    inputFeedbackSubmissions?: boolean | InputFeedbackSubmissionFindManyArgs
    freeFeedbackSubmissions?: boolean | FreeFeedbackSubmissionFindManyArgs
    _count?: boolean | FeedbackConfigCountOutputTypeArgs
  }

  export type FeedbackConfigGetPayload<
    S extends boolean | null | undefined | FeedbackConfigArgs,
    U = keyof S
      > = S extends true
        ? FeedbackConfig
    : S extends undefined
    ? never
    : S extends FeedbackConfigArgs | FeedbackConfigFindManyArgs
    ?'include' extends U
    ? FeedbackConfig  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :
        P extends 'testFeedbackSubmissions' ? Array < TestFeedbackSubmissionGetPayload<S['include'][P]>>  :
        P extends 'inputFeedbackSubmissions' ? Array < InputFeedbackSubmissionGetPayload<S['include'][P]>>  :
        P extends 'freeFeedbackSubmissions' ? Array < FreeFeedbackSubmissionGetPayload<S['include'][P]>>  :
        P extends '_count' ? FeedbackConfigCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :
        P extends 'testFeedbackSubmissions' ? Array < TestFeedbackSubmissionGetPayload<S['select'][P]>>  :
        P extends 'inputFeedbackSubmissions' ? Array < InputFeedbackSubmissionGetPayload<S['select'][P]>>  :
        P extends 'freeFeedbackSubmissions' ? Array < FreeFeedbackSubmissionGetPayload<S['select'][P]>>  :
        P extends '_count' ? FeedbackConfigCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FeedbackConfig ? FeedbackConfig[P] : never
  } 
    : FeedbackConfig
  : FeedbackConfig


  type FeedbackConfigCountArgs = Merge<
    Omit<FeedbackConfigFindManyArgs, 'select' | 'include'> & {
      select?: FeedbackConfigCountAggregateInputType | true
    }
  >

  export interface FeedbackConfigDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FeedbackConfig that matches the filter.
     * @param {FeedbackConfigFindUniqueArgs} args - Arguments to find a FeedbackConfig
     * @example
     * // Get one FeedbackConfig
     * const feedbackConfig = await prisma.feedbackConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackConfigFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeedbackConfigFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FeedbackConfig'> extends True ? CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>> : CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>

    /**
     * Find the first FeedbackConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigFindFirstArgs} args - Arguments to find a FeedbackConfig
     * @example
     * // Get one FeedbackConfig
     * const feedbackConfig = await prisma.feedbackConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackConfigFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeedbackConfigFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FeedbackConfig'> extends True ? CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>> : CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>

    /**
     * Find zero or more FeedbackConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackConfigs
     * const feedbackConfigs = await prisma.feedbackConfig.findMany()
     * 
     * // Get first 10 FeedbackConfigs
     * const feedbackConfigs = await prisma.feedbackConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackConfigWithIdOnly = await prisma.feedbackConfig.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackConfigFindManyArgs>(
      args?: SelectSubset<T, FeedbackConfigFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FeedbackConfig>>, PrismaPromise<Array<FeedbackConfigGetPayload<T>>>>

    /**
     * Create a FeedbackConfig.
     * @param {FeedbackConfigCreateArgs} args - Arguments to create a FeedbackConfig.
     * @example
     * // Create one FeedbackConfig
     * const FeedbackConfig = await prisma.feedbackConfig.create({
     *   data: {
     *     // ... data to create a FeedbackConfig
     *   }
     * })
     * 
    **/
    create<T extends FeedbackConfigCreateArgs>(
      args: SelectSubset<T, FeedbackConfigCreateArgs>
    ): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>>

    /**
     * Create many FeedbackConfigs.
     *     @param {FeedbackConfigCreateManyArgs} args - Arguments to create many FeedbackConfigs.
     *     @example
     *     // Create many FeedbackConfigs
     *     const feedbackConfig = await prisma.feedbackConfig.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackConfigCreateManyArgs>(
      args?: SelectSubset<T, FeedbackConfigCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackConfig.
     * @param {FeedbackConfigDeleteArgs} args - Arguments to delete one FeedbackConfig.
     * @example
     * // Delete one FeedbackConfig
     * const FeedbackConfig = await prisma.feedbackConfig.delete({
     *   where: {
     *     // ... filter to delete one FeedbackConfig
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackConfigDeleteArgs>(
      args: SelectSubset<T, FeedbackConfigDeleteArgs>
    ): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>>

    /**
     * Update one FeedbackConfig.
     * @param {FeedbackConfigUpdateArgs} args - Arguments to update one FeedbackConfig.
     * @example
     * // Update one FeedbackConfig
     * const feedbackConfig = await prisma.feedbackConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackConfigUpdateArgs>(
      args: SelectSubset<T, FeedbackConfigUpdateArgs>
    ): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>>

    /**
     * Delete zero or more FeedbackConfigs.
     * @param {FeedbackConfigDeleteManyArgs} args - Arguments to filter FeedbackConfigs to delete.
     * @example
     * // Delete a few FeedbackConfigs
     * const { count } = await prisma.feedbackConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackConfigDeleteManyArgs>(
      args?: SelectSubset<T, FeedbackConfigDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackConfigs
     * const feedbackConfig = await prisma.feedbackConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackConfigUpdateManyArgs>(
      args: SelectSubset<T, FeedbackConfigUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackConfig.
     * @param {FeedbackConfigUpsertArgs} args - Arguments to update or create a FeedbackConfig.
     * @example
     * // Update or create a FeedbackConfig
     * const feedbackConfig = await prisma.feedbackConfig.upsert({
     *   create: {
     *     // ... data to create a FeedbackConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackConfig we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackConfigUpsertArgs>(
      args: SelectSubset<T, FeedbackConfigUpsertArgs>
    ): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig>, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T>>>

    /**
     * Count the number of FeedbackConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigCountArgs} args - Arguments to filter FeedbackConfigs to count.
     * @example
     * // Count the number of FeedbackConfigs
     * const count = await prisma.feedbackConfig.count({
     *   where: {
     *     // ... the filter for the FeedbackConfigs we want to count
     *   }
     * })
    **/
    count<T extends FeedbackConfigCountArgs>(
      args?: Subset<T, FeedbackConfigCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackConfigAggregateArgs>(args: Subset<T, FeedbackConfigAggregateArgs>): PrismaPromise<GetFeedbackConfigAggregateType<T>>

    /**
     * Group by FeedbackConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackConfigGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackConfigGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeedbackConfigClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    testFeedbackSubmissions<T extends TestFeedbackSubmissionFindManyArgs = {}>(args?: Subset<T, TestFeedbackSubmissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TestFeedbackSubmission>>, PrismaPromise<Array<TestFeedbackSubmissionGetPayload<T>>>>;

    inputFeedbackSubmissions<T extends InputFeedbackSubmissionFindManyArgs = {}>(args?: Subset<T, InputFeedbackSubmissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<InputFeedbackSubmission>>, PrismaPromise<Array<InputFeedbackSubmissionGetPayload<T>>>>;

    freeFeedbackSubmissions<T extends FreeFeedbackSubmissionFindManyArgs = {}>(args?: Subset<T, FreeFeedbackSubmissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<FreeFeedbackSubmission>>, PrismaPromise<Array<FreeFeedbackSubmissionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FeedbackConfig findUnique
   */
  export type FeedbackConfigFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * Throw an Error if a FeedbackConfig can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeedbackConfig to fetch.
     * 
    **/
    where: FeedbackConfigWhereUniqueInput
  }


  /**
   * FeedbackConfig findFirst
   */
  export type FeedbackConfigFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * Throw an Error if a FeedbackConfig can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FeedbackConfig to fetch.
     * 
    **/
    where?: FeedbackConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackConfigs to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackConfigOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackConfigs.
     * 
    **/
    cursor?: FeedbackConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackConfigs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackConfigs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackConfigs.
     * 
    **/
    distinct?: Enumerable<FeedbackConfigScalarFieldEnum>
  }


  /**
   * FeedbackConfig findMany
   */
  export type FeedbackConfigFindManyArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * Filter, which FeedbackConfigs to fetch.
     * 
    **/
    where?: FeedbackConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackConfigs to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackConfigOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackConfigs.
     * 
    **/
    cursor?: FeedbackConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackConfigs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackConfigs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeedbackConfigScalarFieldEnum>
  }


  /**
   * FeedbackConfig create
   */
  export type FeedbackConfigCreateArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * The data needed to create a FeedbackConfig.
     * 
    **/
    data: XOR<FeedbackConfigCreateInput, FeedbackConfigUncheckedCreateInput>
  }


  /**
   * FeedbackConfig createMany
   */
  export type FeedbackConfigCreateManyArgs = {
    /**
     * The data used to create many FeedbackConfigs.
     * 
    **/
    data: Enumerable<FeedbackConfigCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FeedbackConfig update
   */
  export type FeedbackConfigUpdateArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * The data needed to update a FeedbackConfig.
     * 
    **/
    data: XOR<FeedbackConfigUpdateInput, FeedbackConfigUncheckedUpdateInput>
    /**
     * Choose, which FeedbackConfig to update.
     * 
    **/
    where: FeedbackConfigWhereUniqueInput
  }


  /**
   * FeedbackConfig updateMany
   */
  export type FeedbackConfigUpdateManyArgs = {
    /**
     * The data used to update FeedbackConfigs.
     * 
    **/
    data: XOR<FeedbackConfigUpdateManyMutationInput, FeedbackConfigUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackConfigs to update
     * 
    **/
    where?: FeedbackConfigWhereInput
  }


  /**
   * FeedbackConfig upsert
   */
  export type FeedbackConfigUpsertArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * The filter to search for the FeedbackConfig to update in case it exists.
     * 
    **/
    where: FeedbackConfigWhereUniqueInput
    /**
     * In case the FeedbackConfig found by the `where` argument doesn't exist, create a new FeedbackConfig with this data.
     * 
    **/
    create: XOR<FeedbackConfigCreateInput, FeedbackConfigUncheckedCreateInput>
    /**
     * In case the FeedbackConfig was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeedbackConfigUpdateInput, FeedbackConfigUncheckedUpdateInput>
  }


  /**
   * FeedbackConfig delete
   */
  export type FeedbackConfigDeleteArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
    /**
     * Filter which FeedbackConfig to delete.
     * 
    **/
    where: FeedbackConfigWhereUniqueInput
  }


  /**
   * FeedbackConfig deleteMany
   */
  export type FeedbackConfigDeleteManyArgs = {
    /**
     * Filter which FeedbackConfigs to delete
     * 
    **/
    where?: FeedbackConfigWhereInput
  }


  /**
   * FeedbackConfig without action
   */
  export type FeedbackConfigArgs = {
    /**
     * Select specific fields to fetch from the FeedbackConfig
     * 
    **/
    select?: FeedbackConfigSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackConfigInclude | null
  }



  /**
   * Model TestFeedbackSubmission
   */


  export type AggregateTestFeedbackSubmission = {
    _count: TestFeedbackSubmissionCountAggregateOutputType | null
    _min: TestFeedbackSubmissionMinAggregateOutputType | null
    _max: TestFeedbackSubmissionMaxAggregateOutputType | null
  }

  export type TestFeedbackSubmissionMinAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    rating: string | null
    testFeedbackResponseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestFeedbackSubmissionMaxAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    rating: string | null
    testFeedbackResponseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestFeedbackSubmissionCountAggregateOutputType = {
    id: number
    feedbackConfigId: number
    rating: number
    testFeedbackResponseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestFeedbackSubmissionMinAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    rating?: true
    testFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestFeedbackSubmissionMaxAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    rating?: true
    testFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestFeedbackSubmissionCountAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    rating?: true
    testFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestFeedbackSubmissionAggregateArgs = {
    /**
     * Filter which TestFeedbackSubmission to aggregate.
     * 
    **/
    where?: TestFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TestFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestFeedbackSubmissions
    **/
    _count?: true | TestFeedbackSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestFeedbackSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestFeedbackSubmissionMaxAggregateInputType
  }

  export type GetTestFeedbackSubmissionAggregateType<T extends TestFeedbackSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateTestFeedbackSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestFeedbackSubmission[P]>
      : GetScalarType<T[P], AggregateTestFeedbackSubmission[P]>
  }




  export type TestFeedbackSubmissionGroupByArgs = {
    where?: TestFeedbackSubmissionWhereInput
    orderBy?: Enumerable<TestFeedbackSubmissionOrderByWithAggregationInput>
    by: Array<TestFeedbackSubmissionScalarFieldEnum>
    having?: TestFeedbackSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestFeedbackSubmissionCountAggregateInputType | true
    _min?: TestFeedbackSubmissionMinAggregateInputType
    _max?: TestFeedbackSubmissionMaxAggregateInputType
  }


  export type TestFeedbackSubmissionGroupByOutputType = {
    id: string
    feedbackConfigId: string
    rating: string
    testFeedbackResponseId: string
    createdAt: Date
    updatedAt: Date
    _count: TestFeedbackSubmissionCountAggregateOutputType | null
    _min: TestFeedbackSubmissionMinAggregateOutputType | null
    _max: TestFeedbackSubmissionMaxAggregateOutputType | null
  }

  type GetTestFeedbackSubmissionGroupByPayload<T extends TestFeedbackSubmissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TestFeedbackSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestFeedbackSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestFeedbackSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], TestFeedbackSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type TestFeedbackSubmissionSelect = {
    id?: boolean
    feedbackConfig?: boolean | FeedbackConfigArgs
    feedbackConfigId?: boolean
    rating?: boolean
    testFeedbackResponses?: boolean | TestFeedbackResponsesArgs
    testFeedbackResponseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestFeedbackSubmissionInclude = {
    feedbackConfig?: boolean | FeedbackConfigArgs
    testFeedbackResponses?: boolean | TestFeedbackResponsesArgs
  }

  export type TestFeedbackSubmissionGetPayload<
    S extends boolean | null | undefined | TestFeedbackSubmissionArgs,
    U = keyof S
      > = S extends true
        ? TestFeedbackSubmission
    : S extends undefined
    ? never
    : S extends TestFeedbackSubmissionArgs | TestFeedbackSubmissionFindManyArgs
    ?'include' extends U
    ? TestFeedbackSubmission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['include'][P]> | null :
        P extends 'testFeedbackResponses' ? TestFeedbackResponsesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['select'][P]> | null :
        P extends 'testFeedbackResponses' ? TestFeedbackResponsesGetPayload<S['select'][P]> :  P extends keyof TestFeedbackSubmission ? TestFeedbackSubmission[P] : never
  } 
    : TestFeedbackSubmission
  : TestFeedbackSubmission


  type TestFeedbackSubmissionCountArgs = Merge<
    Omit<TestFeedbackSubmissionFindManyArgs, 'select' | 'include'> & {
      select?: TestFeedbackSubmissionCountAggregateInputType | true
    }
  >

  export interface TestFeedbackSubmissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TestFeedbackSubmission that matches the filter.
     * @param {TestFeedbackSubmissionFindUniqueArgs} args - Arguments to find a TestFeedbackSubmission
     * @example
     * // Get one TestFeedbackSubmission
     * const testFeedbackSubmission = await prisma.testFeedbackSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestFeedbackSubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TestFeedbackSubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TestFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission | null >, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find the first TestFeedbackSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionFindFirstArgs} args - Arguments to find a TestFeedbackSubmission
     * @example
     * // Get one TestFeedbackSubmission
     * const testFeedbackSubmission = await prisma.testFeedbackSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestFeedbackSubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TestFeedbackSubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TestFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission | null >, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find zero or more TestFeedbackSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestFeedbackSubmissions
     * const testFeedbackSubmissions = await prisma.testFeedbackSubmission.findMany()
     * 
     * // Get first 10 TestFeedbackSubmissions
     * const testFeedbackSubmissions = await prisma.testFeedbackSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testFeedbackSubmissionWithIdOnly = await prisma.testFeedbackSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestFeedbackSubmissionFindManyArgs>(
      args?: SelectSubset<T, TestFeedbackSubmissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TestFeedbackSubmission>>, PrismaPromise<Array<TestFeedbackSubmissionGetPayload<T>>>>

    /**
     * Create a TestFeedbackSubmission.
     * @param {TestFeedbackSubmissionCreateArgs} args - Arguments to create a TestFeedbackSubmission.
     * @example
     * // Create one TestFeedbackSubmission
     * const TestFeedbackSubmission = await prisma.testFeedbackSubmission.create({
     *   data: {
     *     // ... data to create a TestFeedbackSubmission
     *   }
     * })
     * 
    **/
    create<T extends TestFeedbackSubmissionCreateArgs>(
      args: SelectSubset<T, TestFeedbackSubmissionCreateArgs>
    ): CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>>

    /**
     * Create many TestFeedbackSubmissions.
     *     @param {TestFeedbackSubmissionCreateManyArgs} args - Arguments to create many TestFeedbackSubmissions.
     *     @example
     *     // Create many TestFeedbackSubmissions
     *     const testFeedbackSubmission = await prisma.testFeedbackSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestFeedbackSubmissionCreateManyArgs>(
      args?: SelectSubset<T, TestFeedbackSubmissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TestFeedbackSubmission.
     * @param {TestFeedbackSubmissionDeleteArgs} args - Arguments to delete one TestFeedbackSubmission.
     * @example
     * // Delete one TestFeedbackSubmission
     * const TestFeedbackSubmission = await prisma.testFeedbackSubmission.delete({
     *   where: {
     *     // ... filter to delete one TestFeedbackSubmission
     *   }
     * })
     * 
    **/
    delete<T extends TestFeedbackSubmissionDeleteArgs>(
      args: SelectSubset<T, TestFeedbackSubmissionDeleteArgs>
    ): CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>>

    /**
     * Update one TestFeedbackSubmission.
     * @param {TestFeedbackSubmissionUpdateArgs} args - Arguments to update one TestFeedbackSubmission.
     * @example
     * // Update one TestFeedbackSubmission
     * const testFeedbackSubmission = await prisma.testFeedbackSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestFeedbackSubmissionUpdateArgs>(
      args: SelectSubset<T, TestFeedbackSubmissionUpdateArgs>
    ): CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>>

    /**
     * Delete zero or more TestFeedbackSubmissions.
     * @param {TestFeedbackSubmissionDeleteManyArgs} args - Arguments to filter TestFeedbackSubmissions to delete.
     * @example
     * // Delete a few TestFeedbackSubmissions
     * const { count } = await prisma.testFeedbackSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestFeedbackSubmissionDeleteManyArgs>(
      args?: SelectSubset<T, TestFeedbackSubmissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestFeedbackSubmissions
     * const testFeedbackSubmission = await prisma.testFeedbackSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestFeedbackSubmissionUpdateManyArgs>(
      args: SelectSubset<T, TestFeedbackSubmissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TestFeedbackSubmission.
     * @param {TestFeedbackSubmissionUpsertArgs} args - Arguments to update or create a TestFeedbackSubmission.
     * @example
     * // Update or create a TestFeedbackSubmission
     * const testFeedbackSubmission = await prisma.testFeedbackSubmission.upsert({
     *   create: {
     *     // ... data to create a TestFeedbackSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestFeedbackSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends TestFeedbackSubmissionUpsertArgs>(
      args: SelectSubset<T, TestFeedbackSubmissionUpsertArgs>
    ): CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission>, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T>>>

    /**
     * Count the number of TestFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionCountArgs} args - Arguments to filter TestFeedbackSubmissions to count.
     * @example
     * // Count the number of TestFeedbackSubmissions
     * const count = await prisma.testFeedbackSubmission.count({
     *   where: {
     *     // ... the filter for the TestFeedbackSubmissions we want to count
     *   }
     * })
    **/
    count<T extends TestFeedbackSubmissionCountArgs>(
      args?: Subset<T, TestFeedbackSubmissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestFeedbackSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestFeedbackSubmissionAggregateArgs>(args: Subset<T, TestFeedbackSubmissionAggregateArgs>): PrismaPromise<GetTestFeedbackSubmissionAggregateType<T>>

    /**
     * Group by TestFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestFeedbackSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestFeedbackSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: TestFeedbackSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestFeedbackSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestFeedbackSubmissionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestFeedbackSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TestFeedbackSubmissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    feedbackConfig<T extends FeedbackConfigArgs = {}>(args?: Subset<T, FeedbackConfigArgs>): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>;

    testFeedbackResponses<T extends TestFeedbackResponsesArgs = {}>(args?: Subset<T, TestFeedbackResponsesArgs>): CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses | null >, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TestFeedbackSubmission findUnique
   */
  export type TestFeedbackSubmissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a TestFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TestFeedbackSubmission to fetch.
     * 
    **/
    where: TestFeedbackSubmissionWhereUniqueInput
  }


  /**
   * TestFeedbackSubmission findFirst
   */
  export type TestFeedbackSubmissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a TestFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TestFeedbackSubmission to fetch.
     * 
    **/
    where?: TestFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestFeedbackSubmissions.
     * 
    **/
    cursor?: TestFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestFeedbackSubmissions.
     * 
    **/
    distinct?: Enumerable<TestFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * TestFeedbackSubmission findMany
   */
  export type TestFeedbackSubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * Filter, which TestFeedbackSubmissions to fetch.
     * 
    **/
    where?: TestFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestFeedbackSubmissions.
     * 
    **/
    cursor?: TestFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackSubmissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TestFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * TestFeedbackSubmission create
   */
  export type TestFeedbackSubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * The data needed to create a TestFeedbackSubmission.
     * 
    **/
    data: XOR<TestFeedbackSubmissionCreateInput, TestFeedbackSubmissionUncheckedCreateInput>
  }


  /**
   * TestFeedbackSubmission createMany
   */
  export type TestFeedbackSubmissionCreateManyArgs = {
    /**
     * The data used to create many TestFeedbackSubmissions.
     * 
    **/
    data: Enumerable<TestFeedbackSubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TestFeedbackSubmission update
   */
  export type TestFeedbackSubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * The data needed to update a TestFeedbackSubmission.
     * 
    **/
    data: XOR<TestFeedbackSubmissionUpdateInput, TestFeedbackSubmissionUncheckedUpdateInput>
    /**
     * Choose, which TestFeedbackSubmission to update.
     * 
    **/
    where: TestFeedbackSubmissionWhereUniqueInput
  }


  /**
   * TestFeedbackSubmission updateMany
   */
  export type TestFeedbackSubmissionUpdateManyArgs = {
    /**
     * The data used to update TestFeedbackSubmissions.
     * 
    **/
    data: XOR<TestFeedbackSubmissionUpdateManyMutationInput, TestFeedbackSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which TestFeedbackSubmissions to update
     * 
    **/
    where?: TestFeedbackSubmissionWhereInput
  }


  /**
   * TestFeedbackSubmission upsert
   */
  export type TestFeedbackSubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * The filter to search for the TestFeedbackSubmission to update in case it exists.
     * 
    **/
    where: TestFeedbackSubmissionWhereUniqueInput
    /**
     * In case the TestFeedbackSubmission found by the `where` argument doesn't exist, create a new TestFeedbackSubmission with this data.
     * 
    **/
    create: XOR<TestFeedbackSubmissionCreateInput, TestFeedbackSubmissionUncheckedCreateInput>
    /**
     * In case the TestFeedbackSubmission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TestFeedbackSubmissionUpdateInput, TestFeedbackSubmissionUncheckedUpdateInput>
  }


  /**
   * TestFeedbackSubmission delete
   */
  export type TestFeedbackSubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
    /**
     * Filter which TestFeedbackSubmission to delete.
     * 
    **/
    where: TestFeedbackSubmissionWhereUniqueInput
  }


  /**
   * TestFeedbackSubmission deleteMany
   */
  export type TestFeedbackSubmissionDeleteManyArgs = {
    /**
     * Filter which TestFeedbackSubmissions to delete
     * 
    **/
    where?: TestFeedbackSubmissionWhereInput
  }


  /**
   * TestFeedbackSubmission without action
   */
  export type TestFeedbackSubmissionArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackSubmission
     * 
    **/
    select?: TestFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackSubmissionInclude | null
  }



  /**
   * Model TestFeedbackResponses
   */


  export type AggregateTestFeedbackResponses = {
    _count: TestFeedbackResponsesCountAggregateOutputType | null
    _min: TestFeedbackResponsesMinAggregateOutputType | null
    _max: TestFeedbackResponsesMaxAggregateOutputType | null
  }

  export type TestFeedbackResponsesMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    customResponse: string | null
    results: string | null
    anticipatedResults: string | null
    conditionsConstraints: string | null
    metExpectations: string | null
    notMetExpectations: string | null
    otherOpportunities: string | null
    additionalThoughts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestFeedbackResponsesMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    customResponse: string | null
    results: string | null
    anticipatedResults: string | null
    conditionsConstraints: string | null
    metExpectations: string | null
    notMetExpectations: string | null
    otherOpportunities: string | null
    additionalThoughts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestFeedbackResponsesCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    customResponse: number
    results: number
    anticipatedResults: number
    conditionsConstraints: number
    metExpectations: number
    notMetExpectations: number
    otherOpportunities: number
    additionalThoughts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestFeedbackResponsesMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    results?: true
    anticipatedResults?: true
    conditionsConstraints?: true
    metExpectations?: true
    notMetExpectations?: true
    otherOpportunities?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestFeedbackResponsesMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    results?: true
    anticipatedResults?: true
    conditionsConstraints?: true
    metExpectations?: true
    notMetExpectations?: true
    otherOpportunities?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestFeedbackResponsesCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    results?: true
    anticipatedResults?: true
    conditionsConstraints?: true
    metExpectations?: true
    notMetExpectations?: true
    otherOpportunities?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestFeedbackResponsesAggregateArgs = {
    /**
     * Filter which TestFeedbackResponses to aggregate.
     * 
    **/
    where?: TestFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TestFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestFeedbackResponses
    **/
    _count?: true | TestFeedbackResponsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestFeedbackResponsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestFeedbackResponsesMaxAggregateInputType
  }

  export type GetTestFeedbackResponsesAggregateType<T extends TestFeedbackResponsesAggregateArgs> = {
        [P in keyof T & keyof AggregateTestFeedbackResponses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestFeedbackResponses[P]>
      : GetScalarType<T[P], AggregateTestFeedbackResponses[P]>
  }




  export type TestFeedbackResponsesGroupByArgs = {
    where?: TestFeedbackResponsesWhereInput
    orderBy?: Enumerable<TestFeedbackResponsesOrderByWithAggregationInput>
    by: Array<TestFeedbackResponsesScalarFieldEnum>
    having?: TestFeedbackResponsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestFeedbackResponsesCountAggregateInputType | true
    _min?: TestFeedbackResponsesMinAggregateInputType
    _max?: TestFeedbackResponsesMaxAggregateInputType
  }


  export type TestFeedbackResponsesGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date | null
    customResponse: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestFeedbackResponsesCountAggregateOutputType | null
    _min: TestFeedbackResponsesMinAggregateOutputType | null
    _max: TestFeedbackResponsesMaxAggregateOutputType | null
  }

  type GetTestFeedbackResponsesGroupByPayload<T extends TestFeedbackResponsesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TestFeedbackResponsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestFeedbackResponsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestFeedbackResponsesGroupByOutputType[P]>
            : GetScalarType<T[P], TestFeedbackResponsesGroupByOutputType[P]>
        }
      >
    >


  export type TestFeedbackResponsesSelect = {
    id?: boolean
    testFeedback?: boolean | TestFeedbackSubmissionArgs
    startDate?: boolean
    endDate?: boolean
    customResponse?: boolean
    results?: boolean
    anticipatedResults?: boolean
    conditionsConstraints?: boolean
    metExpectations?: boolean
    notMetExpectations?: boolean
    otherOpportunities?: boolean
    additionalThoughts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestFeedbackResponsesInclude = {
    testFeedback?: boolean | TestFeedbackSubmissionArgs
  }

  export type TestFeedbackResponsesGetPayload<
    S extends boolean | null | undefined | TestFeedbackResponsesArgs,
    U = keyof S
      > = S extends true
        ? TestFeedbackResponses
    : S extends undefined
    ? never
    : S extends TestFeedbackResponsesArgs | TestFeedbackResponsesFindManyArgs
    ?'include' extends U
    ? TestFeedbackResponses  & {
    [P in TrueKeys<S['include']>]:
        P extends 'testFeedback' ? TestFeedbackSubmissionGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'testFeedback' ? TestFeedbackSubmissionGetPayload<S['select'][P]> | null :  P extends keyof TestFeedbackResponses ? TestFeedbackResponses[P] : never
  } 
    : TestFeedbackResponses
  : TestFeedbackResponses


  type TestFeedbackResponsesCountArgs = Merge<
    Omit<TestFeedbackResponsesFindManyArgs, 'select' | 'include'> & {
      select?: TestFeedbackResponsesCountAggregateInputType | true
    }
  >

  export interface TestFeedbackResponsesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TestFeedbackResponses that matches the filter.
     * @param {TestFeedbackResponsesFindUniqueArgs} args - Arguments to find a TestFeedbackResponses
     * @example
     * // Get one TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestFeedbackResponsesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TestFeedbackResponsesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TestFeedbackResponses'> extends True ? CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses | null >, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find the first TestFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesFindFirstArgs} args - Arguments to find a TestFeedbackResponses
     * @example
     * // Get one TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestFeedbackResponsesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TestFeedbackResponsesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TestFeedbackResponses'> extends True ? CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses | null >, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find zero or more TestFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.findMany()
     * 
     * // Get first 10 TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testFeedbackResponsesWithIdOnly = await prisma.testFeedbackResponses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestFeedbackResponsesFindManyArgs>(
      args?: SelectSubset<T, TestFeedbackResponsesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TestFeedbackResponses>>, PrismaPromise<Array<TestFeedbackResponsesGetPayload<T>>>>

    /**
     * Create a TestFeedbackResponses.
     * @param {TestFeedbackResponsesCreateArgs} args - Arguments to create a TestFeedbackResponses.
     * @example
     * // Create one TestFeedbackResponses
     * const TestFeedbackResponses = await prisma.testFeedbackResponses.create({
     *   data: {
     *     // ... data to create a TestFeedbackResponses
     *   }
     * })
     * 
    **/
    create<T extends TestFeedbackResponsesCreateArgs>(
      args: SelectSubset<T, TestFeedbackResponsesCreateArgs>
    ): CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>>

    /**
     * Create many TestFeedbackResponses.
     *     @param {TestFeedbackResponsesCreateManyArgs} args - Arguments to create many TestFeedbackResponses.
     *     @example
     *     // Create many TestFeedbackResponses
     *     const testFeedbackResponses = await prisma.testFeedbackResponses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestFeedbackResponsesCreateManyArgs>(
      args?: SelectSubset<T, TestFeedbackResponsesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TestFeedbackResponses.
     * @param {TestFeedbackResponsesDeleteArgs} args - Arguments to delete one TestFeedbackResponses.
     * @example
     * // Delete one TestFeedbackResponses
     * const TestFeedbackResponses = await prisma.testFeedbackResponses.delete({
     *   where: {
     *     // ... filter to delete one TestFeedbackResponses
     *   }
     * })
     * 
    **/
    delete<T extends TestFeedbackResponsesDeleteArgs>(
      args: SelectSubset<T, TestFeedbackResponsesDeleteArgs>
    ): CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>>

    /**
     * Update one TestFeedbackResponses.
     * @param {TestFeedbackResponsesUpdateArgs} args - Arguments to update one TestFeedbackResponses.
     * @example
     * // Update one TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestFeedbackResponsesUpdateArgs>(
      args: SelectSubset<T, TestFeedbackResponsesUpdateArgs>
    ): CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>>

    /**
     * Delete zero or more TestFeedbackResponses.
     * @param {TestFeedbackResponsesDeleteManyArgs} args - Arguments to filter TestFeedbackResponses to delete.
     * @example
     * // Delete a few TestFeedbackResponses
     * const { count } = await prisma.testFeedbackResponses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestFeedbackResponsesDeleteManyArgs>(
      args?: SelectSubset<T, TestFeedbackResponsesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestFeedbackResponsesUpdateManyArgs>(
      args: SelectSubset<T, TestFeedbackResponsesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TestFeedbackResponses.
     * @param {TestFeedbackResponsesUpsertArgs} args - Arguments to update or create a TestFeedbackResponses.
     * @example
     * // Update or create a TestFeedbackResponses
     * const testFeedbackResponses = await prisma.testFeedbackResponses.upsert({
     *   create: {
     *     // ... data to create a TestFeedbackResponses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestFeedbackResponses we want to update
     *   }
     * })
    **/
    upsert<T extends TestFeedbackResponsesUpsertArgs>(
      args: SelectSubset<T, TestFeedbackResponsesUpsertArgs>
    ): CheckSelect<T, Prisma__TestFeedbackResponsesClient<TestFeedbackResponses>, Prisma__TestFeedbackResponsesClient<TestFeedbackResponsesGetPayload<T>>>

    /**
     * Count the number of TestFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesCountArgs} args - Arguments to filter TestFeedbackResponses to count.
     * @example
     * // Count the number of TestFeedbackResponses
     * const count = await prisma.testFeedbackResponses.count({
     *   where: {
     *     // ... the filter for the TestFeedbackResponses we want to count
     *   }
     * })
    **/
    count<T extends TestFeedbackResponsesCountArgs>(
      args?: Subset<T, TestFeedbackResponsesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestFeedbackResponsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestFeedbackResponsesAggregateArgs>(args: Subset<T, TestFeedbackResponsesAggregateArgs>): PrismaPromise<GetTestFeedbackResponsesAggregateType<T>>

    /**
     * Group by TestFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFeedbackResponsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestFeedbackResponsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestFeedbackResponsesGroupByArgs['orderBy'] }
        : { orderBy?: TestFeedbackResponsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestFeedbackResponsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestFeedbackResponsesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestFeedbackResponses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TestFeedbackResponsesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    testFeedback<T extends TestFeedbackSubmissionArgs = {}>(args?: Subset<T, TestFeedbackSubmissionArgs>): CheckSelect<T, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmission | null >, Prisma__TestFeedbackSubmissionClient<TestFeedbackSubmissionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TestFeedbackResponses findUnique
   */
  export type TestFeedbackResponsesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * Throw an Error if a TestFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TestFeedbackResponses to fetch.
     * 
    **/
    where: TestFeedbackResponsesWhereUniqueInput
  }


  /**
   * TestFeedbackResponses findFirst
   */
  export type TestFeedbackResponsesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * Throw an Error if a TestFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TestFeedbackResponses to fetch.
     * 
    **/
    where?: TestFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestFeedbackResponses.
     * 
    **/
    cursor?: TestFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestFeedbackResponses.
     * 
    **/
    distinct?: Enumerable<TestFeedbackResponsesScalarFieldEnum>
  }


  /**
   * TestFeedbackResponses findMany
   */
  export type TestFeedbackResponsesFindManyArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * Filter, which TestFeedbackResponses to fetch.
     * 
    **/
    where?: TestFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<TestFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestFeedbackResponses.
     * 
    **/
    cursor?: TestFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestFeedbackResponses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TestFeedbackResponsesScalarFieldEnum>
  }


  /**
   * TestFeedbackResponses create
   */
  export type TestFeedbackResponsesCreateArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * The data needed to create a TestFeedbackResponses.
     * 
    **/
    data: XOR<TestFeedbackResponsesCreateInput, TestFeedbackResponsesUncheckedCreateInput>
  }


  /**
   * TestFeedbackResponses createMany
   */
  export type TestFeedbackResponsesCreateManyArgs = {
    /**
     * The data used to create many TestFeedbackResponses.
     * 
    **/
    data: Enumerable<TestFeedbackResponsesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TestFeedbackResponses update
   */
  export type TestFeedbackResponsesUpdateArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * The data needed to update a TestFeedbackResponses.
     * 
    **/
    data: XOR<TestFeedbackResponsesUpdateInput, TestFeedbackResponsesUncheckedUpdateInput>
    /**
     * Choose, which TestFeedbackResponses to update.
     * 
    **/
    where: TestFeedbackResponsesWhereUniqueInput
  }


  /**
   * TestFeedbackResponses updateMany
   */
  export type TestFeedbackResponsesUpdateManyArgs = {
    /**
     * The data used to update TestFeedbackResponses.
     * 
    **/
    data: XOR<TestFeedbackResponsesUpdateManyMutationInput, TestFeedbackResponsesUncheckedUpdateManyInput>
    /**
     * Filter which TestFeedbackResponses to update
     * 
    **/
    where?: TestFeedbackResponsesWhereInput
  }


  /**
   * TestFeedbackResponses upsert
   */
  export type TestFeedbackResponsesUpsertArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * The filter to search for the TestFeedbackResponses to update in case it exists.
     * 
    **/
    where: TestFeedbackResponsesWhereUniqueInput
    /**
     * In case the TestFeedbackResponses found by the `where` argument doesn't exist, create a new TestFeedbackResponses with this data.
     * 
    **/
    create: XOR<TestFeedbackResponsesCreateInput, TestFeedbackResponsesUncheckedCreateInput>
    /**
     * In case the TestFeedbackResponses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TestFeedbackResponsesUpdateInput, TestFeedbackResponsesUncheckedUpdateInput>
  }


  /**
   * TestFeedbackResponses delete
   */
  export type TestFeedbackResponsesDeleteArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
    /**
     * Filter which TestFeedbackResponses to delete.
     * 
    **/
    where: TestFeedbackResponsesWhereUniqueInput
  }


  /**
   * TestFeedbackResponses deleteMany
   */
  export type TestFeedbackResponsesDeleteManyArgs = {
    /**
     * Filter which TestFeedbackResponses to delete
     * 
    **/
    where?: TestFeedbackResponsesWhereInput
  }


  /**
   * TestFeedbackResponses without action
   */
  export type TestFeedbackResponsesArgs = {
    /**
     * Select specific fields to fetch from the TestFeedbackResponses
     * 
    **/
    select?: TestFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TestFeedbackResponsesInclude | null
  }



  /**
   * Model InputFeedbackSubmission
   */


  export type AggregateInputFeedbackSubmission = {
    _count: InputFeedbackSubmissionCountAggregateOutputType | null
    _min: InputFeedbackSubmissionMinAggregateOutputType | null
    _max: InputFeedbackSubmissionMaxAggregateOutputType | null
  }

  export type InputFeedbackSubmissionMinAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    inputFeedbackResponseId: string | null
    rating: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputFeedbackSubmissionMaxAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    inputFeedbackResponseId: string | null
    rating: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputFeedbackSubmissionCountAggregateOutputType = {
    id: number
    feedbackConfigId: number
    inputFeedbackResponseId: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InputFeedbackSubmissionMinAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    inputFeedbackResponseId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputFeedbackSubmissionMaxAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    inputFeedbackResponseId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputFeedbackSubmissionCountAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    inputFeedbackResponseId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InputFeedbackSubmissionAggregateArgs = {
    /**
     * Filter which InputFeedbackSubmission to aggregate.
     * 
    **/
    where?: InputFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InputFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InputFeedbackSubmissions
    **/
    _count?: true | InputFeedbackSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputFeedbackSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputFeedbackSubmissionMaxAggregateInputType
  }

  export type GetInputFeedbackSubmissionAggregateType<T extends InputFeedbackSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateInputFeedbackSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputFeedbackSubmission[P]>
      : GetScalarType<T[P], AggregateInputFeedbackSubmission[P]>
  }




  export type InputFeedbackSubmissionGroupByArgs = {
    where?: InputFeedbackSubmissionWhereInput
    orderBy?: Enumerable<InputFeedbackSubmissionOrderByWithAggregationInput>
    by: Array<InputFeedbackSubmissionScalarFieldEnum>
    having?: InputFeedbackSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputFeedbackSubmissionCountAggregateInputType | true
    _min?: InputFeedbackSubmissionMinAggregateInputType
    _max?: InputFeedbackSubmissionMaxAggregateInputType
  }


  export type InputFeedbackSubmissionGroupByOutputType = {
    id: string
    feedbackConfigId: string
    inputFeedbackResponseId: string
    rating: string
    createdAt: Date
    updatedAt: Date
    _count: InputFeedbackSubmissionCountAggregateOutputType | null
    _min: InputFeedbackSubmissionMinAggregateOutputType | null
    _max: InputFeedbackSubmissionMaxAggregateOutputType | null
  }

  type GetInputFeedbackSubmissionGroupByPayload<T extends InputFeedbackSubmissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InputFeedbackSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputFeedbackSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputFeedbackSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], InputFeedbackSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type InputFeedbackSubmissionSelect = {
    id?: boolean
    feedbackConfig?: boolean | FeedbackConfigArgs
    feedbackConfigId?: boolean
    inputFeedbackResponses?: boolean | InputFeedbackResponsesArgs
    inputFeedbackResponseId?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InputFeedbackSubmissionInclude = {
    feedbackConfig?: boolean | FeedbackConfigArgs
    inputFeedbackResponses?: boolean | InputFeedbackResponsesArgs
  }

  export type InputFeedbackSubmissionGetPayload<
    S extends boolean | null | undefined | InputFeedbackSubmissionArgs,
    U = keyof S
      > = S extends true
        ? InputFeedbackSubmission
    : S extends undefined
    ? never
    : S extends InputFeedbackSubmissionArgs | InputFeedbackSubmissionFindManyArgs
    ?'include' extends U
    ? InputFeedbackSubmission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['include'][P]> | null :
        P extends 'inputFeedbackResponses' ? InputFeedbackResponsesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['select'][P]> | null :
        P extends 'inputFeedbackResponses' ? InputFeedbackResponsesGetPayload<S['select'][P]> :  P extends keyof InputFeedbackSubmission ? InputFeedbackSubmission[P] : never
  } 
    : InputFeedbackSubmission
  : InputFeedbackSubmission


  type InputFeedbackSubmissionCountArgs = Merge<
    Omit<InputFeedbackSubmissionFindManyArgs, 'select' | 'include'> & {
      select?: InputFeedbackSubmissionCountAggregateInputType | true
    }
  >

  export interface InputFeedbackSubmissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one InputFeedbackSubmission that matches the filter.
     * @param {InputFeedbackSubmissionFindUniqueArgs} args - Arguments to find a InputFeedbackSubmission
     * @example
     * // Get one InputFeedbackSubmission
     * const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InputFeedbackSubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InputFeedbackSubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InputFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission | null >, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find the first InputFeedbackSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionFindFirstArgs} args - Arguments to find a InputFeedbackSubmission
     * @example
     * // Get one InputFeedbackSubmission
     * const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InputFeedbackSubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InputFeedbackSubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InputFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission | null >, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find zero or more InputFeedbackSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InputFeedbackSubmissions
     * const inputFeedbackSubmissions = await prisma.inputFeedbackSubmission.findMany()
     * 
     * // Get first 10 InputFeedbackSubmissions
     * const inputFeedbackSubmissions = await prisma.inputFeedbackSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inputFeedbackSubmissionWithIdOnly = await prisma.inputFeedbackSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InputFeedbackSubmissionFindManyArgs>(
      args?: SelectSubset<T, InputFeedbackSubmissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InputFeedbackSubmission>>, PrismaPromise<Array<InputFeedbackSubmissionGetPayload<T>>>>

    /**
     * Create a InputFeedbackSubmission.
     * @param {InputFeedbackSubmissionCreateArgs} args - Arguments to create a InputFeedbackSubmission.
     * @example
     * // Create one InputFeedbackSubmission
     * const InputFeedbackSubmission = await prisma.inputFeedbackSubmission.create({
     *   data: {
     *     // ... data to create a InputFeedbackSubmission
     *   }
     * })
     * 
    **/
    create<T extends InputFeedbackSubmissionCreateArgs>(
      args: SelectSubset<T, InputFeedbackSubmissionCreateArgs>
    ): CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>>

    /**
     * Create many InputFeedbackSubmissions.
     *     @param {InputFeedbackSubmissionCreateManyArgs} args - Arguments to create many InputFeedbackSubmissions.
     *     @example
     *     // Create many InputFeedbackSubmissions
     *     const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InputFeedbackSubmissionCreateManyArgs>(
      args?: SelectSubset<T, InputFeedbackSubmissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InputFeedbackSubmission.
     * @param {InputFeedbackSubmissionDeleteArgs} args - Arguments to delete one InputFeedbackSubmission.
     * @example
     * // Delete one InputFeedbackSubmission
     * const InputFeedbackSubmission = await prisma.inputFeedbackSubmission.delete({
     *   where: {
     *     // ... filter to delete one InputFeedbackSubmission
     *   }
     * })
     * 
    **/
    delete<T extends InputFeedbackSubmissionDeleteArgs>(
      args: SelectSubset<T, InputFeedbackSubmissionDeleteArgs>
    ): CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>>

    /**
     * Update one InputFeedbackSubmission.
     * @param {InputFeedbackSubmissionUpdateArgs} args - Arguments to update one InputFeedbackSubmission.
     * @example
     * // Update one InputFeedbackSubmission
     * const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InputFeedbackSubmissionUpdateArgs>(
      args: SelectSubset<T, InputFeedbackSubmissionUpdateArgs>
    ): CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>>

    /**
     * Delete zero or more InputFeedbackSubmissions.
     * @param {InputFeedbackSubmissionDeleteManyArgs} args - Arguments to filter InputFeedbackSubmissions to delete.
     * @example
     * // Delete a few InputFeedbackSubmissions
     * const { count } = await prisma.inputFeedbackSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InputFeedbackSubmissionDeleteManyArgs>(
      args?: SelectSubset<T, InputFeedbackSubmissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InputFeedbackSubmissions
     * const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InputFeedbackSubmissionUpdateManyArgs>(
      args: SelectSubset<T, InputFeedbackSubmissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InputFeedbackSubmission.
     * @param {InputFeedbackSubmissionUpsertArgs} args - Arguments to update or create a InputFeedbackSubmission.
     * @example
     * // Update or create a InputFeedbackSubmission
     * const inputFeedbackSubmission = await prisma.inputFeedbackSubmission.upsert({
     *   create: {
     *     // ... data to create a InputFeedbackSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InputFeedbackSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends InputFeedbackSubmissionUpsertArgs>(
      args: SelectSubset<T, InputFeedbackSubmissionUpsertArgs>
    ): CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission>, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T>>>

    /**
     * Count the number of InputFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionCountArgs} args - Arguments to filter InputFeedbackSubmissions to count.
     * @example
     * // Count the number of InputFeedbackSubmissions
     * const count = await prisma.inputFeedbackSubmission.count({
     *   where: {
     *     // ... the filter for the InputFeedbackSubmissions we want to count
     *   }
     * })
    **/
    count<T extends InputFeedbackSubmissionCountArgs>(
      args?: Subset<T, InputFeedbackSubmissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputFeedbackSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InputFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputFeedbackSubmissionAggregateArgs>(args: Subset<T, InputFeedbackSubmissionAggregateArgs>): PrismaPromise<GetInputFeedbackSubmissionAggregateType<T>>

    /**
     * Group by InputFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InputFeedbackSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputFeedbackSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: InputFeedbackSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InputFeedbackSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputFeedbackSubmissionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for InputFeedbackSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InputFeedbackSubmissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    feedbackConfig<T extends FeedbackConfigArgs = {}>(args?: Subset<T, FeedbackConfigArgs>): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>;

    inputFeedbackResponses<T extends InputFeedbackResponsesArgs = {}>(args?: Subset<T, InputFeedbackResponsesArgs>): CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses | null >, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * InputFeedbackSubmission findUnique
   */
  export type InputFeedbackSubmissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a InputFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InputFeedbackSubmission to fetch.
     * 
    **/
    where: InputFeedbackSubmissionWhereUniqueInput
  }


  /**
   * InputFeedbackSubmission findFirst
   */
  export type InputFeedbackSubmissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a InputFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InputFeedbackSubmission to fetch.
     * 
    **/
    where?: InputFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputFeedbackSubmissions.
     * 
    **/
    cursor?: InputFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputFeedbackSubmissions.
     * 
    **/
    distinct?: Enumerable<InputFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * InputFeedbackSubmission findMany
   */
  export type InputFeedbackSubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * Filter, which InputFeedbackSubmissions to fetch.
     * 
    **/
    where?: InputFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InputFeedbackSubmissions.
     * 
    **/
    cursor?: InputFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackSubmissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InputFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * InputFeedbackSubmission create
   */
  export type InputFeedbackSubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * The data needed to create a InputFeedbackSubmission.
     * 
    **/
    data: XOR<InputFeedbackSubmissionCreateInput, InputFeedbackSubmissionUncheckedCreateInput>
  }


  /**
   * InputFeedbackSubmission createMany
   */
  export type InputFeedbackSubmissionCreateManyArgs = {
    /**
     * The data used to create many InputFeedbackSubmissions.
     * 
    **/
    data: Enumerable<InputFeedbackSubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InputFeedbackSubmission update
   */
  export type InputFeedbackSubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * The data needed to update a InputFeedbackSubmission.
     * 
    **/
    data: XOR<InputFeedbackSubmissionUpdateInput, InputFeedbackSubmissionUncheckedUpdateInput>
    /**
     * Choose, which InputFeedbackSubmission to update.
     * 
    **/
    where: InputFeedbackSubmissionWhereUniqueInput
  }


  /**
   * InputFeedbackSubmission updateMany
   */
  export type InputFeedbackSubmissionUpdateManyArgs = {
    /**
     * The data used to update InputFeedbackSubmissions.
     * 
    **/
    data: XOR<InputFeedbackSubmissionUpdateManyMutationInput, InputFeedbackSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which InputFeedbackSubmissions to update
     * 
    **/
    where?: InputFeedbackSubmissionWhereInput
  }


  /**
   * InputFeedbackSubmission upsert
   */
  export type InputFeedbackSubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * The filter to search for the InputFeedbackSubmission to update in case it exists.
     * 
    **/
    where: InputFeedbackSubmissionWhereUniqueInput
    /**
     * In case the InputFeedbackSubmission found by the `where` argument doesn't exist, create a new InputFeedbackSubmission with this data.
     * 
    **/
    create: XOR<InputFeedbackSubmissionCreateInput, InputFeedbackSubmissionUncheckedCreateInput>
    /**
     * In case the InputFeedbackSubmission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InputFeedbackSubmissionUpdateInput, InputFeedbackSubmissionUncheckedUpdateInput>
  }


  /**
   * InputFeedbackSubmission delete
   */
  export type InputFeedbackSubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
    /**
     * Filter which InputFeedbackSubmission to delete.
     * 
    **/
    where: InputFeedbackSubmissionWhereUniqueInput
  }


  /**
   * InputFeedbackSubmission deleteMany
   */
  export type InputFeedbackSubmissionDeleteManyArgs = {
    /**
     * Filter which InputFeedbackSubmissions to delete
     * 
    **/
    where?: InputFeedbackSubmissionWhereInput
  }


  /**
   * InputFeedbackSubmission without action
   */
  export type InputFeedbackSubmissionArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackSubmission
     * 
    **/
    select?: InputFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackSubmissionInclude | null
  }



  /**
   * Model InputFeedbackResponses
   */


  export type AggregateInputFeedbackResponses = {
    _count: InputFeedbackResponsesCountAggregateOutputType | null
    _min: InputFeedbackResponsesMinAggregateOutputType | null
    _max: InputFeedbackResponsesMaxAggregateOutputType | null
  }

  export type InputFeedbackResponsesMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    customResponse: string | null
    opportunities: string | null
    processSolution: string | null
    notAsked: string | null
    responseViews: string | null
    additionalThoughts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputFeedbackResponsesMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    customResponse: string | null
    opportunities: string | null
    processSolution: string | null
    notAsked: string | null
    responseViews: string | null
    additionalThoughts: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InputFeedbackResponsesCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    customResponse: number
    opportunities: number
    processSolution: number
    notAsked: number
    responseViews: number
    additionalThoughts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InputFeedbackResponsesMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    opportunities?: true
    processSolution?: true
    notAsked?: true
    responseViews?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputFeedbackResponsesMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    opportunities?: true
    processSolution?: true
    notAsked?: true
    responseViews?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InputFeedbackResponsesCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    customResponse?: true
    opportunities?: true
    processSolution?: true
    notAsked?: true
    responseViews?: true
    additionalThoughts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InputFeedbackResponsesAggregateArgs = {
    /**
     * Filter which InputFeedbackResponses to aggregate.
     * 
    **/
    where?: InputFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InputFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InputFeedbackResponses
    **/
    _count?: true | InputFeedbackResponsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InputFeedbackResponsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InputFeedbackResponsesMaxAggregateInputType
  }

  export type GetInputFeedbackResponsesAggregateType<T extends InputFeedbackResponsesAggregateArgs> = {
        [P in keyof T & keyof AggregateInputFeedbackResponses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInputFeedbackResponses[P]>
      : GetScalarType<T[P], AggregateInputFeedbackResponses[P]>
  }




  export type InputFeedbackResponsesGroupByArgs = {
    where?: InputFeedbackResponsesWhereInput
    orderBy?: Enumerable<InputFeedbackResponsesOrderByWithAggregationInput>
    by: Array<InputFeedbackResponsesScalarFieldEnum>
    having?: InputFeedbackResponsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InputFeedbackResponsesCountAggregateInputType | true
    _min?: InputFeedbackResponsesMinAggregateInputType
    _max?: InputFeedbackResponsesMaxAggregateInputType
  }


  export type InputFeedbackResponsesGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date | null
    customResponse: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts: string | null
    createdAt: Date
    updatedAt: Date
    _count: InputFeedbackResponsesCountAggregateOutputType | null
    _min: InputFeedbackResponsesMinAggregateOutputType | null
    _max: InputFeedbackResponsesMaxAggregateOutputType | null
  }

  type GetInputFeedbackResponsesGroupByPayload<T extends InputFeedbackResponsesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InputFeedbackResponsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InputFeedbackResponsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InputFeedbackResponsesGroupByOutputType[P]>
            : GetScalarType<T[P], InputFeedbackResponsesGroupByOutputType[P]>
        }
      >
    >


  export type InputFeedbackResponsesSelect = {
    id?: boolean
    inputFeedback?: boolean | InputFeedbackSubmissionArgs
    startDate?: boolean
    endDate?: boolean
    customResponse?: boolean
    opportunities?: boolean
    processSolution?: boolean
    notAsked?: boolean
    responseViews?: boolean
    additionalThoughts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InputFeedbackResponsesInclude = {
    inputFeedback?: boolean | InputFeedbackSubmissionArgs
  }

  export type InputFeedbackResponsesGetPayload<
    S extends boolean | null | undefined | InputFeedbackResponsesArgs,
    U = keyof S
      > = S extends true
        ? InputFeedbackResponses
    : S extends undefined
    ? never
    : S extends InputFeedbackResponsesArgs | InputFeedbackResponsesFindManyArgs
    ?'include' extends U
    ? InputFeedbackResponses  & {
    [P in TrueKeys<S['include']>]:
        P extends 'inputFeedback' ? InputFeedbackSubmissionGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'inputFeedback' ? InputFeedbackSubmissionGetPayload<S['select'][P]> | null :  P extends keyof InputFeedbackResponses ? InputFeedbackResponses[P] : never
  } 
    : InputFeedbackResponses
  : InputFeedbackResponses


  type InputFeedbackResponsesCountArgs = Merge<
    Omit<InputFeedbackResponsesFindManyArgs, 'select' | 'include'> & {
      select?: InputFeedbackResponsesCountAggregateInputType | true
    }
  >

  export interface InputFeedbackResponsesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one InputFeedbackResponses that matches the filter.
     * @param {InputFeedbackResponsesFindUniqueArgs} args - Arguments to find a InputFeedbackResponses
     * @example
     * // Get one InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InputFeedbackResponsesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InputFeedbackResponsesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InputFeedbackResponses'> extends True ? CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses | null >, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find the first InputFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesFindFirstArgs} args - Arguments to find a InputFeedbackResponses
     * @example
     * // Get one InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InputFeedbackResponsesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InputFeedbackResponsesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InputFeedbackResponses'> extends True ? CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses | null >, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find zero or more InputFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.findMany()
     * 
     * // Get first 10 InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inputFeedbackResponsesWithIdOnly = await prisma.inputFeedbackResponses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InputFeedbackResponsesFindManyArgs>(
      args?: SelectSubset<T, InputFeedbackResponsesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<InputFeedbackResponses>>, PrismaPromise<Array<InputFeedbackResponsesGetPayload<T>>>>

    /**
     * Create a InputFeedbackResponses.
     * @param {InputFeedbackResponsesCreateArgs} args - Arguments to create a InputFeedbackResponses.
     * @example
     * // Create one InputFeedbackResponses
     * const InputFeedbackResponses = await prisma.inputFeedbackResponses.create({
     *   data: {
     *     // ... data to create a InputFeedbackResponses
     *   }
     * })
     * 
    **/
    create<T extends InputFeedbackResponsesCreateArgs>(
      args: SelectSubset<T, InputFeedbackResponsesCreateArgs>
    ): CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>>

    /**
     * Create many InputFeedbackResponses.
     *     @param {InputFeedbackResponsesCreateManyArgs} args - Arguments to create many InputFeedbackResponses.
     *     @example
     *     // Create many InputFeedbackResponses
     *     const inputFeedbackResponses = await prisma.inputFeedbackResponses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InputFeedbackResponsesCreateManyArgs>(
      args?: SelectSubset<T, InputFeedbackResponsesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InputFeedbackResponses.
     * @param {InputFeedbackResponsesDeleteArgs} args - Arguments to delete one InputFeedbackResponses.
     * @example
     * // Delete one InputFeedbackResponses
     * const InputFeedbackResponses = await prisma.inputFeedbackResponses.delete({
     *   where: {
     *     // ... filter to delete one InputFeedbackResponses
     *   }
     * })
     * 
    **/
    delete<T extends InputFeedbackResponsesDeleteArgs>(
      args: SelectSubset<T, InputFeedbackResponsesDeleteArgs>
    ): CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>>

    /**
     * Update one InputFeedbackResponses.
     * @param {InputFeedbackResponsesUpdateArgs} args - Arguments to update one InputFeedbackResponses.
     * @example
     * // Update one InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InputFeedbackResponsesUpdateArgs>(
      args: SelectSubset<T, InputFeedbackResponsesUpdateArgs>
    ): CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>>

    /**
     * Delete zero or more InputFeedbackResponses.
     * @param {InputFeedbackResponsesDeleteManyArgs} args - Arguments to filter InputFeedbackResponses to delete.
     * @example
     * // Delete a few InputFeedbackResponses
     * const { count } = await prisma.inputFeedbackResponses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InputFeedbackResponsesDeleteManyArgs>(
      args?: SelectSubset<T, InputFeedbackResponsesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InputFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InputFeedbackResponsesUpdateManyArgs>(
      args: SelectSubset<T, InputFeedbackResponsesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InputFeedbackResponses.
     * @param {InputFeedbackResponsesUpsertArgs} args - Arguments to update or create a InputFeedbackResponses.
     * @example
     * // Update or create a InputFeedbackResponses
     * const inputFeedbackResponses = await prisma.inputFeedbackResponses.upsert({
     *   create: {
     *     // ... data to create a InputFeedbackResponses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InputFeedbackResponses we want to update
     *   }
     * })
    **/
    upsert<T extends InputFeedbackResponsesUpsertArgs>(
      args: SelectSubset<T, InputFeedbackResponsesUpsertArgs>
    ): CheckSelect<T, Prisma__InputFeedbackResponsesClient<InputFeedbackResponses>, Prisma__InputFeedbackResponsesClient<InputFeedbackResponsesGetPayload<T>>>

    /**
     * Count the number of InputFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesCountArgs} args - Arguments to filter InputFeedbackResponses to count.
     * @example
     * // Count the number of InputFeedbackResponses
     * const count = await prisma.inputFeedbackResponses.count({
     *   where: {
     *     // ... the filter for the InputFeedbackResponses we want to count
     *   }
     * })
    **/
    count<T extends InputFeedbackResponsesCountArgs>(
      args?: Subset<T, InputFeedbackResponsesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InputFeedbackResponsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InputFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InputFeedbackResponsesAggregateArgs>(args: Subset<T, InputFeedbackResponsesAggregateArgs>): PrismaPromise<GetInputFeedbackResponsesAggregateType<T>>

    /**
     * Group by InputFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InputFeedbackResponsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InputFeedbackResponsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InputFeedbackResponsesGroupByArgs['orderBy'] }
        : { orderBy?: InputFeedbackResponsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InputFeedbackResponsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInputFeedbackResponsesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for InputFeedbackResponses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InputFeedbackResponsesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    inputFeedback<T extends InputFeedbackSubmissionArgs = {}>(args?: Subset<T, InputFeedbackSubmissionArgs>): CheckSelect<T, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmission | null >, Prisma__InputFeedbackSubmissionClient<InputFeedbackSubmissionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * InputFeedbackResponses findUnique
   */
  export type InputFeedbackResponsesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * Throw an Error if a InputFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InputFeedbackResponses to fetch.
     * 
    **/
    where: InputFeedbackResponsesWhereUniqueInput
  }


  /**
   * InputFeedbackResponses findFirst
   */
  export type InputFeedbackResponsesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * Throw an Error if a InputFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which InputFeedbackResponses to fetch.
     * 
    **/
    where?: InputFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InputFeedbackResponses.
     * 
    **/
    cursor?: InputFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InputFeedbackResponses.
     * 
    **/
    distinct?: Enumerable<InputFeedbackResponsesScalarFieldEnum>
  }


  /**
   * InputFeedbackResponses findMany
   */
  export type InputFeedbackResponsesFindManyArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * Filter, which InputFeedbackResponses to fetch.
     * 
    **/
    where?: InputFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InputFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<InputFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InputFeedbackResponses.
     * 
    **/
    cursor?: InputFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InputFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InputFeedbackResponses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InputFeedbackResponsesScalarFieldEnum>
  }


  /**
   * InputFeedbackResponses create
   */
  export type InputFeedbackResponsesCreateArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * The data needed to create a InputFeedbackResponses.
     * 
    **/
    data: XOR<InputFeedbackResponsesCreateInput, InputFeedbackResponsesUncheckedCreateInput>
  }


  /**
   * InputFeedbackResponses createMany
   */
  export type InputFeedbackResponsesCreateManyArgs = {
    /**
     * The data used to create many InputFeedbackResponses.
     * 
    **/
    data: Enumerable<InputFeedbackResponsesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InputFeedbackResponses update
   */
  export type InputFeedbackResponsesUpdateArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * The data needed to update a InputFeedbackResponses.
     * 
    **/
    data: XOR<InputFeedbackResponsesUpdateInput, InputFeedbackResponsesUncheckedUpdateInput>
    /**
     * Choose, which InputFeedbackResponses to update.
     * 
    **/
    where: InputFeedbackResponsesWhereUniqueInput
  }


  /**
   * InputFeedbackResponses updateMany
   */
  export type InputFeedbackResponsesUpdateManyArgs = {
    /**
     * The data used to update InputFeedbackResponses.
     * 
    **/
    data: XOR<InputFeedbackResponsesUpdateManyMutationInput, InputFeedbackResponsesUncheckedUpdateManyInput>
    /**
     * Filter which InputFeedbackResponses to update
     * 
    **/
    where?: InputFeedbackResponsesWhereInput
  }


  /**
   * InputFeedbackResponses upsert
   */
  export type InputFeedbackResponsesUpsertArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * The filter to search for the InputFeedbackResponses to update in case it exists.
     * 
    **/
    where: InputFeedbackResponsesWhereUniqueInput
    /**
     * In case the InputFeedbackResponses found by the `where` argument doesn't exist, create a new InputFeedbackResponses with this data.
     * 
    **/
    create: XOR<InputFeedbackResponsesCreateInput, InputFeedbackResponsesUncheckedCreateInput>
    /**
     * In case the InputFeedbackResponses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InputFeedbackResponsesUpdateInput, InputFeedbackResponsesUncheckedUpdateInput>
  }


  /**
   * InputFeedbackResponses delete
   */
  export type InputFeedbackResponsesDeleteArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
    /**
     * Filter which InputFeedbackResponses to delete.
     * 
    **/
    where: InputFeedbackResponsesWhereUniqueInput
  }


  /**
   * InputFeedbackResponses deleteMany
   */
  export type InputFeedbackResponsesDeleteManyArgs = {
    /**
     * Filter which InputFeedbackResponses to delete
     * 
    **/
    where?: InputFeedbackResponsesWhereInput
  }


  /**
   * InputFeedbackResponses without action
   */
  export type InputFeedbackResponsesArgs = {
    /**
     * Select specific fields to fetch from the InputFeedbackResponses
     * 
    **/
    select?: InputFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InputFeedbackResponsesInclude | null
  }



  /**
   * Model FreeFeedbackSubmission
   */


  export type AggregateFreeFeedbackSubmission = {
    _count: FreeFeedbackSubmissionCountAggregateOutputType | null
    _min: FreeFeedbackSubmissionMinAggregateOutputType | null
    _max: FreeFeedbackSubmissionMaxAggregateOutputType | null
  }

  export type FreeFeedbackSubmissionMinAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    freeFeedbackResponseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rating: string | null
  }

  export type FreeFeedbackSubmissionMaxAggregateOutputType = {
    id: string | null
    feedbackConfigId: string | null
    freeFeedbackResponseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    rating: string | null
  }

  export type FreeFeedbackSubmissionCountAggregateOutputType = {
    id: number
    feedbackConfigId: number
    freeFeedbackResponseId: number
    createdAt: number
    updatedAt: number
    rating: number
    _all: number
  }


  export type FreeFeedbackSubmissionMinAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    freeFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
  }

  export type FreeFeedbackSubmissionMaxAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    freeFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
  }

  export type FreeFeedbackSubmissionCountAggregateInputType = {
    id?: true
    feedbackConfigId?: true
    freeFeedbackResponseId?: true
    createdAt?: true
    updatedAt?: true
    rating?: true
    _all?: true
  }

  export type FreeFeedbackSubmissionAggregateArgs = {
    /**
     * Filter which FreeFeedbackSubmission to aggregate.
     * 
    **/
    where?: FreeFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FreeFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreeFeedbackSubmissions
    **/
    _count?: true | FreeFeedbackSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreeFeedbackSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreeFeedbackSubmissionMaxAggregateInputType
  }

  export type GetFreeFeedbackSubmissionAggregateType<T extends FreeFeedbackSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFreeFeedbackSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreeFeedbackSubmission[P]>
      : GetScalarType<T[P], AggregateFreeFeedbackSubmission[P]>
  }




  export type FreeFeedbackSubmissionGroupByArgs = {
    where?: FreeFeedbackSubmissionWhereInput
    orderBy?: Enumerable<FreeFeedbackSubmissionOrderByWithAggregationInput>
    by: Array<FreeFeedbackSubmissionScalarFieldEnum>
    having?: FreeFeedbackSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreeFeedbackSubmissionCountAggregateInputType | true
    _min?: FreeFeedbackSubmissionMinAggregateInputType
    _max?: FreeFeedbackSubmissionMaxAggregateInputType
  }


  export type FreeFeedbackSubmissionGroupByOutputType = {
    id: string
    feedbackConfigId: string
    freeFeedbackResponseId: string
    createdAt: Date
    updatedAt: Date
    rating: string
    _count: FreeFeedbackSubmissionCountAggregateOutputType | null
    _min: FreeFeedbackSubmissionMinAggregateOutputType | null
    _max: FreeFeedbackSubmissionMaxAggregateOutputType | null
  }

  type GetFreeFeedbackSubmissionGroupByPayload<T extends FreeFeedbackSubmissionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FreeFeedbackSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreeFeedbackSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreeFeedbackSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FreeFeedbackSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FreeFeedbackSubmissionSelect = {
    id?: boolean
    feedbackConfig?: boolean | FeedbackConfigArgs
    feedbackConfigId?: boolean
    freeFeedbackResponses?: boolean | FreeFeedbackResponsesArgs
    freeFeedbackResponseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rating?: boolean
  }

  export type FreeFeedbackSubmissionInclude = {
    feedbackConfig?: boolean | FeedbackConfigArgs
    freeFeedbackResponses?: boolean | FreeFeedbackResponsesArgs
  }

  export type FreeFeedbackSubmissionGetPayload<
    S extends boolean | null | undefined | FreeFeedbackSubmissionArgs,
    U = keyof S
      > = S extends true
        ? FreeFeedbackSubmission
    : S extends undefined
    ? never
    : S extends FreeFeedbackSubmissionArgs | FreeFeedbackSubmissionFindManyArgs
    ?'include' extends U
    ? FreeFeedbackSubmission  & {
    [P in TrueKeys<S['include']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['include'][P]> | null :
        P extends 'freeFeedbackResponses' ? FreeFeedbackResponsesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'feedbackConfig' ? FeedbackConfigGetPayload<S['select'][P]> | null :
        P extends 'freeFeedbackResponses' ? FreeFeedbackResponsesGetPayload<S['select'][P]> :  P extends keyof FreeFeedbackSubmission ? FreeFeedbackSubmission[P] : never
  } 
    : FreeFeedbackSubmission
  : FreeFeedbackSubmission


  type FreeFeedbackSubmissionCountArgs = Merge<
    Omit<FreeFeedbackSubmissionFindManyArgs, 'select' | 'include'> & {
      select?: FreeFeedbackSubmissionCountAggregateInputType | true
    }
  >

  export interface FreeFeedbackSubmissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FreeFeedbackSubmission that matches the filter.
     * @param {FreeFeedbackSubmissionFindUniqueArgs} args - Arguments to find a FreeFeedbackSubmission
     * @example
     * // Get one FreeFeedbackSubmission
     * const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FreeFeedbackSubmissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FreeFeedbackSubmissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FreeFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission | null >, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find the first FreeFeedbackSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionFindFirstArgs} args - Arguments to find a FreeFeedbackSubmission
     * @example
     * // Get one FreeFeedbackSubmission
     * const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FreeFeedbackSubmissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FreeFeedbackSubmissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FreeFeedbackSubmission'> extends True ? CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>> : CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission | null >, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T> | null >>

    /**
     * Find zero or more FreeFeedbackSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreeFeedbackSubmissions
     * const freeFeedbackSubmissions = await prisma.freeFeedbackSubmission.findMany()
     * 
     * // Get first 10 FreeFeedbackSubmissions
     * const freeFeedbackSubmissions = await prisma.freeFeedbackSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freeFeedbackSubmissionWithIdOnly = await prisma.freeFeedbackSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FreeFeedbackSubmissionFindManyArgs>(
      args?: SelectSubset<T, FreeFeedbackSubmissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FreeFeedbackSubmission>>, PrismaPromise<Array<FreeFeedbackSubmissionGetPayload<T>>>>

    /**
     * Create a FreeFeedbackSubmission.
     * @param {FreeFeedbackSubmissionCreateArgs} args - Arguments to create a FreeFeedbackSubmission.
     * @example
     * // Create one FreeFeedbackSubmission
     * const FreeFeedbackSubmission = await prisma.freeFeedbackSubmission.create({
     *   data: {
     *     // ... data to create a FreeFeedbackSubmission
     *   }
     * })
     * 
    **/
    create<T extends FreeFeedbackSubmissionCreateArgs>(
      args: SelectSubset<T, FreeFeedbackSubmissionCreateArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>>

    /**
     * Create many FreeFeedbackSubmissions.
     *     @param {FreeFeedbackSubmissionCreateManyArgs} args - Arguments to create many FreeFeedbackSubmissions.
     *     @example
     *     // Create many FreeFeedbackSubmissions
     *     const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FreeFeedbackSubmissionCreateManyArgs>(
      args?: SelectSubset<T, FreeFeedbackSubmissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FreeFeedbackSubmission.
     * @param {FreeFeedbackSubmissionDeleteArgs} args - Arguments to delete one FreeFeedbackSubmission.
     * @example
     * // Delete one FreeFeedbackSubmission
     * const FreeFeedbackSubmission = await prisma.freeFeedbackSubmission.delete({
     *   where: {
     *     // ... filter to delete one FreeFeedbackSubmission
     *   }
     * })
     * 
    **/
    delete<T extends FreeFeedbackSubmissionDeleteArgs>(
      args: SelectSubset<T, FreeFeedbackSubmissionDeleteArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>>

    /**
     * Update one FreeFeedbackSubmission.
     * @param {FreeFeedbackSubmissionUpdateArgs} args - Arguments to update one FreeFeedbackSubmission.
     * @example
     * // Update one FreeFeedbackSubmission
     * const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FreeFeedbackSubmissionUpdateArgs>(
      args: SelectSubset<T, FreeFeedbackSubmissionUpdateArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>>

    /**
     * Delete zero or more FreeFeedbackSubmissions.
     * @param {FreeFeedbackSubmissionDeleteManyArgs} args - Arguments to filter FreeFeedbackSubmissions to delete.
     * @example
     * // Delete a few FreeFeedbackSubmissions
     * const { count } = await prisma.freeFeedbackSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FreeFeedbackSubmissionDeleteManyArgs>(
      args?: SelectSubset<T, FreeFeedbackSubmissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreeFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreeFeedbackSubmissions
     * const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FreeFeedbackSubmissionUpdateManyArgs>(
      args: SelectSubset<T, FreeFeedbackSubmissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FreeFeedbackSubmission.
     * @param {FreeFeedbackSubmissionUpsertArgs} args - Arguments to update or create a FreeFeedbackSubmission.
     * @example
     * // Update or create a FreeFeedbackSubmission
     * const freeFeedbackSubmission = await prisma.freeFeedbackSubmission.upsert({
     *   create: {
     *     // ... data to create a FreeFeedbackSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreeFeedbackSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends FreeFeedbackSubmissionUpsertArgs>(
      args: SelectSubset<T, FreeFeedbackSubmissionUpsertArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission>, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T>>>

    /**
     * Count the number of FreeFeedbackSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionCountArgs} args - Arguments to filter FreeFeedbackSubmissions to count.
     * @example
     * // Count the number of FreeFeedbackSubmissions
     * const count = await prisma.freeFeedbackSubmission.count({
     *   where: {
     *     // ... the filter for the FreeFeedbackSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FreeFeedbackSubmissionCountArgs>(
      args?: Subset<T, FreeFeedbackSubmissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreeFeedbackSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreeFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreeFeedbackSubmissionAggregateArgs>(args: Subset<T, FreeFeedbackSubmissionAggregateArgs>): PrismaPromise<GetFreeFeedbackSubmissionAggregateType<T>>

    /**
     * Group by FreeFeedbackSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreeFeedbackSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreeFeedbackSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FreeFeedbackSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreeFeedbackSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreeFeedbackSubmissionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreeFeedbackSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FreeFeedbackSubmissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    feedbackConfig<T extends FeedbackConfigArgs = {}>(args?: Subset<T, FeedbackConfigArgs>): CheckSelect<T, Prisma__FeedbackConfigClient<FeedbackConfig | null >, Prisma__FeedbackConfigClient<FeedbackConfigGetPayload<T> | null >>;

    freeFeedbackResponses<T extends FreeFeedbackResponsesArgs = {}>(args?: Subset<T, FreeFeedbackResponsesArgs>): CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses | null >, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FreeFeedbackSubmission findUnique
   */
  export type FreeFeedbackSubmissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a FreeFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FreeFeedbackSubmission to fetch.
     * 
    **/
    where: FreeFeedbackSubmissionWhereUniqueInput
  }


  /**
   * FreeFeedbackSubmission findFirst
   */
  export type FreeFeedbackSubmissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * Throw an Error if a FreeFeedbackSubmission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FreeFeedbackSubmission to fetch.
     * 
    **/
    where?: FreeFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreeFeedbackSubmissions.
     * 
    **/
    cursor?: FreeFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackSubmissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreeFeedbackSubmissions.
     * 
    **/
    distinct?: Enumerable<FreeFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * FreeFeedbackSubmission findMany
   */
  export type FreeFeedbackSubmissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * Filter, which FreeFeedbackSubmissions to fetch.
     * 
    **/
    where?: FreeFeedbackSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackSubmissions to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreeFeedbackSubmissions.
     * 
    **/
    cursor?: FreeFeedbackSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackSubmissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackSubmissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FreeFeedbackSubmissionScalarFieldEnum>
  }


  /**
   * FreeFeedbackSubmission create
   */
  export type FreeFeedbackSubmissionCreateArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * The data needed to create a FreeFeedbackSubmission.
     * 
    **/
    data: XOR<FreeFeedbackSubmissionCreateInput, FreeFeedbackSubmissionUncheckedCreateInput>
  }


  /**
   * FreeFeedbackSubmission createMany
   */
  export type FreeFeedbackSubmissionCreateManyArgs = {
    /**
     * The data used to create many FreeFeedbackSubmissions.
     * 
    **/
    data: Enumerable<FreeFeedbackSubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FreeFeedbackSubmission update
   */
  export type FreeFeedbackSubmissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * The data needed to update a FreeFeedbackSubmission.
     * 
    **/
    data: XOR<FreeFeedbackSubmissionUpdateInput, FreeFeedbackSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FreeFeedbackSubmission to update.
     * 
    **/
    where: FreeFeedbackSubmissionWhereUniqueInput
  }


  /**
   * FreeFeedbackSubmission updateMany
   */
  export type FreeFeedbackSubmissionUpdateManyArgs = {
    /**
     * The data used to update FreeFeedbackSubmissions.
     * 
    **/
    data: XOR<FreeFeedbackSubmissionUpdateManyMutationInput, FreeFeedbackSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FreeFeedbackSubmissions to update
     * 
    **/
    where?: FreeFeedbackSubmissionWhereInput
  }


  /**
   * FreeFeedbackSubmission upsert
   */
  export type FreeFeedbackSubmissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * The filter to search for the FreeFeedbackSubmission to update in case it exists.
     * 
    **/
    where: FreeFeedbackSubmissionWhereUniqueInput
    /**
     * In case the FreeFeedbackSubmission found by the `where` argument doesn't exist, create a new FreeFeedbackSubmission with this data.
     * 
    **/
    create: XOR<FreeFeedbackSubmissionCreateInput, FreeFeedbackSubmissionUncheckedCreateInput>
    /**
     * In case the FreeFeedbackSubmission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FreeFeedbackSubmissionUpdateInput, FreeFeedbackSubmissionUncheckedUpdateInput>
  }


  /**
   * FreeFeedbackSubmission delete
   */
  export type FreeFeedbackSubmissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
    /**
     * Filter which FreeFeedbackSubmission to delete.
     * 
    **/
    where: FreeFeedbackSubmissionWhereUniqueInput
  }


  /**
   * FreeFeedbackSubmission deleteMany
   */
  export type FreeFeedbackSubmissionDeleteManyArgs = {
    /**
     * Filter which FreeFeedbackSubmissions to delete
     * 
    **/
    where?: FreeFeedbackSubmissionWhereInput
  }


  /**
   * FreeFeedbackSubmission without action
   */
  export type FreeFeedbackSubmissionArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackSubmission
     * 
    **/
    select?: FreeFeedbackSubmissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackSubmissionInclude | null
  }



  /**
   * Model FreeFeedbackResponses
   */


  export type AggregateFreeFeedbackResponses = {
    _count: FreeFeedbackResponsesCountAggregateOutputType | null
    _min: FreeFeedbackResponsesMinAggregateOutputType | null
    _max: FreeFeedbackResponsesMaxAggregateOutputType | null
  }

  export type FreeFeedbackResponsesMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreeFeedbackResponsesMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreeFeedbackResponsesCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    response: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreeFeedbackResponsesMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreeFeedbackResponsesMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreeFeedbackResponsesCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreeFeedbackResponsesAggregateArgs = {
    /**
     * Filter which FreeFeedbackResponses to aggregate.
     * 
    **/
    where?: FreeFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FreeFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreeFeedbackResponses
    **/
    _count?: true | FreeFeedbackResponsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreeFeedbackResponsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreeFeedbackResponsesMaxAggregateInputType
  }

  export type GetFreeFeedbackResponsesAggregateType<T extends FreeFeedbackResponsesAggregateArgs> = {
        [P in keyof T & keyof AggregateFreeFeedbackResponses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreeFeedbackResponses[P]>
      : GetScalarType<T[P], AggregateFreeFeedbackResponses[P]>
  }




  export type FreeFeedbackResponsesGroupByArgs = {
    where?: FreeFeedbackResponsesWhereInput
    orderBy?: Enumerable<FreeFeedbackResponsesOrderByWithAggregationInput>
    by: Array<FreeFeedbackResponsesScalarFieldEnum>
    having?: FreeFeedbackResponsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreeFeedbackResponsesCountAggregateInputType | true
    _min?: FreeFeedbackResponsesMinAggregateInputType
    _max?: FreeFeedbackResponsesMaxAggregateInputType
  }


  export type FreeFeedbackResponsesGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date | null
    response: string
    createdAt: Date
    updatedAt: Date
    _count: FreeFeedbackResponsesCountAggregateOutputType | null
    _min: FreeFeedbackResponsesMinAggregateOutputType | null
    _max: FreeFeedbackResponsesMaxAggregateOutputType | null
  }

  type GetFreeFeedbackResponsesGroupByPayload<T extends FreeFeedbackResponsesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FreeFeedbackResponsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreeFeedbackResponsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreeFeedbackResponsesGroupByOutputType[P]>
            : GetScalarType<T[P], FreeFeedbackResponsesGroupByOutputType[P]>
        }
      >
    >


  export type FreeFeedbackResponsesSelect = {
    id?: boolean
    freeFeedback?: boolean | FreeFeedbackSubmissionArgs
    startDate?: boolean
    endDate?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreeFeedbackResponsesInclude = {
    freeFeedback?: boolean | FreeFeedbackSubmissionArgs
  }

  export type FreeFeedbackResponsesGetPayload<
    S extends boolean | null | undefined | FreeFeedbackResponsesArgs,
    U = keyof S
      > = S extends true
        ? FreeFeedbackResponses
    : S extends undefined
    ? never
    : S extends FreeFeedbackResponsesArgs | FreeFeedbackResponsesFindManyArgs
    ?'include' extends U
    ? FreeFeedbackResponses  & {
    [P in TrueKeys<S['include']>]:
        P extends 'freeFeedback' ? FreeFeedbackSubmissionGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'freeFeedback' ? FreeFeedbackSubmissionGetPayload<S['select'][P]> | null :  P extends keyof FreeFeedbackResponses ? FreeFeedbackResponses[P] : never
  } 
    : FreeFeedbackResponses
  : FreeFeedbackResponses


  type FreeFeedbackResponsesCountArgs = Merge<
    Omit<FreeFeedbackResponsesFindManyArgs, 'select' | 'include'> & {
      select?: FreeFeedbackResponsesCountAggregateInputType | true
    }
  >

  export interface FreeFeedbackResponsesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FreeFeedbackResponses that matches the filter.
     * @param {FreeFeedbackResponsesFindUniqueArgs} args - Arguments to find a FreeFeedbackResponses
     * @example
     * // Get one FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FreeFeedbackResponsesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FreeFeedbackResponsesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FreeFeedbackResponses'> extends True ? CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses | null >, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find the first FreeFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesFindFirstArgs} args - Arguments to find a FreeFeedbackResponses
     * @example
     * // Get one FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FreeFeedbackResponsesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FreeFeedbackResponsesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FreeFeedbackResponses'> extends True ? CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>> : CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses | null >, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T> | null >>

    /**
     * Find zero or more FreeFeedbackResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.findMany()
     * 
     * // Get first 10 FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freeFeedbackResponsesWithIdOnly = await prisma.freeFeedbackResponses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FreeFeedbackResponsesFindManyArgs>(
      args?: SelectSubset<T, FreeFeedbackResponsesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<FreeFeedbackResponses>>, PrismaPromise<Array<FreeFeedbackResponsesGetPayload<T>>>>

    /**
     * Create a FreeFeedbackResponses.
     * @param {FreeFeedbackResponsesCreateArgs} args - Arguments to create a FreeFeedbackResponses.
     * @example
     * // Create one FreeFeedbackResponses
     * const FreeFeedbackResponses = await prisma.freeFeedbackResponses.create({
     *   data: {
     *     // ... data to create a FreeFeedbackResponses
     *   }
     * })
     * 
    **/
    create<T extends FreeFeedbackResponsesCreateArgs>(
      args: SelectSubset<T, FreeFeedbackResponsesCreateArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>>

    /**
     * Create many FreeFeedbackResponses.
     *     @param {FreeFeedbackResponsesCreateManyArgs} args - Arguments to create many FreeFeedbackResponses.
     *     @example
     *     // Create many FreeFeedbackResponses
     *     const freeFeedbackResponses = await prisma.freeFeedbackResponses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FreeFeedbackResponsesCreateManyArgs>(
      args?: SelectSubset<T, FreeFeedbackResponsesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FreeFeedbackResponses.
     * @param {FreeFeedbackResponsesDeleteArgs} args - Arguments to delete one FreeFeedbackResponses.
     * @example
     * // Delete one FreeFeedbackResponses
     * const FreeFeedbackResponses = await prisma.freeFeedbackResponses.delete({
     *   where: {
     *     // ... filter to delete one FreeFeedbackResponses
     *   }
     * })
     * 
    **/
    delete<T extends FreeFeedbackResponsesDeleteArgs>(
      args: SelectSubset<T, FreeFeedbackResponsesDeleteArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>>

    /**
     * Update one FreeFeedbackResponses.
     * @param {FreeFeedbackResponsesUpdateArgs} args - Arguments to update one FreeFeedbackResponses.
     * @example
     * // Update one FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FreeFeedbackResponsesUpdateArgs>(
      args: SelectSubset<T, FreeFeedbackResponsesUpdateArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>>

    /**
     * Delete zero or more FreeFeedbackResponses.
     * @param {FreeFeedbackResponsesDeleteManyArgs} args - Arguments to filter FreeFeedbackResponses to delete.
     * @example
     * // Delete a few FreeFeedbackResponses
     * const { count } = await prisma.freeFeedbackResponses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FreeFeedbackResponsesDeleteManyArgs>(
      args?: SelectSubset<T, FreeFeedbackResponsesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreeFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FreeFeedbackResponsesUpdateManyArgs>(
      args: SelectSubset<T, FreeFeedbackResponsesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FreeFeedbackResponses.
     * @param {FreeFeedbackResponsesUpsertArgs} args - Arguments to update or create a FreeFeedbackResponses.
     * @example
     * // Update or create a FreeFeedbackResponses
     * const freeFeedbackResponses = await prisma.freeFeedbackResponses.upsert({
     *   create: {
     *     // ... data to create a FreeFeedbackResponses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreeFeedbackResponses we want to update
     *   }
     * })
    **/
    upsert<T extends FreeFeedbackResponsesUpsertArgs>(
      args: SelectSubset<T, FreeFeedbackResponsesUpsertArgs>
    ): CheckSelect<T, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponses>, Prisma__FreeFeedbackResponsesClient<FreeFeedbackResponsesGetPayload<T>>>

    /**
     * Count the number of FreeFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesCountArgs} args - Arguments to filter FreeFeedbackResponses to count.
     * @example
     * // Count the number of FreeFeedbackResponses
     * const count = await prisma.freeFeedbackResponses.count({
     *   where: {
     *     // ... the filter for the FreeFeedbackResponses we want to count
     *   }
     * })
    **/
    count<T extends FreeFeedbackResponsesCountArgs>(
      args?: Subset<T, FreeFeedbackResponsesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreeFeedbackResponsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreeFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreeFeedbackResponsesAggregateArgs>(args: Subset<T, FreeFeedbackResponsesAggregateArgs>): PrismaPromise<GetFreeFeedbackResponsesAggregateType<T>>

    /**
     * Group by FreeFeedbackResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreeFeedbackResponsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreeFeedbackResponsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreeFeedbackResponsesGroupByArgs['orderBy'] }
        : { orderBy?: FreeFeedbackResponsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreeFeedbackResponsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreeFeedbackResponsesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreeFeedbackResponses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FreeFeedbackResponsesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    freeFeedback<T extends FreeFeedbackSubmissionArgs = {}>(args?: Subset<T, FreeFeedbackSubmissionArgs>): CheckSelect<T, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmission | null >, Prisma__FreeFeedbackSubmissionClient<FreeFeedbackSubmissionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * FreeFeedbackResponses findUnique
   */
  export type FreeFeedbackResponsesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * Throw an Error if a FreeFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FreeFeedbackResponses to fetch.
     * 
    **/
    where: FreeFeedbackResponsesWhereUniqueInput
  }


  /**
   * FreeFeedbackResponses findFirst
   */
  export type FreeFeedbackResponsesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * Throw an Error if a FreeFeedbackResponses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which FreeFeedbackResponses to fetch.
     * 
    **/
    where?: FreeFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreeFeedbackResponses.
     * 
    **/
    cursor?: FreeFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackResponses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreeFeedbackResponses.
     * 
    **/
    distinct?: Enumerable<FreeFeedbackResponsesScalarFieldEnum>
  }


  /**
   * FreeFeedbackResponses findMany
   */
  export type FreeFeedbackResponsesFindManyArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * Filter, which FreeFeedbackResponses to fetch.
     * 
    **/
    where?: FreeFeedbackResponsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreeFeedbackResponses to fetch.
     * 
    **/
    orderBy?: Enumerable<FreeFeedbackResponsesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreeFeedbackResponses.
     * 
    **/
    cursor?: FreeFeedbackResponsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreeFeedbackResponses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreeFeedbackResponses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FreeFeedbackResponsesScalarFieldEnum>
  }


  /**
   * FreeFeedbackResponses create
   */
  export type FreeFeedbackResponsesCreateArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * The data needed to create a FreeFeedbackResponses.
     * 
    **/
    data: XOR<FreeFeedbackResponsesCreateInput, FreeFeedbackResponsesUncheckedCreateInput>
  }


  /**
   * FreeFeedbackResponses createMany
   */
  export type FreeFeedbackResponsesCreateManyArgs = {
    /**
     * The data used to create many FreeFeedbackResponses.
     * 
    **/
    data: Enumerable<FreeFeedbackResponsesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FreeFeedbackResponses update
   */
  export type FreeFeedbackResponsesUpdateArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * The data needed to update a FreeFeedbackResponses.
     * 
    **/
    data: XOR<FreeFeedbackResponsesUpdateInput, FreeFeedbackResponsesUncheckedUpdateInput>
    /**
     * Choose, which FreeFeedbackResponses to update.
     * 
    **/
    where: FreeFeedbackResponsesWhereUniqueInput
  }


  /**
   * FreeFeedbackResponses updateMany
   */
  export type FreeFeedbackResponsesUpdateManyArgs = {
    /**
     * The data used to update FreeFeedbackResponses.
     * 
    **/
    data: XOR<FreeFeedbackResponsesUpdateManyMutationInput, FreeFeedbackResponsesUncheckedUpdateManyInput>
    /**
     * Filter which FreeFeedbackResponses to update
     * 
    **/
    where?: FreeFeedbackResponsesWhereInput
  }


  /**
   * FreeFeedbackResponses upsert
   */
  export type FreeFeedbackResponsesUpsertArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * The filter to search for the FreeFeedbackResponses to update in case it exists.
     * 
    **/
    where: FreeFeedbackResponsesWhereUniqueInput
    /**
     * In case the FreeFeedbackResponses found by the `where` argument doesn't exist, create a new FreeFeedbackResponses with this data.
     * 
    **/
    create: XOR<FreeFeedbackResponsesCreateInput, FreeFeedbackResponsesUncheckedCreateInput>
    /**
     * In case the FreeFeedbackResponses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FreeFeedbackResponsesUpdateInput, FreeFeedbackResponsesUncheckedUpdateInput>
  }


  /**
   * FreeFeedbackResponses delete
   */
  export type FreeFeedbackResponsesDeleteArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
    /**
     * Filter which FreeFeedbackResponses to delete.
     * 
    **/
    where: FreeFeedbackResponsesWhereUniqueInput
  }


  /**
   * FreeFeedbackResponses deleteMany
   */
  export type FreeFeedbackResponsesDeleteManyArgs = {
    /**
     * Filter which FreeFeedbackResponses to delete
     * 
    **/
    where?: FreeFeedbackResponsesWhereInput
  }


  /**
   * FreeFeedbackResponses without action
   */
  export type FreeFeedbackResponsesArgs = {
    /**
     * Select specific fields to fetch from the FreeFeedbackResponses
     * 
    **/
    select?: FreeFeedbackResponsesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FreeFeedbackResponsesInclude | null
  }



  /**
   * Model File
   */


  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    engagementId: string | null
    engagementDraftId: string | null
    blobName: string | null
    containerName: string | null
    path: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    engagementId: string | null
    engagementDraftId: string | null
    blobName: string | null
    containerName: string | null
    path: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    engagementId: number
    engagementDraftId: number
    blobName: number
    containerName: number
    path: number
    _all: number
  }


  export type FileMinAggregateInputType = {
    id?: true
    engagementId?: true
    engagementDraftId?: true
    blobName?: true
    containerName?: true
    path?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    engagementId?: true
    engagementDraftId?: true
    blobName?: true
    containerName?: true
    path?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    engagementId?: true
    engagementDraftId?: true
    blobName?: true
    containerName?: true
    path?: true
    _all?: true
  }

  export type FileAggregateArgs = {
    /**
     * Filter which File to aggregate.
     * 
    **/
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs = {
    where?: FileWhereInput
    orderBy?: Enumerable<FileOrderByWithAggregationInput>
    by: Array<FileScalarFieldEnum>
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }


  export type FileGroupByOutputType = {
    id: string
    engagementId: string | null
    engagementDraftId: string | null
    blobName: string
    containerName: string
    path: string
    _count: FileCountAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect = {
    id?: boolean
    engagement?: boolean | EngagementArgs
    engagementId?: boolean
    engagementDraft?: boolean | EngagementDraftArgs
    engagementDraftId?: boolean
    blobName?: boolean
    containerName?: boolean
    path?: boolean
  }

  export type FileInclude = {
    engagement?: boolean | EngagementArgs
    engagementDraft?: boolean | EngagementDraftArgs
  }

  export type FileGetPayload<
    S extends boolean | null | undefined | FileArgs,
    U = keyof S
      > = S extends true
        ? File
    : S extends undefined
    ? never
    : S extends FileArgs | FileFindManyArgs
    ?'include' extends U
    ? File  & {
    [P in TrueKeys<S['include']>]:
        P extends 'engagement' ? EngagementGetPayload<S['include'][P]> | null :
        P extends 'engagementDraft' ? EngagementDraftGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'engagement' ? EngagementGetPayload<S['select'][P]> | null :
        P extends 'engagementDraft' ? EngagementDraftGetPayload<S['select'][P]> | null :  P extends keyof File ? File[P] : never
  } 
    : File
  : File


  type FileCountArgs = Merge<
    Omit<FileFindManyArgs, 'select' | 'include'> & {
      select?: FileCountAggregateInputType | true
    }
  >

  export interface FileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'File'> extends True ? CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>> : CheckSelect<T, Prisma__FileClient<File | null >, Prisma__FileClient<FileGetPayload<T> | null >>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'File'> extends True ? CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>> : CheckSelect<T, Prisma__FileClient<File | null >, Prisma__FileClient<FileGetPayload<T> | null >>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FileFindManyArgs>(
      args?: SelectSubset<T, FileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<File>>, PrismaPromise<Array<FileGetPayload<T>>>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
    **/
    create<T extends FileCreateArgs>(
      args: SelectSubset<T, FileCreateArgs>
    ): CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>>

    /**
     * Create many Files.
     *     @param {FileCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const file = await prisma.file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FileCreateManyArgs>(
      args?: SelectSubset<T, FileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
    **/
    delete<T extends FileDeleteArgs>(
      args: SelectSubset<T, FileDeleteArgs>
    ): CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FileUpdateArgs>(
      args: SelectSubset<T, FileUpdateArgs>
    ): CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FileDeleteManyArgs>(
      args?: SelectSubset<T, FileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FileUpdateManyArgs>(
      args: SelectSubset<T, FileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
    **/
    upsert<T extends FileUpsertArgs>(
      args: SelectSubset<T, FileUpsertArgs>
    ): CheckSelect<T, Prisma__FileClient<File>, Prisma__FileClient<FileGetPayload<T>>>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    engagement<T extends EngagementArgs = {}>(args?: Subset<T, EngagementArgs>): CheckSelect<T, Prisma__EngagementClient<Engagement | null >, Prisma__EngagementClient<EngagementGetPayload<T> | null >>;

    engagementDraft<T extends EngagementDraftArgs = {}>(args?: Subset<T, EngagementDraftArgs>): CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft | null >, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * File findUnique
   */
  export type FileFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * Throw an Error if a File can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which File to fetch.
     * 
    **/
    where: FileWhereUniqueInput
  }


  /**
   * File findFirst
   */
  export type FileFindFirstArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * Throw an Error if a File can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which File to fetch.
     * 
    **/
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     * 
    **/
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     * 
    **/
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * File findMany
   */
  export type FileFindManyArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * Filter, which Files to fetch.
     * 
    **/
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     * 
    **/
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     * 
    **/
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * File create
   */
  export type FileCreateArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * The data needed to create a File.
     * 
    **/
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }


  /**
   * File createMany
   */
  export type FileCreateManyArgs = {
    /**
     * The data used to create many Files.
     * 
    **/
    data: Enumerable<FileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * File update
   */
  export type FileUpdateArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * The data needed to update a File.
     * 
    **/
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     * 
    **/
    where: FileWhereUniqueInput
  }


  /**
   * File updateMany
   */
  export type FileUpdateManyArgs = {
    /**
     * The data used to update Files.
     * 
    **/
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     * 
    **/
    where?: FileWhereInput
  }


  /**
   * File upsert
   */
  export type FileUpsertArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * The filter to search for the File to update in case it exists.
     * 
    **/
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     * 
    **/
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }


  /**
   * File delete
   */
  export type FileDeleteArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
    /**
     * Filter which File to delete.
     * 
    **/
    where: FileWhereUniqueInput
  }


  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs = {
    /**
     * Filter which Files to delete
     * 
    **/
    where?: FileWhereInput
  }


  /**
   * File without action
   */
  export type FileArgs = {
    /**
     * Select specific fields to fetch from the File
     * 
    **/
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FileInclude | null
  }



  /**
   * Model EngagementDraft
   */


  export type AggregateEngagementDraft = {
    _count: EngagementDraftCountAggregateOutputType | null
    _avg: EngagementDraftAvgAggregateOutputType | null
    _sum: EngagementDraftSumAggregateOutputType | null
    _min: EngagementDraftMinAggregateOutputType | null
    _max: EngagementDraftMaxAggregateOutputType | null
  }

  export type EngagementDraftAvgAggregateOutputType = {
    cft: number | null
  }

  export type EngagementDraftSumAggregateOutputType = {
    cft: number | null
  }

  export type EngagementDraftMinAggregateOutputType = {
    id: string | null
    userId: string | null
    engagementTitle: string | null
    engagementSummary: string | null
    associatedProgram: string | null
    soldierInput: string | null
    soldiersNeeded: string | null
    preferredDivision: string | null
    mos: string | null
    armyImpact: string | null
    cft: number | null
    engagementRequest: string | null
    feedbackType: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventTitle: string | null
    eventDescription: string | null
    dueDate: Date | null
    dueDateTitle: string | null
    addressOne: string | null
    addressTwo: string | null
    city: string | null
    state: string | null
    zip: string | null
    funding: string | null
    otherInfo: string | null
    requestorName: string | null
    requestorEmail: string | null
    requestorPhone: string | null
    requestorTitle: string | null
    requestorOrganization: string | null
    freeFormQuestion: string | null
  }

  export type EngagementDraftMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    engagementTitle: string | null
    engagementSummary: string | null
    associatedProgram: string | null
    soldierInput: string | null
    soldiersNeeded: string | null
    preferredDivision: string | null
    mos: string | null
    armyImpact: string | null
    cft: number | null
    engagementRequest: string | null
    feedbackType: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventTitle: string | null
    eventDescription: string | null
    dueDate: Date | null
    dueDateTitle: string | null
    addressOne: string | null
    addressTwo: string | null
    city: string | null
    state: string | null
    zip: string | null
    funding: string | null
    otherInfo: string | null
    requestorName: string | null
    requestorEmail: string | null
    requestorPhone: string | null
    requestorTitle: string | null
    requestorOrganization: string | null
    freeFormQuestion: string | null
  }

  export type EngagementDraftCountAggregateOutputType = {
    id: number
    userId: number
    engagementTitle: number
    engagementSummary: number
    associatedProgram: number
    soldierInput: number
    soldiersNeeded: number
    preferredDivision: number
    mos: number
    requirements: number
    armyImpact: number
    cft: number
    engagementRequest: number
    feedbackType: number
    eventStartDate: number
    eventEndDate: number
    eventTitle: number
    eventDescription: number
    dueDate: number
    dueDateTitle: number
    addressOne: number
    addressTwo: number
    city: number
    state: number
    zip: number
    funding: number
    otherInfo: number
    requestorName: number
    requestorEmail: number
    requestorPhone: number
    requestorTitle: number
    requestorOrganization: number
    freeFormQuestion: number
    _all: number
  }


  export type EngagementDraftAvgAggregateInputType = {
    cft?: true
  }

  export type EngagementDraftSumAggregateInputType = {
    cft?: true
  }

  export type EngagementDraftMinAggregateInputType = {
    id?: true
    userId?: true
    engagementTitle?: true
    engagementSummary?: true
    associatedProgram?: true
    soldierInput?: true
    soldiersNeeded?: true
    preferredDivision?: true
    mos?: true
    armyImpact?: true
    cft?: true
    engagementRequest?: true
    feedbackType?: true
    eventStartDate?: true
    eventEndDate?: true
    eventTitle?: true
    eventDescription?: true
    dueDate?: true
    dueDateTitle?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
    funding?: true
    otherInfo?: true
    requestorName?: true
    requestorEmail?: true
    requestorPhone?: true
    requestorTitle?: true
    requestorOrganization?: true
    freeFormQuestion?: true
  }

  export type EngagementDraftMaxAggregateInputType = {
    id?: true
    userId?: true
    engagementTitle?: true
    engagementSummary?: true
    associatedProgram?: true
    soldierInput?: true
    soldiersNeeded?: true
    preferredDivision?: true
    mos?: true
    armyImpact?: true
    cft?: true
    engagementRequest?: true
    feedbackType?: true
    eventStartDate?: true
    eventEndDate?: true
    eventTitle?: true
    eventDescription?: true
    dueDate?: true
    dueDateTitle?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
    funding?: true
    otherInfo?: true
    requestorName?: true
    requestorEmail?: true
    requestorPhone?: true
    requestorTitle?: true
    requestorOrganization?: true
    freeFormQuestion?: true
  }

  export type EngagementDraftCountAggregateInputType = {
    id?: true
    userId?: true
    engagementTitle?: true
    engagementSummary?: true
    associatedProgram?: true
    soldierInput?: true
    soldiersNeeded?: true
    preferredDivision?: true
    mos?: true
    requirements?: true
    armyImpact?: true
    cft?: true
    engagementRequest?: true
    feedbackType?: true
    eventStartDate?: true
    eventEndDate?: true
    eventTitle?: true
    eventDescription?: true
    dueDate?: true
    dueDateTitle?: true
    addressOne?: true
    addressTwo?: true
    city?: true
    state?: true
    zip?: true
    funding?: true
    otherInfo?: true
    requestorName?: true
    requestorEmail?: true
    requestorPhone?: true
    requestorTitle?: true
    requestorOrganization?: true
    freeFormQuestion?: true
    _all?: true
  }

  export type EngagementDraftAggregateArgs = {
    /**
     * Filter which EngagementDraft to aggregate.
     * 
    **/
    where?: EngagementDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDrafts to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDraftOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EngagementDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDrafts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDrafts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EngagementDrafts
    **/
    _count?: true | EngagementDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EngagementDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EngagementDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementDraftMaxAggregateInputType
  }

  export type GetEngagementDraftAggregateType<T extends EngagementDraftAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagementDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagementDraft[P]>
      : GetScalarType<T[P], AggregateEngagementDraft[P]>
  }




  export type EngagementDraftGroupByArgs = {
    where?: EngagementDraftWhereInput
    orderBy?: Enumerable<EngagementDraftOrderByWithAggregationInput>
    by: Array<EngagementDraftScalarFieldEnum>
    having?: EngagementDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementDraftCountAggregateInputType | true
    _avg?: EngagementDraftAvgAggregateInputType
    _sum?: EngagementDraftSumAggregateInputType
    _min?: EngagementDraftMinAggregateInputType
    _max?: EngagementDraftMaxAggregateInputType
  }


  export type EngagementDraftGroupByOutputType = {
    id: string
    userId: string
    engagementTitle: string | null
    engagementSummary: string | null
    associatedProgram: string | null
    soldierInput: string | null
    soldiersNeeded: string | null
    preferredDivision: string | null
    mos: string | null
    requirements: string[]
    armyImpact: string | null
    cft: number | null
    engagementRequest: string | null
    feedbackType: string | null
    eventStartDate: Date | null
    eventEndDate: Date | null
    eventTitle: string | null
    eventDescription: string | null
    dueDate: Date | null
    dueDateTitle: string | null
    addressOne: string | null
    addressTwo: string | null
    city: string | null
    state: string | null
    zip: string | null
    funding: string | null
    otherInfo: string | null
    requestorName: string | null
    requestorEmail: string | null
    requestorPhone: string | null
    requestorTitle: string | null
    requestorOrganization: string | null
    freeFormQuestion: string | null
    _count: EngagementDraftCountAggregateOutputType | null
    _avg: EngagementDraftAvgAggregateOutputType | null
    _sum: EngagementDraftSumAggregateOutputType | null
    _min: EngagementDraftMinAggregateOutputType | null
    _max: EngagementDraftMaxAggregateOutputType | null
  }

  type GetEngagementDraftGroupByPayload<T extends EngagementDraftGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EngagementDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementDraftGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementDraftGroupByOutputType[P]>
        }
      >
    >


  export type EngagementDraftSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    engagementTitle?: boolean
    engagementSummary?: boolean
    associatedProgram?: boolean
    soldierInput?: boolean
    soldiersNeeded?: boolean
    preferredDivision?: boolean
    mos?: boolean
    requirements?: boolean
    armyImpact?: boolean
    cft?: boolean
    engagementRequest?: boolean
    feedbackType?: boolean
    files?: boolean | FileFindManyArgs
    eventStartDate?: boolean
    eventEndDate?: boolean
    eventTitle?: boolean
    eventDescription?: boolean
    dueDate?: boolean
    dueDateTitle?: boolean
    addressOne?: boolean
    addressTwo?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    funding?: boolean
    otherInfo?: boolean
    requestorName?: boolean
    requestorEmail?: boolean
    requestorPhone?: boolean
    requestorTitle?: boolean
    requestorOrganization?: boolean
    freeFormQuestion?: boolean
    _count?: boolean | EngagementDraftCountOutputTypeArgs
  }

  export type EngagementDraftInclude = {
    user?: boolean | UserArgs
    files?: boolean | FileFindManyArgs
    _count?: boolean | EngagementDraftCountOutputTypeArgs
  }

  export type EngagementDraftGetPayload<
    S extends boolean | null | undefined | EngagementDraftArgs,
    U = keyof S
      > = S extends true
        ? EngagementDraft
    : S extends undefined
    ? never
    : S extends EngagementDraftArgs | EngagementDraftFindManyArgs
    ?'include' extends U
    ? EngagementDraft  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'files' ? Array < FileGetPayload<S['include'][P]>>  :
        P extends '_count' ? EngagementDraftCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'files' ? Array < FileGetPayload<S['select'][P]>>  :
        P extends '_count' ? EngagementDraftCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof EngagementDraft ? EngagementDraft[P] : never
  } 
    : EngagementDraft
  : EngagementDraft


  type EngagementDraftCountArgs = Merge<
    Omit<EngagementDraftFindManyArgs, 'select' | 'include'> & {
      select?: EngagementDraftCountAggregateInputType | true
    }
  >

  export interface EngagementDraftDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EngagementDraft that matches the filter.
     * @param {EngagementDraftFindUniqueArgs} args - Arguments to find a EngagementDraft
     * @example
     * // Get one EngagementDraft
     * const engagementDraft = await prisma.engagementDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EngagementDraftFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EngagementDraftFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EngagementDraft'> extends True ? CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>> : CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft | null >, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T> | null >>

    /**
     * Find the first EngagementDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftFindFirstArgs} args - Arguments to find a EngagementDraft
     * @example
     * // Get one EngagementDraft
     * const engagementDraft = await prisma.engagementDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EngagementDraftFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EngagementDraftFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EngagementDraft'> extends True ? CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>> : CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft | null >, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T> | null >>

    /**
     * Find zero or more EngagementDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EngagementDrafts
     * const engagementDrafts = await prisma.engagementDraft.findMany()
     * 
     * // Get first 10 EngagementDrafts
     * const engagementDrafts = await prisma.engagementDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementDraftWithIdOnly = await prisma.engagementDraft.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EngagementDraftFindManyArgs>(
      args?: SelectSubset<T, EngagementDraftFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EngagementDraft>>, PrismaPromise<Array<EngagementDraftGetPayload<T>>>>

    /**
     * Create a EngagementDraft.
     * @param {EngagementDraftCreateArgs} args - Arguments to create a EngagementDraft.
     * @example
     * // Create one EngagementDraft
     * const EngagementDraft = await prisma.engagementDraft.create({
     *   data: {
     *     // ... data to create a EngagementDraft
     *   }
     * })
     * 
    **/
    create<T extends EngagementDraftCreateArgs>(
      args: SelectSubset<T, EngagementDraftCreateArgs>
    ): CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>>

    /**
     * Create many EngagementDrafts.
     *     @param {EngagementDraftCreateManyArgs} args - Arguments to create many EngagementDrafts.
     *     @example
     *     // Create many EngagementDrafts
     *     const engagementDraft = await prisma.engagementDraft.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EngagementDraftCreateManyArgs>(
      args?: SelectSubset<T, EngagementDraftCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EngagementDraft.
     * @param {EngagementDraftDeleteArgs} args - Arguments to delete one EngagementDraft.
     * @example
     * // Delete one EngagementDraft
     * const EngagementDraft = await prisma.engagementDraft.delete({
     *   where: {
     *     // ... filter to delete one EngagementDraft
     *   }
     * })
     * 
    **/
    delete<T extends EngagementDraftDeleteArgs>(
      args: SelectSubset<T, EngagementDraftDeleteArgs>
    ): CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>>

    /**
     * Update one EngagementDraft.
     * @param {EngagementDraftUpdateArgs} args - Arguments to update one EngagementDraft.
     * @example
     * // Update one EngagementDraft
     * const engagementDraft = await prisma.engagementDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EngagementDraftUpdateArgs>(
      args: SelectSubset<T, EngagementDraftUpdateArgs>
    ): CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>>

    /**
     * Delete zero or more EngagementDrafts.
     * @param {EngagementDraftDeleteManyArgs} args - Arguments to filter EngagementDrafts to delete.
     * @example
     * // Delete a few EngagementDrafts
     * const { count } = await prisma.engagementDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EngagementDraftDeleteManyArgs>(
      args?: SelectSubset<T, EngagementDraftDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EngagementDrafts
     * const engagementDraft = await prisma.engagementDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EngagementDraftUpdateManyArgs>(
      args: SelectSubset<T, EngagementDraftUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EngagementDraft.
     * @param {EngagementDraftUpsertArgs} args - Arguments to update or create a EngagementDraft.
     * @example
     * // Update or create a EngagementDraft
     * const engagementDraft = await prisma.engagementDraft.upsert({
     *   create: {
     *     // ... data to create a EngagementDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EngagementDraft we want to update
     *   }
     * })
    **/
    upsert<T extends EngagementDraftUpsertArgs>(
      args: SelectSubset<T, EngagementDraftUpsertArgs>
    ): CheckSelect<T, Prisma__EngagementDraftClient<EngagementDraft>, Prisma__EngagementDraftClient<EngagementDraftGetPayload<T>>>

    /**
     * Count the number of EngagementDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftCountArgs} args - Arguments to filter EngagementDrafts to count.
     * @example
     * // Count the number of EngagementDrafts
     * const count = await prisma.engagementDraft.count({
     *   where: {
     *     // ... the filter for the EngagementDrafts we want to count
     *   }
     * })
    **/
    count<T extends EngagementDraftCountArgs>(
      args?: Subset<T, EngagementDraftCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EngagementDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementDraftAggregateArgs>(args: Subset<T, EngagementDraftAggregateArgs>): PrismaPromise<GetEngagementDraftAggregateType<T>>

    /**
     * Group by EngagementDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementDraftGroupByArgs['orderBy'] }
        : { orderBy?: EngagementDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementDraftGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EngagementDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EngagementDraftClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    files<T extends FileFindManyArgs = {}>(args?: Subset<T, FileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<File>>, PrismaPromise<Array<FileGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EngagementDraft findUnique
   */
  export type EngagementDraftFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * Throw an Error if a EngagementDraft can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EngagementDraft to fetch.
     * 
    **/
    where: EngagementDraftWhereUniqueInput
  }


  /**
   * EngagementDraft findFirst
   */
  export type EngagementDraftFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * Throw an Error if a EngagementDraft can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EngagementDraft to fetch.
     * 
    **/
    where?: EngagementDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDrafts to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDraftOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementDrafts.
     * 
    **/
    cursor?: EngagementDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDrafts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDrafts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementDrafts.
     * 
    **/
    distinct?: Enumerable<EngagementDraftScalarFieldEnum>
  }


  /**
   * EngagementDraft findMany
   */
  export type EngagementDraftFindManyArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * Filter, which EngagementDrafts to fetch.
     * 
    **/
    where?: EngagementDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementDrafts to fetch.
     * 
    **/
    orderBy?: Enumerable<EngagementDraftOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EngagementDrafts.
     * 
    **/
    cursor?: EngagementDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementDrafts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementDrafts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EngagementDraftScalarFieldEnum>
  }


  /**
   * EngagementDraft create
   */
  export type EngagementDraftCreateArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * The data needed to create a EngagementDraft.
     * 
    **/
    data: XOR<EngagementDraftCreateInput, EngagementDraftUncheckedCreateInput>
  }


  /**
   * EngagementDraft createMany
   */
  export type EngagementDraftCreateManyArgs = {
    /**
     * The data used to create many EngagementDrafts.
     * 
    **/
    data: Enumerable<EngagementDraftCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EngagementDraft update
   */
  export type EngagementDraftUpdateArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * The data needed to update a EngagementDraft.
     * 
    **/
    data: XOR<EngagementDraftUpdateInput, EngagementDraftUncheckedUpdateInput>
    /**
     * Choose, which EngagementDraft to update.
     * 
    **/
    where: EngagementDraftWhereUniqueInput
  }


  /**
   * EngagementDraft updateMany
   */
  export type EngagementDraftUpdateManyArgs = {
    /**
     * The data used to update EngagementDrafts.
     * 
    **/
    data: XOR<EngagementDraftUpdateManyMutationInput, EngagementDraftUncheckedUpdateManyInput>
    /**
     * Filter which EngagementDrafts to update
     * 
    **/
    where?: EngagementDraftWhereInput
  }


  /**
   * EngagementDraft upsert
   */
  export type EngagementDraftUpsertArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * The filter to search for the EngagementDraft to update in case it exists.
     * 
    **/
    where: EngagementDraftWhereUniqueInput
    /**
     * In case the EngagementDraft found by the `where` argument doesn't exist, create a new EngagementDraft with this data.
     * 
    **/
    create: XOR<EngagementDraftCreateInput, EngagementDraftUncheckedCreateInput>
    /**
     * In case the EngagementDraft was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EngagementDraftUpdateInput, EngagementDraftUncheckedUpdateInput>
  }


  /**
   * EngagementDraft delete
   */
  export type EngagementDraftDeleteArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
    /**
     * Filter which EngagementDraft to delete.
     * 
    **/
    where: EngagementDraftWhereUniqueInput
  }


  /**
   * EngagementDraft deleteMany
   */
  export type EngagementDraftDeleteManyArgs = {
    /**
     * Filter which EngagementDrafts to delete
     * 
    **/
    where?: EngagementDraftWhereInput
  }


  /**
   * EngagementDraft without action
   */
  export type EngagementDraftArgs = {
    /**
     * Select specific fields to fetch from the EngagementDraft
     * 
    **/
    select?: EngagementDraftSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EngagementDraftInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    initials: 'initials',
    email: 'email',
    password: 'password',
    organizationId: 'organizationId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const OrganizationAccessScalarFieldEnum: {
    organizationId: 'organizationId',
    userId: 'userId',
    read: 'read',
    write: 'write',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationAccessScalarFieldEnum = (typeof OrganizationAccessScalarFieldEnum)[keyof typeof OrganizationAccessScalarFieldEnum]


  export const EngagementScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    locationId: 'locationId',
    demographicId: 'demographicId',
    engagementDetailId: 'engagementDetailId',
    status: 'status',
    crossFunctionalTeamId: 'crossFunctionalTeamId',
    requestorId: 'requestorId',
    shortId: 'shortId',
    feedbackConfigId: 'feedbackConfigId',
    isDeleted: 'isDeleted',
    statusChangedOn: 'statusChangedOn'
  };

  export type EngagementScalarFieldEnum = (typeof EngagementScalarFieldEnum)[keyof typeof EngagementScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    addressOne: 'addressOne',
    addressTwo: 'addressTwo',
    city: 'city',
    state: 'state',
    zip: 'zip'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const EngagementDetailScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    description: 'description',
    associatedProgram: 'associatedProgram',
    armyImpact: 'armyImpact',
    fundingDetails: 'fundingDetails',
    otherInformation: 'otherInformation'
  };

  export type EngagementDetailScalarFieldEnum = (typeof EngagementDetailScalarFieldEnum)[keyof typeof EngagementDetailScalarFieldEnum]


  export const CrossFunctionalTeamsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrossFunctionalTeamsScalarFieldEnum = (typeof CrossFunctionalTeamsScalarFieldEnum)[keyof typeof CrossFunctionalTeamsScalarFieldEnum]


  export const DemographicScalarFieldEnum: {
    id: 'id',
    soldierInput: 'soldierInput',
    soldiersNeeded: 'soldiersNeeded',
    mos: 'mos'
  };

  export type DemographicScalarFieldEnum = (typeof DemographicScalarFieldEnum)[keyof typeof DemographicScalarFieldEnum]


  export const RequirementScalarFieldEnum: {
    id: 'id',
    content: 'content'
  };

  export type RequirementScalarFieldEnum = (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum]


  export const RequestorInformationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organization: 'organization',
    title: 'title',
    email: 'email',
    phone: 'phone'
  };

  export type RequestorInformationScalarFieldEnum = (typeof RequestorInformationScalarFieldEnum)[keyof typeof RequestorInformationScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    title: 'title',
    description: 'description',
    engagementId: 'engagementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const DueDateScalarFieldEnum: {
    id: 'id',
    title: 'title',
    dueDate: 'dueDate',
    engagementId: 'engagementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DueDateScalarFieldEnum = (typeof DueDateScalarFieldEnum)[keyof typeof DueDateScalarFieldEnum]


  export const FeedbackConfigScalarFieldEnum: {
    id: 'id',
    feedbackType: 'feedbackType',
    isHumanResearch: 'isHumanResearch',
    hasSubmissions: 'hasSubmissions',
    freeFormQuestion: 'freeFormQuestion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackConfigScalarFieldEnum = (typeof FeedbackConfigScalarFieldEnum)[keyof typeof FeedbackConfigScalarFieldEnum]


  export const TestFeedbackSubmissionScalarFieldEnum: {
    id: 'id',
    feedbackConfigId: 'feedbackConfigId',
    rating: 'rating',
    testFeedbackResponseId: 'testFeedbackResponseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestFeedbackSubmissionScalarFieldEnum = (typeof TestFeedbackSubmissionScalarFieldEnum)[keyof typeof TestFeedbackSubmissionScalarFieldEnum]


  export const TestFeedbackResponsesScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    customResponse: 'customResponse',
    results: 'results',
    anticipatedResults: 'anticipatedResults',
    conditionsConstraints: 'conditionsConstraints',
    metExpectations: 'metExpectations',
    notMetExpectations: 'notMetExpectations',
    otherOpportunities: 'otherOpportunities',
    additionalThoughts: 'additionalThoughts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestFeedbackResponsesScalarFieldEnum = (typeof TestFeedbackResponsesScalarFieldEnum)[keyof typeof TestFeedbackResponsesScalarFieldEnum]


  export const InputFeedbackSubmissionScalarFieldEnum: {
    id: 'id',
    feedbackConfigId: 'feedbackConfigId',
    inputFeedbackResponseId: 'inputFeedbackResponseId',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InputFeedbackSubmissionScalarFieldEnum = (typeof InputFeedbackSubmissionScalarFieldEnum)[keyof typeof InputFeedbackSubmissionScalarFieldEnum]


  export const InputFeedbackResponsesScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    customResponse: 'customResponse',
    opportunities: 'opportunities',
    processSolution: 'processSolution',
    notAsked: 'notAsked',
    responseViews: 'responseViews',
    additionalThoughts: 'additionalThoughts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InputFeedbackResponsesScalarFieldEnum = (typeof InputFeedbackResponsesScalarFieldEnum)[keyof typeof InputFeedbackResponsesScalarFieldEnum]


  export const FreeFeedbackSubmissionScalarFieldEnum: {
    id: 'id',
    feedbackConfigId: 'feedbackConfigId',
    freeFeedbackResponseId: 'freeFeedbackResponseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rating: 'rating'
  };

  export type FreeFeedbackSubmissionScalarFieldEnum = (typeof FreeFeedbackSubmissionScalarFieldEnum)[keyof typeof FreeFeedbackSubmissionScalarFieldEnum]


  export const FreeFeedbackResponsesScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreeFeedbackResponsesScalarFieldEnum = (typeof FreeFeedbackResponsesScalarFieldEnum)[keyof typeof FreeFeedbackResponsesScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    engagementId: 'engagementId',
    engagementDraftId: 'engagementDraftId',
    blobName: 'blobName',
    containerName: 'containerName',
    path: 'path'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const EngagementDraftScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    engagementTitle: 'engagementTitle',
    engagementSummary: 'engagementSummary',
    associatedProgram: 'associatedProgram',
    soldierInput: 'soldierInput',
    soldiersNeeded: 'soldiersNeeded',
    preferredDivision: 'preferredDivision',
    mos: 'mos',
    requirements: 'requirements',
    armyImpact: 'armyImpact',
    cft: 'cft',
    engagementRequest: 'engagementRequest',
    feedbackType: 'feedbackType',
    eventStartDate: 'eventStartDate',
    eventEndDate: 'eventEndDate',
    eventTitle: 'eventTitle',
    eventDescription: 'eventDescription',
    dueDate: 'dueDate',
    dueDateTitle: 'dueDateTitle',
    addressOne: 'addressOne',
    addressTwo: 'addressTwo',
    city: 'city',
    state: 'state',
    zip: 'zip',
    funding: 'funding',
    otherInfo: 'otherInfo',
    requestorName: 'requestorName',
    requestorEmail: 'requestorEmail',
    requestorPhone: 'requestorPhone',
    requestorTitle: 'requestorTitle',
    requestorOrganization: 'requestorOrganization',
    freeFormQuestion: 'freeFormQuestion'
  };

  export type EngagementDraftScalarFieldEnum = (typeof EngagementDraftScalarFieldEnum)[keyof typeof EngagementDraftScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    user?: UserListRelationFilter
    engagement?: EngagementListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    organizationAccess?: OrganizationAccessListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    user?: UserOrderByRelationAggregateInput
    engagement?: EngagementOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationAccess?: OrganizationAccessOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    initials?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput> | null
    organizationId?: StringNullableFilter | string | null
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    roleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    engagement?: EngagementListRelationFilter
    organizationAccess?: OrganizationAccessListRelationFilter
    EngagementDraft?: EngagementDraftListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    initials?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    organizationId?: SortOrder
    role?: RoleOrderByWithRelationInput
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    engagement?: EngagementOrderByRelationAggregateInput
    organizationAccess?: OrganizationAccessOrderByRelationAggregateInput
    EngagementDraft?: EngagementDraftOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    initials?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organizationId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    initials?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    organizationId?: StringNullableWithAggregatesFilter | string | null
    roleId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: number
    type?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
  }

  export type OrganizationAccessWhereInput = {
    AND?: Enumerable<OrganizationAccessWhereInput>
    OR?: Enumerable<OrganizationAccessWhereInput>
    NOT?: Enumerable<OrganizationAccessWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    organizationId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    read?: BoolFilter | boolean
    write?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrganizationAccessOrderByWithRelationInput = {
    organization?: OrganizationOrderByWithRelationInput
    organizationId?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    read?: SortOrder
    write?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAccessWhereUniqueInput = {
    userId_organizationId?: OrganizationAccessUserIdOrganizationIdCompoundUniqueInput
  }

  export type OrganizationAccessOrderByWithAggregationInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    write?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationAccessCountOrderByAggregateInput
    _max?: OrganizationAccessMaxOrderByAggregateInput
    _min?: OrganizationAccessMinOrderByAggregateInput
  }

  export type OrganizationAccessScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrganizationAccessScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrganizationAccessScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrganizationAccessScalarWhereWithAggregatesInput>
    organizationId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    read?: BoolWithAggregatesFilter | boolean
    write?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EngagementWhereInput = {
    AND?: Enumerable<EngagementWhereInput>
    OR?: Enumerable<EngagementWhereInput>
    NOT?: Enumerable<EngagementWhereInput>
    id?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    organizationId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput> | null
    locationId?: StringNullableFilter | string | null
    demographic?: XOR<DemographicRelationFilter, DemographicWhereInput>
    demographicId?: StringFilter | string
    engagementDetail?: XOR<EngagementDetailRelationFilter, EngagementDetailWhereInput>
    engagementDetailId?: StringFilter | string
    status?: StringFilter | string
    crossFunctionalTeam?: XOR<CrossFunctionalTeamsRelationFilter, CrossFunctionalTeamsWhereInput>
    crossFunctionalTeamId?: IntFilter | number
    requestor?: XOR<RequestorInformationRelationFilter, RequestorInformationWhereInput>
    requestorId?: StringFilter | string
    events?: EventListRelationFilter
    dueDates?: DueDateListRelationFilter
    files?: FileListRelationFilter
    shortId?: StringNullableFilter | string | null
    feedbackConfig?: XOR<FeedbackConfigRelationFilter, FeedbackConfigWhereInput> | null
    feedbackConfigId?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    statusChangedOn?: DateTimeNullableFilter | Date | string | null
  }

  export type EngagementOrderByWithRelationInput = {
    id?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    organizationId?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    locationId?: SortOrder
    demographic?: DemographicOrderByWithRelationInput
    demographicId?: SortOrder
    engagementDetail?: EngagementDetailOrderByWithRelationInput
    engagementDetailId?: SortOrder
    status?: SortOrder
    crossFunctionalTeam?: CrossFunctionalTeamsOrderByWithRelationInput
    crossFunctionalTeamId?: SortOrder
    requestor?: RequestorInformationOrderByWithRelationInput
    requestorId?: SortOrder
    events?: EventOrderByRelationAggregateInput
    dueDates?: DueDateOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    shortId?: SortOrder
    feedbackConfig?: FeedbackConfigOrderByWithRelationInput
    feedbackConfigId?: SortOrder
    isDeleted?: SortOrder
    statusChangedOn?: SortOrder
  }

  export type EngagementWhereUniqueInput = {
    id?: string
    locationId?: string
    demographicId?: string
    engagementDetailId?: string
    requestorId?: string
    shortId?: string
    feedbackConfigId?: string
  }

  export type EngagementOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    demographicId?: SortOrder
    engagementDetailId?: SortOrder
    status?: SortOrder
    crossFunctionalTeamId?: SortOrder
    requestorId?: SortOrder
    shortId?: SortOrder
    feedbackConfigId?: SortOrder
    isDeleted?: SortOrder
    statusChangedOn?: SortOrder
    _count?: EngagementCountOrderByAggregateInput
    _avg?: EngagementAvgOrderByAggregateInput
    _max?: EngagementMaxOrderByAggregateInput
    _min?: EngagementMinOrderByAggregateInput
    _sum?: EngagementSumOrderByAggregateInput
  }

  export type EngagementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EngagementScalarWhereWithAggregatesInput>
    OR?: Enumerable<EngagementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EngagementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    locationId?: StringNullableWithAggregatesFilter | string | null
    demographicId?: StringWithAggregatesFilter | string
    engagementDetailId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    crossFunctionalTeamId?: IntWithAggregatesFilter | number
    requestorId?: StringWithAggregatesFilter | string
    shortId?: StringNullableWithAggregatesFilter | string | null
    feedbackConfigId?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    statusChangedOn?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type LocationWhereInput = {
    AND?: Enumerable<LocationWhereInput>
    OR?: Enumerable<LocationWhereInput>
    NOT?: Enumerable<LocationWhereInput>
    id?: StringFilter | string
    addressOne?: StringFilter | string
    addressTwo?: StringNullableFilter | string | null
    city?: StringFilter | string
    state?: StringFilter | string
    zip?: IntFilter | number
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = {
    id?: string
  }

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LocationScalarWhereWithAggregatesInput>
    OR?: Enumerable<LocationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LocationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    addressOne?: StringWithAggregatesFilter | string
    addressTwo?: StringNullableWithAggregatesFilter | string | null
    city?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    zip?: IntWithAggregatesFilter | number
  }

  export type EngagementDetailWhereInput = {
    AND?: Enumerable<EngagementDetailWhereInput>
    OR?: Enumerable<EngagementDetailWhereInput>
    NOT?: Enumerable<EngagementDetailWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    summary?: StringFilter | string
    description?: StringFilter | string
    associatedProgram?: StringFilter | string
    armyImpact?: StringFilter | string
    fundingDetails?: StringNullableFilter | string | null
    otherInformation?: StringNullableFilter | string | null
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
  }

  export type EngagementDetailOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    associatedProgram?: SortOrder
    armyImpact?: SortOrder
    fundingDetails?: SortOrder
    otherInformation?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
  }

  export type EngagementDetailWhereUniqueInput = {
    id?: string
  }

  export type EngagementDetailOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    associatedProgram?: SortOrder
    armyImpact?: SortOrder
    fundingDetails?: SortOrder
    otherInformation?: SortOrder
    _count?: EngagementDetailCountOrderByAggregateInput
    _max?: EngagementDetailMaxOrderByAggregateInput
    _min?: EngagementDetailMinOrderByAggregateInput
  }

  export type EngagementDetailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EngagementDetailScalarWhereWithAggregatesInput>
    OR?: Enumerable<EngagementDetailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EngagementDetailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    summary?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    associatedProgram?: StringWithAggregatesFilter | string
    armyImpact?: StringWithAggregatesFilter | string
    fundingDetails?: StringNullableWithAggregatesFilter | string | null
    otherInformation?: StringNullableWithAggregatesFilter | string | null
  }

  export type CrossFunctionalTeamsWhereInput = {
    AND?: Enumerable<CrossFunctionalTeamsWhereInput>
    OR?: Enumerable<CrossFunctionalTeamsWhereInput>
    NOT?: Enumerable<CrossFunctionalTeamsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    engagements?: EngagementListRelationFilter
  }

  export type CrossFunctionalTeamsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    engagements?: EngagementOrderByRelationAggregateInput
  }

  export type CrossFunctionalTeamsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CrossFunctionalTeamsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrossFunctionalTeamsCountOrderByAggregateInput
    _avg?: CrossFunctionalTeamsAvgOrderByAggregateInput
    _max?: CrossFunctionalTeamsMaxOrderByAggregateInput
    _min?: CrossFunctionalTeamsMinOrderByAggregateInput
    _sum?: CrossFunctionalTeamsSumOrderByAggregateInput
  }

  export type CrossFunctionalTeamsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CrossFunctionalTeamsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CrossFunctionalTeamsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CrossFunctionalTeamsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DemographicWhereInput = {
    AND?: Enumerable<DemographicWhereInput>
    OR?: Enumerable<DemographicWhereInput>
    NOT?: Enumerable<DemographicWhereInput>
    id?: StringFilter | string
    soldierInput?: StringFilter | string
    soldiersNeeded?: IntFilter | number
    mos?: StringFilter | string
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
    requirements?: RequirementListRelationFilter
  }

  export type DemographicOrderByWithRelationInput = {
    id?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    mos?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
    requirements?: RequirementOrderByRelationAggregateInput
  }

  export type DemographicWhereUniqueInput = {
    id?: string
  }

  export type DemographicOrderByWithAggregationInput = {
    id?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    mos?: SortOrder
    _count?: DemographicCountOrderByAggregateInput
    _avg?: DemographicAvgOrderByAggregateInput
    _max?: DemographicMaxOrderByAggregateInput
    _min?: DemographicMinOrderByAggregateInput
    _sum?: DemographicSumOrderByAggregateInput
  }

  export type DemographicScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DemographicScalarWhereWithAggregatesInput>
    OR?: Enumerable<DemographicScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DemographicScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    soldierInput?: StringWithAggregatesFilter | string
    soldiersNeeded?: IntWithAggregatesFilter | number
    mos?: StringWithAggregatesFilter | string
  }

  export type RequirementWhereInput = {
    AND?: Enumerable<RequirementWhereInput>
    OR?: Enumerable<RequirementWhereInput>
    NOT?: Enumerable<RequirementWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    demographics?: DemographicListRelationFilter
  }

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    demographics?: DemographicOrderByRelationAggregateInput
  }

  export type RequirementWhereUniqueInput = {
    id?: string
    content?: string
  }

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    _count?: RequirementCountOrderByAggregateInput
    _max?: RequirementMaxOrderByAggregateInput
    _min?: RequirementMinOrderByAggregateInput
  }

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequirementScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequirementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequirementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
  }

  export type RequestorInformationWhereInput = {
    AND?: Enumerable<RequestorInformationWhereInput>
    OR?: Enumerable<RequestorInformationWhereInput>
    NOT?: Enumerable<RequestorInformationWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    organization?: StringFilter | string
    title?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
  }

  export type RequestorInformationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
  }

  export type RequestorInformationWhereUniqueInput = {
    id?: string
  }

  export type RequestorInformationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    _count?: RequestorInformationCountOrderByAggregateInput
    _max?: RequestorInformationMaxOrderByAggregateInput
    _min?: RequestorInformationMinOrderByAggregateInput
  }

  export type RequestorInformationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestorInformationScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestorInformationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestorInformationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    organization?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    title?: StringFilter | string
    description?: StringFilter | string
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
    engagementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventWhereUniqueInput = {
    id?: string
  }

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    engagementId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DueDateWhereInput = {
    AND?: Enumerable<DueDateWhereInput>
    OR?: Enumerable<DueDateWhereInput>
    NOT?: Enumerable<DueDateWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    dueDate?: DateTimeFilter | Date | string
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
    engagementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DueDateOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDateWhereUniqueInput = {
    id?: string
  }

  export type DueDateOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DueDateCountOrderByAggregateInput
    _max?: DueDateMaxOrderByAggregateInput
    _min?: DueDateMinOrderByAggregateInput
  }

  export type DueDateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DueDateScalarWhereWithAggregatesInput>
    OR?: Enumerable<DueDateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DueDateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    dueDate?: DateTimeWithAggregatesFilter | Date | string
    engagementId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FeedbackConfigWhereInput = {
    AND?: Enumerable<FeedbackConfigWhereInput>
    OR?: Enumerable<FeedbackConfigWhereInput>
    NOT?: Enumerable<FeedbackConfigWhereInput>
    id?: StringFilter | string
    feedbackType?: EnumFeedbackTypesFilter | FeedbackTypes
    isHumanResearch?: BoolFilter | boolean
    hasSubmissions?: BoolFilter | boolean
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
    testFeedbackSubmissions?: TestFeedbackSubmissionListRelationFilter
    inputFeedbackSubmissions?: InputFeedbackSubmissionListRelationFilter
    freeFeedbackSubmissions?: FreeFeedbackSubmissionListRelationFilter
    freeFormQuestion?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FeedbackConfigOrderByWithRelationInput = {
    id?: SortOrder
    feedbackType?: SortOrder
    isHumanResearch?: SortOrder
    hasSubmissions?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
    testFeedbackSubmissions?: TestFeedbackSubmissionOrderByRelationAggregateInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionOrderByRelationAggregateInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionOrderByRelationAggregateInput
    freeFormQuestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackConfigWhereUniqueInput = {
    id?: string
  }

  export type FeedbackConfigOrderByWithAggregationInput = {
    id?: SortOrder
    feedbackType?: SortOrder
    isHumanResearch?: SortOrder
    hasSubmissions?: SortOrder
    freeFormQuestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedbackConfigCountOrderByAggregateInput
    _max?: FeedbackConfigMaxOrderByAggregateInput
    _min?: FeedbackConfigMinOrderByAggregateInput
  }

  export type FeedbackConfigScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeedbackConfigScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeedbackConfigScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeedbackConfigScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    feedbackType?: EnumFeedbackTypesWithAggregatesFilter | FeedbackTypes
    isHumanResearch?: BoolWithAggregatesFilter | boolean
    hasSubmissions?: BoolWithAggregatesFilter | boolean
    freeFormQuestion?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TestFeedbackSubmissionWhereInput = {
    AND?: Enumerable<TestFeedbackSubmissionWhereInput>
    OR?: Enumerable<TestFeedbackSubmissionWhereInput>
    NOT?: Enumerable<TestFeedbackSubmissionWhereInput>
    id?: StringFilter | string
    feedbackConfig?: XOR<FeedbackConfigRelationFilter, FeedbackConfigWhereInput> | null
    feedbackConfigId?: StringFilter | string
    rating?: StringFilter | string
    testFeedbackResponses?: XOR<TestFeedbackResponsesRelationFilter, TestFeedbackResponsesWhereInput>
    testFeedbackResponseId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TestFeedbackSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    feedbackConfig?: FeedbackConfigOrderByWithRelationInput
    feedbackConfigId?: SortOrder
    rating?: SortOrder
    testFeedbackResponses?: TestFeedbackResponsesOrderByWithRelationInput
    testFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackSubmissionWhereUniqueInput = {
    id?: string
    testFeedbackResponseId?: string
  }

  export type TestFeedbackSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    rating?: SortOrder
    testFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestFeedbackSubmissionCountOrderByAggregateInput
    _max?: TestFeedbackSubmissionMaxOrderByAggregateInput
    _min?: TestFeedbackSubmissionMinOrderByAggregateInput
  }

  export type TestFeedbackSubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TestFeedbackSubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TestFeedbackSubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TestFeedbackSubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    feedbackConfigId?: StringWithAggregatesFilter | string
    rating?: StringWithAggregatesFilter | string
    testFeedbackResponseId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TestFeedbackResponsesWhereInput = {
    AND?: Enumerable<TestFeedbackResponsesWhereInput>
    OR?: Enumerable<TestFeedbackResponsesWhereInput>
    NOT?: Enumerable<TestFeedbackResponsesWhereInput>
    id?: StringFilter | string
    testFeedback?: XOR<TestFeedbackSubmissionRelationFilter, TestFeedbackSubmissionWhereInput> | null
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    customResponse?: StringNullableFilter | string | null
    results?: StringFilter | string
    anticipatedResults?: StringFilter | string
    conditionsConstraints?: StringFilter | string
    metExpectations?: StringFilter | string
    notMetExpectations?: StringFilter | string
    otherOpportunities?: StringFilter | string
    additionalThoughts?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TestFeedbackResponsesOrderByWithRelationInput = {
    id?: SortOrder
    testFeedback?: TestFeedbackSubmissionOrderByWithRelationInput
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    results?: SortOrder
    anticipatedResults?: SortOrder
    conditionsConstraints?: SortOrder
    metExpectations?: SortOrder
    notMetExpectations?: SortOrder
    otherOpportunities?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackResponsesWhereUniqueInput = {
    id?: string
  }

  export type TestFeedbackResponsesOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    results?: SortOrder
    anticipatedResults?: SortOrder
    conditionsConstraints?: SortOrder
    metExpectations?: SortOrder
    notMetExpectations?: SortOrder
    otherOpportunities?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestFeedbackResponsesCountOrderByAggregateInput
    _max?: TestFeedbackResponsesMaxOrderByAggregateInput
    _min?: TestFeedbackResponsesMinOrderByAggregateInput
  }

  export type TestFeedbackResponsesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TestFeedbackResponsesScalarWhereWithAggregatesInput>
    OR?: Enumerable<TestFeedbackResponsesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TestFeedbackResponsesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    customResponse?: StringNullableWithAggregatesFilter | string | null
    results?: StringWithAggregatesFilter | string
    anticipatedResults?: StringWithAggregatesFilter | string
    conditionsConstraints?: StringWithAggregatesFilter | string
    metExpectations?: StringWithAggregatesFilter | string
    notMetExpectations?: StringWithAggregatesFilter | string
    otherOpportunities?: StringWithAggregatesFilter | string
    additionalThoughts?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InputFeedbackSubmissionWhereInput = {
    AND?: Enumerable<InputFeedbackSubmissionWhereInput>
    OR?: Enumerable<InputFeedbackSubmissionWhereInput>
    NOT?: Enumerable<InputFeedbackSubmissionWhereInput>
    id?: StringFilter | string
    feedbackConfig?: XOR<FeedbackConfigRelationFilter, FeedbackConfigWhereInput> | null
    feedbackConfigId?: StringFilter | string
    inputFeedbackResponses?: XOR<InputFeedbackResponsesRelationFilter, InputFeedbackResponsesWhereInput>
    inputFeedbackResponseId?: StringFilter | string
    rating?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InputFeedbackSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    feedbackConfig?: FeedbackConfigOrderByWithRelationInput
    feedbackConfigId?: SortOrder
    inputFeedbackResponses?: InputFeedbackResponsesOrderByWithRelationInput
    inputFeedbackResponseId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackSubmissionWhereUniqueInput = {
    id?: string
    inputFeedbackResponseId?: string
  }

  export type InputFeedbackSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    inputFeedbackResponseId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InputFeedbackSubmissionCountOrderByAggregateInput
    _max?: InputFeedbackSubmissionMaxOrderByAggregateInput
    _min?: InputFeedbackSubmissionMinOrderByAggregateInput
  }

  export type InputFeedbackSubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InputFeedbackSubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<InputFeedbackSubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InputFeedbackSubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    feedbackConfigId?: StringWithAggregatesFilter | string
    inputFeedbackResponseId?: StringWithAggregatesFilter | string
    rating?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InputFeedbackResponsesWhereInput = {
    AND?: Enumerable<InputFeedbackResponsesWhereInput>
    OR?: Enumerable<InputFeedbackResponsesWhereInput>
    NOT?: Enumerable<InputFeedbackResponsesWhereInput>
    id?: StringFilter | string
    inputFeedback?: XOR<InputFeedbackSubmissionRelationFilter, InputFeedbackSubmissionWhereInput> | null
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    customResponse?: StringNullableFilter | string | null
    opportunities?: StringFilter | string
    processSolution?: StringFilter | string
    notAsked?: StringFilter | string
    responseViews?: StringFilter | string
    additionalThoughts?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InputFeedbackResponsesOrderByWithRelationInput = {
    id?: SortOrder
    inputFeedback?: InputFeedbackSubmissionOrderByWithRelationInput
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    opportunities?: SortOrder
    processSolution?: SortOrder
    notAsked?: SortOrder
    responseViews?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackResponsesWhereUniqueInput = {
    id?: string
  }

  export type InputFeedbackResponsesOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    opportunities?: SortOrder
    processSolution?: SortOrder
    notAsked?: SortOrder
    responseViews?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InputFeedbackResponsesCountOrderByAggregateInput
    _max?: InputFeedbackResponsesMaxOrderByAggregateInput
    _min?: InputFeedbackResponsesMinOrderByAggregateInput
  }

  export type InputFeedbackResponsesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InputFeedbackResponsesScalarWhereWithAggregatesInput>
    OR?: Enumerable<InputFeedbackResponsesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InputFeedbackResponsesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    customResponse?: StringNullableWithAggregatesFilter | string | null
    opportunities?: StringWithAggregatesFilter | string
    processSolution?: StringWithAggregatesFilter | string
    notAsked?: StringWithAggregatesFilter | string
    responseViews?: StringWithAggregatesFilter | string
    additionalThoughts?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FreeFeedbackSubmissionWhereInput = {
    AND?: Enumerable<FreeFeedbackSubmissionWhereInput>
    OR?: Enumerable<FreeFeedbackSubmissionWhereInput>
    NOT?: Enumerable<FreeFeedbackSubmissionWhereInput>
    id?: StringFilter | string
    feedbackConfig?: XOR<FeedbackConfigRelationFilter, FeedbackConfigWhereInput> | null
    feedbackConfigId?: StringFilter | string
    freeFeedbackResponses?: XOR<FreeFeedbackResponsesRelationFilter, FreeFeedbackResponsesWhereInput>
    freeFeedbackResponseId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    rating?: StringFilter | string
  }

  export type FreeFeedbackSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    feedbackConfig?: FeedbackConfigOrderByWithRelationInput
    feedbackConfigId?: SortOrder
    freeFeedbackResponses?: FreeFeedbackResponsesOrderByWithRelationInput
    freeFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type FreeFeedbackSubmissionWhereUniqueInput = {
    id?: string
    freeFeedbackResponseId?: string
  }

  export type FreeFeedbackSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    freeFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
    _count?: FreeFeedbackSubmissionCountOrderByAggregateInput
    _max?: FreeFeedbackSubmissionMaxOrderByAggregateInput
    _min?: FreeFeedbackSubmissionMinOrderByAggregateInput
  }

  export type FreeFeedbackSubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FreeFeedbackSubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<FreeFeedbackSubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FreeFeedbackSubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    feedbackConfigId?: StringWithAggregatesFilter | string
    freeFeedbackResponseId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    rating?: StringWithAggregatesFilter | string
  }

  export type FreeFeedbackResponsesWhereInput = {
    AND?: Enumerable<FreeFeedbackResponsesWhereInput>
    OR?: Enumerable<FreeFeedbackResponsesWhereInput>
    NOT?: Enumerable<FreeFeedbackResponsesWhereInput>
    id?: StringFilter | string
    freeFeedback?: XOR<FreeFeedbackSubmissionRelationFilter, FreeFeedbackSubmissionWhereInput> | null
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    response?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FreeFeedbackResponsesOrderByWithRelationInput = {
    id?: SortOrder
    freeFeedback?: FreeFeedbackSubmissionOrderByWithRelationInput
    startDate?: SortOrder
    endDate?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeFeedbackResponsesWhereUniqueInput = {
    id?: string
  }

  export type FreeFeedbackResponsesOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreeFeedbackResponsesCountOrderByAggregateInput
    _max?: FreeFeedbackResponsesMaxOrderByAggregateInput
    _min?: FreeFeedbackResponsesMinOrderByAggregateInput
  }

  export type FreeFeedbackResponsesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FreeFeedbackResponsesScalarWhereWithAggregatesInput>
    OR?: Enumerable<FreeFeedbackResponsesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FreeFeedbackResponsesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    response?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FileWhereInput = {
    AND?: Enumerable<FileWhereInput>
    OR?: Enumerable<FileWhereInput>
    NOT?: Enumerable<FileWhereInput>
    id?: StringFilter | string
    engagement?: XOR<EngagementRelationFilter, EngagementWhereInput> | null
    engagementId?: StringNullableFilter | string | null
    engagementDraft?: XOR<EngagementDraftRelationFilter, EngagementDraftWhereInput> | null
    engagementDraftId?: StringNullableFilter | string | null
    blobName?: StringFilter | string
    containerName?: StringFilter | string
    path?: StringFilter | string
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    engagement?: EngagementOrderByWithRelationInput
    engagementId?: SortOrder
    engagementDraft?: EngagementDraftOrderByWithRelationInput
    engagementDraftId?: SortOrder
    blobName?: SortOrder
    containerName?: SortOrder
    path?: SortOrder
  }

  export type FileWhereUniqueInput = {
    id?: string
  }

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    engagementId?: SortOrder
    engagementDraftId?: SortOrder
    blobName?: SortOrder
    containerName?: SortOrder
    path?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FileScalarWhereWithAggregatesInput>
    OR?: Enumerable<FileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    engagementId?: StringNullableWithAggregatesFilter | string | null
    engagementDraftId?: StringNullableWithAggregatesFilter | string | null
    blobName?: StringWithAggregatesFilter | string
    containerName?: StringWithAggregatesFilter | string
    path?: StringWithAggregatesFilter | string
  }

  export type EngagementDraftWhereInput = {
    AND?: Enumerable<EngagementDraftWhereInput>
    OR?: Enumerable<EngagementDraftWhereInput>
    NOT?: Enumerable<EngagementDraftWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    engagementTitle?: StringNullableFilter | string | null
    engagementSummary?: StringNullableFilter | string | null
    associatedProgram?: StringNullableFilter | string | null
    soldierInput?: StringNullableFilter | string | null
    soldiersNeeded?: StringNullableFilter | string | null
    preferredDivision?: StringNullableFilter | string | null
    mos?: StringNullableFilter | string | null
    requirements?: StringNullableListFilter
    armyImpact?: StringNullableFilter | string | null
    cft?: IntNullableFilter | number | null
    engagementRequest?: StringNullableFilter | string | null
    feedbackType?: StringNullableFilter | string | null
    files?: FileListRelationFilter
    eventStartDate?: DateTimeNullableFilter | Date | string | null
    eventEndDate?: DateTimeNullableFilter | Date | string | null
    eventTitle?: StringNullableFilter | string | null
    eventDescription?: StringNullableFilter | string | null
    dueDate?: DateTimeNullableFilter | Date | string | null
    dueDateTitle?: StringNullableFilter | string | null
    addressOne?: StringNullableFilter | string | null
    addressTwo?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    zip?: StringNullableFilter | string | null
    funding?: StringNullableFilter | string | null
    otherInfo?: StringNullableFilter | string | null
    requestorName?: StringNullableFilter | string | null
    requestorEmail?: StringNullableFilter | string | null
    requestorPhone?: StringNullableFilter | string | null
    requestorTitle?: StringNullableFilter | string | null
    requestorOrganization?: StringNullableFilter | string | null
    freeFormQuestion?: StringNullableFilter | string | null
  }

  export type EngagementDraftOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    engagementTitle?: SortOrder
    engagementSummary?: SortOrder
    associatedProgram?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    preferredDivision?: SortOrder
    mos?: SortOrder
    requirements?: SortOrder
    armyImpact?: SortOrder
    cft?: SortOrder
    engagementRequest?: SortOrder
    feedbackType?: SortOrder
    files?: FileOrderByRelationAggregateInput
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    dueDate?: SortOrder
    dueDateTitle?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    funding?: SortOrder
    otherInfo?: SortOrder
    requestorName?: SortOrder
    requestorEmail?: SortOrder
    requestorPhone?: SortOrder
    requestorTitle?: SortOrder
    requestorOrganization?: SortOrder
    freeFormQuestion?: SortOrder
  }

  export type EngagementDraftWhereUniqueInput = {
    id?: string
  }

  export type EngagementDraftOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    engagementTitle?: SortOrder
    engagementSummary?: SortOrder
    associatedProgram?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    preferredDivision?: SortOrder
    mos?: SortOrder
    requirements?: SortOrder
    armyImpact?: SortOrder
    cft?: SortOrder
    engagementRequest?: SortOrder
    feedbackType?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    dueDate?: SortOrder
    dueDateTitle?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    funding?: SortOrder
    otherInfo?: SortOrder
    requestorName?: SortOrder
    requestorEmail?: SortOrder
    requestorPhone?: SortOrder
    requestorTitle?: SortOrder
    requestorOrganization?: SortOrder
    freeFormQuestion?: SortOrder
    _count?: EngagementDraftCountOrderByAggregateInput
    _avg?: EngagementDraftAvgOrderByAggregateInput
    _max?: EngagementDraftMaxOrderByAggregateInput
    _min?: EngagementDraftMinOrderByAggregateInput
    _sum?: EngagementDraftSumOrderByAggregateInput
  }

  export type EngagementDraftScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EngagementDraftScalarWhereWithAggregatesInput>
    OR?: Enumerable<EngagementDraftScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EngagementDraftScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    engagementTitle?: StringNullableWithAggregatesFilter | string | null
    engagementSummary?: StringNullableWithAggregatesFilter | string | null
    associatedProgram?: StringNullableWithAggregatesFilter | string | null
    soldierInput?: StringNullableWithAggregatesFilter | string | null
    soldiersNeeded?: StringNullableWithAggregatesFilter | string | null
    preferredDivision?: StringNullableWithAggregatesFilter | string | null
    mos?: StringNullableWithAggregatesFilter | string | null
    requirements?: StringNullableListFilter
    armyImpact?: StringNullableWithAggregatesFilter | string | null
    cft?: IntNullableWithAggregatesFilter | number | null
    engagementRequest?: StringNullableWithAggregatesFilter | string | null
    feedbackType?: StringNullableWithAggregatesFilter | string | null
    eventStartDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    eventEndDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    eventTitle?: StringNullableWithAggregatesFilter | string | null
    eventDescription?: StringNullableWithAggregatesFilter | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dueDateTitle?: StringNullableWithAggregatesFilter | string | null
    addressOne?: StringNullableWithAggregatesFilter | string | null
    addressTwo?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    zip?: StringNullableWithAggregatesFilter | string | null
    funding?: StringNullableWithAggregatesFilter | string | null
    otherInfo?: StringNullableWithAggregatesFilter | string | null
    requestorName?: StringNullableWithAggregatesFilter | string | null
    requestorEmail?: StringNullableWithAggregatesFilter | string | null
    requestorPhone?: StringNullableWithAggregatesFilter | string | null
    requestorTitle?: StringNullableWithAggregatesFilter | string | null
    requestorOrganization?: StringNullableWithAggregatesFilter | string | null
    freeFormQuestion?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    user?: UserCreateNestedManyWithoutOrganizationInput
    engagement?: EngagementCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    engagement?: EngagementUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutOrganizationInput
    engagement?: EngagementUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUpdateManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutOrganizationInput
    engagement?: EngagementUncheckedUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutOrganizationInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organization?: OrganizationCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementUncheckedCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneWithoutUserInput
    role?: RoleUpdateOneRequiredWithoutUsersInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUncheckedUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    type: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    type: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleInput
  }

  export type RoleCreateManyInput = {
    id?: number
    type: string
  }

  export type RoleUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationAccessCreateInput = {
    organization: OrganizationCreateNestedOneWithoutOrganizationAccessInput
    user: UserCreateNestedOneWithoutOrganizationAccessInput
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessUncheckedCreateInput = {
    organizationId: string
    userId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessUpdateInput = {
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationAccessInput
    user?: UserUpdateOneRequiredWithoutOrganizationAccessInput
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessCreateManyInput = {
    organizationId: string
    userId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessUpdateManyMutationInput = {
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementCreateInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocationCreateInput = {
    id?: string
    addressOne: string
    addressTwo?: string | null
    city: string
    state: string
    zip: number
    engagement?: EngagementCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    addressOne: string
    addressTwo?: string | null
    city: string
    state: string
    zip: number
    engagement?: EngagementUncheckedCreateNestedOneWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
    engagement?: EngagementUpdateOneWithoutLocationInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
    engagement?: EngagementUncheckedUpdateOneWithoutLocationInput
  }

  export type LocationCreateManyInput = {
    id?: string
    addressOne: string
    addressTwo?: string | null
    city: string
    state: string
    zip: number
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type EngagementDetailCreateInput = {
    id?: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails?: string | null
    otherInformation?: string | null
    engagement?: EngagementCreateNestedOneWithoutEngagementDetailInput
  }

  export type EngagementDetailUncheckedCreateInput = {
    id?: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails?: string | null
    otherInformation?: string | null
    engagement?: EngagementUncheckedCreateNestedOneWithoutEngagementDetailInput
  }

  export type EngagementDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: EngagementUpdateOneWithoutEngagementDetailInput
  }

  export type EngagementDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: EngagementUncheckedUpdateOneWithoutEngagementDetailInput
  }

  export type EngagementDetailCreateManyInput = {
    id?: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails?: string | null
    otherInformation?: string | null
  }

  export type EngagementDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrossFunctionalTeamsCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementCreateNestedManyWithoutCrossFunctionalTeamInput
  }

  export type CrossFunctionalTeamsUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    engagements?: EngagementUncheckedCreateNestedManyWithoutCrossFunctionalTeamInput
  }

  export type CrossFunctionalTeamsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUpdateManyWithoutCrossFunctionalTeamInput
  }

  export type CrossFunctionalTeamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagements?: EngagementUncheckedUpdateManyWithoutCrossFunctionalTeamInput
  }

  export type CrossFunctionalTeamsCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrossFunctionalTeamsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrossFunctionalTeamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DemographicCreateInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    engagement?: EngagementCreateNestedOneWithoutDemographicInput
    requirements?: RequirementCreateNestedManyWithoutDemographicsInput
  }

  export type DemographicUncheckedCreateInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    engagement?: EngagementUncheckedCreateNestedOneWithoutDemographicInput
    requirements?: RequirementUncheckedCreateNestedManyWithoutDemographicsInput
  }

  export type DemographicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutDemographicInput
    requirements?: RequirementUpdateManyWithoutDemographicsInput
  }

  export type DemographicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUncheckedUpdateOneWithoutDemographicInput
    requirements?: RequirementUncheckedUpdateManyWithoutDemographicsInput
  }

  export type DemographicCreateManyInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
  }

  export type DemographicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
  }

  export type DemographicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
  }

  export type RequirementCreateInput = {
    id?: string
    content: string
    demographics?: DemographicCreateNestedManyWithoutRequirementsInput
  }

  export type RequirementUncheckedCreateInput = {
    id?: string
    content: string
    demographics?: DemographicUncheckedCreateNestedManyWithoutRequirementsInput
  }

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    demographics?: DemographicUpdateManyWithoutRequirementsInput
  }

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    demographics?: DemographicUncheckedUpdateManyWithoutRequirementsInput
  }

  export type RequirementCreateManyInput = {
    id?: string
    content: string
  }

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RequestorInformationCreateInput = {
    id?: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
    engagement?: EngagementCreateNestedOneWithoutRequestorInput
  }

  export type RequestorInformationUncheckedCreateInput = {
    id?: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
    engagement?: EngagementUncheckedCreateNestedOneWithoutRequestorInput
  }

  export type RequestorInformationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutRequestorInput
  }

  export type RequestorInformationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUncheckedUpdateOneWithoutRequestorInput
  }

  export type RequestorInformationCreateManyInput = {
    id?: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
  }

  export type RequestorInformationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type RequestorInformationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    engagement?: EngagementCreateNestedOneWithoutEventsInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    engagementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutEventsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    engagementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    engagementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateCreateInput = {
    id?: string
    title: string
    dueDate: Date | string
    engagement?: EngagementCreateNestedOneWithoutDueDatesInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateUncheckedCreateInput = {
    id?: string
    title: string
    dueDate: Date | string
    engagementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateOneWithoutDueDatesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateCreateManyInput = {
    id?: string
    title: string
    dueDate: Date | string
    engagementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigCreateInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUncheckedCreateInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementUncheckedCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUncheckedUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigCreateManyInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionCreateInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutTestFeedbackSubmissionsInput
    rating: string
    testFeedbackResponses: TestFeedbackResponsesCreateNestedOneWithoutTestFeedbackInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionUncheckedCreateInput = {
    id?: string
    feedbackConfigId: string
    rating: string
    testFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutTestFeedbackSubmissionsInput
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponses?: TestFeedbackResponsesUpdateOneRequiredWithoutTestFeedbackInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionCreateManyInput = {
    id?: string
    feedbackConfigId: string
    rating: string
    testFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesCreateInput = {
    id?: string
    testFeedback?: TestFeedbackSubmissionCreateNestedOneWithoutTestFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackResponsesUncheckedCreateInput = {
    id?: string
    testFeedback?: TestFeedbackSubmissionUncheckedCreateNestedOneWithoutTestFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackResponsesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testFeedback?: TestFeedbackSubmissionUpdateOneWithoutTestFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testFeedback?: TestFeedbackSubmissionUncheckedUpdateOneWithoutTestFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackResponsesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionCreateInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutInputFeedbackSubmissionsInput
    inputFeedbackResponses: InputFeedbackResponsesCreateNestedOneWithoutInputFeedbackInput
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionUncheckedCreateInput = {
    id?: string
    feedbackConfigId: string
    inputFeedbackResponseId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutInputFeedbackSubmissionsInput
    inputFeedbackResponses?: InputFeedbackResponsesUpdateOneRequiredWithoutInputFeedbackInput
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    inputFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionCreateManyInput = {
    id?: string
    feedbackConfigId: string
    inputFeedbackResponseId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    inputFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesCreateInput = {
    id?: string
    inputFeedback?: InputFeedbackSubmissionCreateNestedOneWithoutInputFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackResponsesUncheckedCreateInput = {
    id?: string
    inputFeedback?: InputFeedbackSubmissionUncheckedCreateNestedOneWithoutInputFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackResponsesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputFeedback?: InputFeedbackSubmissionUpdateOneWithoutInputFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputFeedback?: InputFeedbackSubmissionUncheckedUpdateOneWithoutInputFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackResponsesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackSubmissionCreateInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutFreeFeedbackSubmissionsInput
    freeFeedbackResponses: FreeFeedbackResponsesCreateNestedOneWithoutFreeFeedbackInput
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionUncheckedCreateInput = {
    id?: string
    feedbackConfigId: string
    freeFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutFreeFeedbackSubmissionsInput
    freeFeedbackResponses?: FreeFeedbackResponsesUpdateOneRequiredWithoutFreeFeedbackInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    freeFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionCreateManyInput = {
    id?: string
    feedbackConfigId: string
    freeFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    freeFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackResponsesCreateInput = {
    id?: string
    freeFeedback?: FreeFeedbackSubmissionCreateNestedOneWithoutFreeFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackResponsesUncheckedCreateInput = {
    id?: string
    freeFeedback?: FreeFeedbackSubmissionUncheckedCreateNestedOneWithoutFreeFeedbackResponsesInput
    startDate: Date | string
    endDate?: Date | string | null
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackResponsesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    freeFeedback?: FreeFeedbackSubmissionUpdateOneWithoutFreeFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackResponsesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    freeFeedback?: FreeFeedbackSubmissionUncheckedUpdateOneWithoutFreeFeedbackResponsesInput
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackResponsesCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackResponsesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackResponsesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    engagement?: EngagementCreateNestedOneWithoutFilesInput
    engagementDraft?: EngagementDraftCreateNestedOneWithoutFilesInput
    blobName: string
    containerName: string
    path: string
  }

  export type FileUncheckedCreateInput = {
    id?: string
    engagementId?: string | null
    engagementDraftId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutFilesInput
    engagementDraft?: EngagementDraftUpdateOneWithoutFilesInput
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: NullableStringFieldUpdateOperationsInput | string | null
    engagementDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManyInput = {
    id?: string
    engagementId?: string | null
    engagementDraftId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: NullableStringFieldUpdateOperationsInput | string | null
    engagementDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type EngagementDraftCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutEngagementDraftInput
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    files?: FileCreateNestedManyWithoutEngagementDraftInput
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftUncheckedCreateInput = {
    id?: string
    userId: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    files?: FileUncheckedCreateNestedManyWithoutEngagementDraftInput
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEngagementDraftInput
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutEngagementDraftInput
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutEngagementDraftInput
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftCreateManyInput = {
    id?: string
    userId: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type EngagementListRelationFilter = {
    every?: EngagementWhereInput
    some?: EngagementWhereInput
    none?: EngagementWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type OrganizationAccessListRelationFilter = {
    every?: OrganizationAccessWhereInput
    some?: OrganizationAccessWhereInput
    none?: OrganizationAccessWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EngagementDraftListRelationFilter = {
    every?: EngagementDraftWhereInput
    some?: EngagementDraftWhereInput
    none?: EngagementDraftWhereInput
  }

  export type EngagementDraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    initials?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organizationId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    initials?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organizationId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    initials?: SortOrder
    email?: SortOrder
    password?: SortOrder
    organizationId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type OrganizationAccessUserIdOrganizationIdCompoundUniqueInput = {
    userId: string
    organizationId: string
  }

  export type OrganizationAccessCountOrderByAggregateInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    write?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAccessMaxOrderByAggregateInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    write?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAccessMinOrderByAggregateInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    read?: SortOrder
    write?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type DemographicRelationFilter = {
    is?: DemographicWhereInput
    isNot?: DemographicWhereInput
  }

  export type EngagementDetailRelationFilter = {
    is?: EngagementDetailWhereInput
    isNot?: EngagementDetailWhereInput
  }

  export type CrossFunctionalTeamsRelationFilter = {
    is?: CrossFunctionalTeamsWhereInput
    isNot?: CrossFunctionalTeamsWhereInput
  }

  export type RequestorInformationRelationFilter = {
    is?: RequestorInformationWhereInput
    isNot?: RequestorInformationWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type DueDateListRelationFilter = {
    every?: DueDateWhereInput
    some?: DueDateWhereInput
    none?: DueDateWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FeedbackConfigRelationFilter = {
    is?: FeedbackConfigWhereInput | null
    isNot?: FeedbackConfigWhereInput | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DueDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    demographicId?: SortOrder
    engagementDetailId?: SortOrder
    status?: SortOrder
    crossFunctionalTeamId?: SortOrder
    requestorId?: SortOrder
    shortId?: SortOrder
    feedbackConfigId?: SortOrder
    isDeleted?: SortOrder
    statusChangedOn?: SortOrder
  }

  export type EngagementAvgOrderByAggregateInput = {
    crossFunctionalTeamId?: SortOrder
  }

  export type EngagementMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    demographicId?: SortOrder
    engagementDetailId?: SortOrder
    status?: SortOrder
    crossFunctionalTeamId?: SortOrder
    requestorId?: SortOrder
    shortId?: SortOrder
    feedbackConfigId?: SortOrder
    isDeleted?: SortOrder
    statusChangedOn?: SortOrder
  }

  export type EngagementMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locationId?: SortOrder
    demographicId?: SortOrder
    engagementDetailId?: SortOrder
    status?: SortOrder
    crossFunctionalTeamId?: SortOrder
    requestorId?: SortOrder
    shortId?: SortOrder
    feedbackConfigId?: SortOrder
    isDeleted?: SortOrder
    statusChangedOn?: SortOrder
  }

  export type EngagementSumOrderByAggregateInput = {
    crossFunctionalTeamId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EngagementRelationFilter = {
    is?: EngagementWhereInput | null
    isNot?: EngagementWhereInput | null
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    zip?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    zip?: SortOrder
  }

  export type EngagementDetailCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    associatedProgram?: SortOrder
    armyImpact?: SortOrder
    fundingDetails?: SortOrder
    otherInformation?: SortOrder
  }

  export type EngagementDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    associatedProgram?: SortOrder
    armyImpact?: SortOrder
    fundingDetails?: SortOrder
    otherInformation?: SortOrder
  }

  export type EngagementDetailMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    description?: SortOrder
    associatedProgram?: SortOrder
    armyImpact?: SortOrder
    fundingDetails?: SortOrder
    otherInformation?: SortOrder
  }

  export type CrossFunctionalTeamsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrossFunctionalTeamsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CrossFunctionalTeamsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrossFunctionalTeamsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrossFunctionalTeamsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput
    some?: RequirementWhereInput
    none?: RequirementWhereInput
  }

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DemographicCountOrderByAggregateInput = {
    id?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    mos?: SortOrder
  }

  export type DemographicAvgOrderByAggregateInput = {
    soldiersNeeded?: SortOrder
  }

  export type DemographicMaxOrderByAggregateInput = {
    id?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    mos?: SortOrder
  }

  export type DemographicMinOrderByAggregateInput = {
    id?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    mos?: SortOrder
  }

  export type DemographicSumOrderByAggregateInput = {
    soldiersNeeded?: SortOrder
  }

  export type DemographicListRelationFilter = {
    every?: DemographicWhereInput
    some?: DemographicWhereInput
    none?: DemographicWhereInput
  }

  export type DemographicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
  }

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
  }

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
  }

  export type RequestorInformationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type RequestorInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type RequestorInformationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organization?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDateCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDateMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DueDateMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    dueDate?: SortOrder
    engagementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFeedbackTypesFilter = {
    equals?: FeedbackTypes
    in?: Enumerable<FeedbackTypes>
    notIn?: Enumerable<FeedbackTypes>
    not?: NestedEnumFeedbackTypesFilter | FeedbackTypes
  }

  export type TestFeedbackSubmissionListRelationFilter = {
    every?: TestFeedbackSubmissionWhereInput
    some?: TestFeedbackSubmissionWhereInput
    none?: TestFeedbackSubmissionWhereInput
  }

  export type InputFeedbackSubmissionListRelationFilter = {
    every?: InputFeedbackSubmissionWhereInput
    some?: InputFeedbackSubmissionWhereInput
    none?: InputFeedbackSubmissionWhereInput
  }

  export type FreeFeedbackSubmissionListRelationFilter = {
    every?: FreeFeedbackSubmissionWhereInput
    some?: FreeFeedbackSubmissionWhereInput
    none?: FreeFeedbackSubmissionWhereInput
  }

  export type TestFeedbackSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InputFeedbackSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreeFeedbackSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackConfigCountOrderByAggregateInput = {
    id?: SortOrder
    feedbackType?: SortOrder
    isHumanResearch?: SortOrder
    hasSubmissions?: SortOrder
    freeFormQuestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    feedbackType?: SortOrder
    isHumanResearch?: SortOrder
    hasSubmissions?: SortOrder
    freeFormQuestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackConfigMinOrderByAggregateInput = {
    id?: SortOrder
    feedbackType?: SortOrder
    isHumanResearch?: SortOrder
    hasSubmissions?: SortOrder
    freeFormQuestion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFeedbackTypesWithAggregatesFilter = {
    equals?: FeedbackTypes
    in?: Enumerable<FeedbackTypes>
    notIn?: Enumerable<FeedbackTypes>
    not?: NestedEnumFeedbackTypesWithAggregatesFilter | FeedbackTypes
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackTypesFilter
    _max?: NestedEnumFeedbackTypesFilter
  }

  export type TestFeedbackResponsesRelationFilter = {
    is?: TestFeedbackResponsesWhereInput
    isNot?: TestFeedbackResponsesWhereInput
  }

  export type TestFeedbackSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    rating?: SortOrder
    testFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    rating?: SortOrder
    testFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    rating?: SortOrder
    testFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackSubmissionRelationFilter = {
    is?: TestFeedbackSubmissionWhereInput | null
    isNot?: TestFeedbackSubmissionWhereInput | null
  }

  export type TestFeedbackResponsesCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    results?: SortOrder
    anticipatedResults?: SortOrder
    conditionsConstraints?: SortOrder
    metExpectations?: SortOrder
    notMetExpectations?: SortOrder
    otherOpportunities?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackResponsesMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    results?: SortOrder
    anticipatedResults?: SortOrder
    conditionsConstraints?: SortOrder
    metExpectations?: SortOrder
    notMetExpectations?: SortOrder
    otherOpportunities?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestFeedbackResponsesMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    results?: SortOrder
    anticipatedResults?: SortOrder
    conditionsConstraints?: SortOrder
    metExpectations?: SortOrder
    notMetExpectations?: SortOrder
    otherOpportunities?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackResponsesRelationFilter = {
    is?: InputFeedbackResponsesWhereInput
    isNot?: InputFeedbackResponsesWhereInput
  }

  export type InputFeedbackSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    inputFeedbackResponseId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    inputFeedbackResponseId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    inputFeedbackResponseId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackSubmissionRelationFilter = {
    is?: InputFeedbackSubmissionWhereInput | null
    isNot?: InputFeedbackSubmissionWhereInput | null
  }

  export type InputFeedbackResponsesCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    opportunities?: SortOrder
    processSolution?: SortOrder
    notAsked?: SortOrder
    responseViews?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackResponsesMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    opportunities?: SortOrder
    processSolution?: SortOrder
    notAsked?: SortOrder
    responseViews?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InputFeedbackResponsesMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customResponse?: SortOrder
    opportunities?: SortOrder
    processSolution?: SortOrder
    notAsked?: SortOrder
    responseViews?: SortOrder
    additionalThoughts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeFeedbackResponsesRelationFilter = {
    is?: FreeFeedbackResponsesWhereInput
    isNot?: FreeFeedbackResponsesWhereInput
  }

  export type FreeFeedbackSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    freeFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type FreeFeedbackSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    freeFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type FreeFeedbackSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    feedbackConfigId?: SortOrder
    freeFeedbackResponseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type FreeFeedbackSubmissionRelationFilter = {
    is?: FreeFeedbackSubmissionWhereInput | null
    isNot?: FreeFeedbackSubmissionWhereInput | null
  }

  export type FreeFeedbackResponsesCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeFeedbackResponsesMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreeFeedbackResponsesMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EngagementDraftRelationFilter = {
    is?: EngagementDraftWhereInput | null
    isNot?: EngagementDraftWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    engagementDraftId?: SortOrder
    blobName?: SortOrder
    containerName?: SortOrder
    path?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    engagementDraftId?: SortOrder
    blobName?: SortOrder
    containerName?: SortOrder
    path?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    engagementId?: SortOrder
    engagementDraftId?: SortOrder
    blobName?: SortOrder
    containerName?: SortOrder
    path?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type EngagementDraftCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    engagementTitle?: SortOrder
    engagementSummary?: SortOrder
    associatedProgram?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    preferredDivision?: SortOrder
    mos?: SortOrder
    requirements?: SortOrder
    armyImpact?: SortOrder
    cft?: SortOrder
    engagementRequest?: SortOrder
    feedbackType?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    dueDate?: SortOrder
    dueDateTitle?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    funding?: SortOrder
    otherInfo?: SortOrder
    requestorName?: SortOrder
    requestorEmail?: SortOrder
    requestorPhone?: SortOrder
    requestorTitle?: SortOrder
    requestorOrganization?: SortOrder
    freeFormQuestion?: SortOrder
  }

  export type EngagementDraftAvgOrderByAggregateInput = {
    cft?: SortOrder
  }

  export type EngagementDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    engagementTitle?: SortOrder
    engagementSummary?: SortOrder
    associatedProgram?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    preferredDivision?: SortOrder
    mos?: SortOrder
    armyImpact?: SortOrder
    cft?: SortOrder
    engagementRequest?: SortOrder
    feedbackType?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    dueDate?: SortOrder
    dueDateTitle?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    funding?: SortOrder
    otherInfo?: SortOrder
    requestorName?: SortOrder
    requestorEmail?: SortOrder
    requestorPhone?: SortOrder
    requestorTitle?: SortOrder
    requestorOrganization?: SortOrder
    freeFormQuestion?: SortOrder
  }

  export type EngagementDraftMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    engagementTitle?: SortOrder
    engagementSummary?: SortOrder
    associatedProgram?: SortOrder
    soldierInput?: SortOrder
    soldiersNeeded?: SortOrder
    preferredDivision?: SortOrder
    mos?: SortOrder
    armyImpact?: SortOrder
    cft?: SortOrder
    engagementRequest?: SortOrder
    feedbackType?: SortOrder
    eventStartDate?: SortOrder
    eventEndDate?: SortOrder
    eventTitle?: SortOrder
    eventDescription?: SortOrder
    dueDate?: SortOrder
    dueDateTitle?: SortOrder
    addressOne?: SortOrder
    addressTwo?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    funding?: SortOrder
    otherInfo?: SortOrder
    requestorName?: SortOrder
    requestorEmail?: SortOrder
    requestorPhone?: SortOrder
    requestorTitle?: SortOrder
    requestorOrganization?: SortOrder
    freeFormQuestion?: SortOrder
  }

  export type EngagementDraftSumOrderByAggregateInput = {
    cft?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserCreateWithoutOrganizationInput>, Enumerable<UserUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOrganizationInput>
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EngagementCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutOrganizationInput>, Enumerable<EngagementUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutOrganizationInput>
    createMany?: EngagementCreateManyOrganizationInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type OrganizationAccessCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutOrganizationInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationAccessCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserCreateWithoutOrganizationInput>, Enumerable<UserUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOrganizationInput>
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EngagementUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutOrganizationInput>, Enumerable<EngagementUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutOrganizationInput>
    createMany?: EngagementCreateManyOrganizationInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type OrganizationAccessUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutOrganizationInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutOrganizationInput>
    createMany?: OrganizationAccessCreateManyOrganizationInputEnvelope
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserCreateWithoutOrganizationInput>, Enumerable<UserUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type EngagementUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutOrganizationInput>, Enumerable<EngagementUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: EngagementCreateManyOrganizationInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganizationAccessUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutOrganizationInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationAccessUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationAccessCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationAccessWhereUniqueInput>
    disconnect?: Enumerable<OrganizationAccessWhereUniqueInput>
    delete?: Enumerable<OrganizationAccessWhereUniqueInput>
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
    update?: Enumerable<OrganizationAccessUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationAccessUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationAccessScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<UserCreateWithoutOrganizationInput>, Enumerable<UserUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type EngagementUncheckedUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutOrganizationInput>, Enumerable<EngagementUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: EngagementCreateManyOrganizationInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type OrganizationAccessUncheckedUpdateManyWithoutOrganizationInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutOrganizationInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutOrganizationInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutOrganizationInput>
    upsert?: Enumerable<OrganizationAccessUpsertWithWhereUniqueWithoutOrganizationInput>
    createMany?: OrganizationAccessCreateManyOrganizationInputEnvelope
    set?: Enumerable<OrganizationAccessWhereUniqueInput>
    disconnect?: Enumerable<OrganizationAccessWhereUniqueInput>
    delete?: Enumerable<OrganizationAccessWhereUniqueInput>
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
    update?: Enumerable<OrganizationAccessUpdateWithWhereUniqueWithoutOrganizationInput>
    updateMany?: Enumerable<OrganizationAccessUpdateManyWithWhereWithoutOrganizationInput>
    deleteMany?: Enumerable<OrganizationAccessScalarWhereInput>
  }

  export type OrganizationCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    connect?: OrganizationWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type EngagementCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutUserInput>, Enumerable<EngagementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutUserInput>
    createMany?: EngagementCreateManyUserInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type OrganizationAccessCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutUserInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutUserInput>
    createMany?: OrganizationAccessCreateManyUserInputEnvelope
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
  }

  export type EngagementDraftCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementDraftCreateWithoutUserInput>, Enumerable<EngagementDraftUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementDraftCreateOrConnectWithoutUserInput>
    createMany?: EngagementDraftCreateManyUserInputEnvelope
    connect?: Enumerable<EngagementDraftWhereUniqueInput>
  }

  export type EngagementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutUserInput>, Enumerable<EngagementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutUserInput>
    createMany?: EngagementCreateManyUserInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type OrganizationAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutUserInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutUserInput>
    createMany?: OrganizationAccessCreateManyUserInputEnvelope
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
  }

  export type EngagementDraftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementDraftCreateWithoutUserInput>, Enumerable<EngagementDraftUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementDraftCreateOrConnectWithoutUserInput>
    createMany?: EngagementDraftCreateManyUserInputEnvelope
    connect?: Enumerable<EngagementDraftWhereUniqueInput>
  }

  export type OrganizationUpdateOneWithoutUserInput = {
    create?: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUserInput
    upsert?: OrganizationUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type EngagementUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutUserInput>, Enumerable<EngagementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EngagementCreateManyUserInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type OrganizationAccessUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutUserInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrganizationAccessUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrganizationAccessCreateManyUserInputEnvelope
    set?: Enumerable<OrganizationAccessWhereUniqueInput>
    disconnect?: Enumerable<OrganizationAccessWhereUniqueInput>
    delete?: Enumerable<OrganizationAccessWhereUniqueInput>
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
    update?: Enumerable<OrganizationAccessUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrganizationAccessUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrganizationAccessScalarWhereInput>
  }

  export type EngagementDraftUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementDraftCreateWithoutUserInput>, Enumerable<EngagementDraftUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementDraftCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EngagementDraftUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EngagementDraftCreateManyUserInputEnvelope
    set?: Enumerable<EngagementDraftWhereUniqueInput>
    disconnect?: Enumerable<EngagementDraftWhereUniqueInput>
    delete?: Enumerable<EngagementDraftWhereUniqueInput>
    connect?: Enumerable<EngagementDraftWhereUniqueInput>
    update?: Enumerable<EngagementDraftUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EngagementDraftUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EngagementDraftScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EngagementUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutUserInput>, Enumerable<EngagementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EngagementCreateManyUserInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type OrganizationAccessUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<OrganizationAccessCreateWithoutUserInput>, Enumerable<OrganizationAccessUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrganizationAccessCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrganizationAccessUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrganizationAccessCreateManyUserInputEnvelope
    set?: Enumerable<OrganizationAccessWhereUniqueInput>
    disconnect?: Enumerable<OrganizationAccessWhereUniqueInput>
    delete?: Enumerable<OrganizationAccessWhereUniqueInput>
    connect?: Enumerable<OrganizationAccessWhereUniqueInput>
    update?: Enumerable<OrganizationAccessUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrganizationAccessUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrganizationAccessScalarWhereInput>
  }

  export type EngagementDraftUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<EngagementDraftCreateWithoutUserInput>, Enumerable<EngagementDraftUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EngagementDraftCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EngagementDraftUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EngagementDraftCreateManyUserInputEnvelope
    set?: Enumerable<EngagementDraftWhereUniqueInput>
    disconnect?: Enumerable<EngagementDraftWhereUniqueInput>
    delete?: Enumerable<EngagementDraftWhereUniqueInput>
    connect?: Enumerable<EngagementDraftWhereUniqueInput>
    update?: Enumerable<EngagementDraftUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EngagementDraftUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EngagementDraftScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type OrganizationCreateNestedOneWithoutOrganizationAccessInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationAccessInput, OrganizationUncheckedCreateWithoutOrganizationAccessInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationAccessInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationAccessInput = {
    create?: XOR<UserCreateWithoutOrganizationAccessInput, UserUncheckedCreateWithoutOrganizationAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationAccessInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutOrganizationAccessInput = {
    create?: XOR<OrganizationCreateWithoutOrganizationAccessInput, OrganizationUncheckedCreateWithoutOrganizationAccessInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOrganizationAccessInput
    upsert?: OrganizationUpsertWithoutOrganizationAccessInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutOrganizationAccessInput, OrganizationUncheckedUpdateWithoutOrganizationAccessInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationAccessInput = {
    create?: XOR<UserCreateWithoutOrganizationAccessInput, UserUncheckedCreateWithoutOrganizationAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationAccessInput
    upsert?: UserUpsertWithoutOrganizationAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrganizationAccessInput, UserUncheckedUpdateWithoutOrganizationAccessInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrganizationCreateNestedOneWithoutEngagementInput = {
    create?: XOR<OrganizationCreateWithoutEngagementInput, OrganizationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEngagementInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEngagementInput = {
    create?: XOR<UserCreateWithoutEngagementInput, UserUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutEngagementInput = {
    create?: XOR<LocationCreateWithoutEngagementInput, LocationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEngagementInput
    connect?: LocationWhereUniqueInput
  }

  export type DemographicCreateNestedOneWithoutEngagementInput = {
    create?: XOR<DemographicCreateWithoutEngagementInput, DemographicUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: DemographicCreateOrConnectWithoutEngagementInput
    connect?: DemographicWhereUniqueInput
  }

  export type EngagementDetailCreateNestedOneWithoutEngagementInput = {
    create?: XOR<EngagementDetailCreateWithoutEngagementInput, EngagementDetailUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: EngagementDetailCreateOrConnectWithoutEngagementInput
    connect?: EngagementDetailWhereUniqueInput
  }

  export type CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<CrossFunctionalTeamsCreateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: CrossFunctionalTeamsCreateOrConnectWithoutEngagementsInput
    connect?: CrossFunctionalTeamsWhereUniqueInput
  }

  export type RequestorInformationCreateNestedOneWithoutEngagementInput = {
    create?: XOR<RequestorInformationCreateWithoutEngagementInput, RequestorInformationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: RequestorInformationCreateOrConnectWithoutEngagementInput
    connect?: RequestorInformationWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<EventCreateWithoutEngagementInput>, Enumerable<EventUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutEngagementInput>
    createMany?: EventCreateManyEngagementInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type DueDateCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<DueDateCreateWithoutEngagementInput>, Enumerable<DueDateUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<DueDateCreateOrConnectWithoutEngagementInput>
    createMany?: DueDateCreateManyEngagementInputEnvelope
    connect?: Enumerable<DueDateWhereUniqueInput>
  }

  export type FileCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementInput>, Enumerable<FileUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementInput>
    createMany?: FileCreateManyEngagementInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type FeedbackConfigCreateNestedOneWithoutEngagementInput = {
    create?: XOR<FeedbackConfigCreateWithoutEngagementInput, FeedbackConfigUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutEngagementInput
    connect?: FeedbackConfigWhereUniqueInput
  }

  export type EventUncheckedCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<EventCreateWithoutEngagementInput>, Enumerable<EventUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutEngagementInput>
    createMany?: EventCreateManyEngagementInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type DueDateUncheckedCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<DueDateCreateWithoutEngagementInput>, Enumerable<DueDateUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<DueDateCreateOrConnectWithoutEngagementInput>
    createMany?: DueDateCreateManyEngagementInputEnvelope
    connect?: Enumerable<DueDateWhereUniqueInput>
  }

  export type FileUncheckedCreateNestedManyWithoutEngagementInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementInput>, Enumerable<FileUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementInput>
    createMany?: FileCreateManyEngagementInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type OrganizationUpdateOneRequiredWithoutEngagementInput = {
    create?: XOR<OrganizationCreateWithoutEngagementInput, OrganizationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEngagementInput
    upsert?: OrganizationUpsertWithoutEngagementInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutEngagementInput, OrganizationUncheckedUpdateWithoutEngagementInput>
  }

  export type UserUpdateOneRequiredWithoutEngagementInput = {
    create?: XOR<UserCreateWithoutEngagementInput, UserUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementInput
    upsert?: UserUpsertWithoutEngagementInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEngagementInput, UserUncheckedUpdateWithoutEngagementInput>
  }

  export type LocationUpdateOneWithoutEngagementInput = {
    create?: XOR<LocationCreateWithoutEngagementInput, LocationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEngagementInput
    upsert?: LocationUpsertWithoutEngagementInput
    disconnect?: boolean
    delete?: boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<LocationUpdateWithoutEngagementInput, LocationUncheckedUpdateWithoutEngagementInput>
  }

  export type DemographicUpdateOneRequiredWithoutEngagementInput = {
    create?: XOR<DemographicCreateWithoutEngagementInput, DemographicUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: DemographicCreateOrConnectWithoutEngagementInput
    upsert?: DemographicUpsertWithoutEngagementInput
    connect?: DemographicWhereUniqueInput
    update?: XOR<DemographicUpdateWithoutEngagementInput, DemographicUncheckedUpdateWithoutEngagementInput>
  }

  export type EngagementDetailUpdateOneRequiredWithoutEngagementInput = {
    create?: XOR<EngagementDetailCreateWithoutEngagementInput, EngagementDetailUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: EngagementDetailCreateOrConnectWithoutEngagementInput
    upsert?: EngagementDetailUpsertWithoutEngagementInput
    connect?: EngagementDetailWhereUniqueInput
    update?: XOR<EngagementDetailUpdateWithoutEngagementInput, EngagementDetailUncheckedUpdateWithoutEngagementInput>
  }

  export type CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput = {
    create?: XOR<CrossFunctionalTeamsCreateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: CrossFunctionalTeamsCreateOrConnectWithoutEngagementsInput
    upsert?: CrossFunctionalTeamsUpsertWithoutEngagementsInput
    connect?: CrossFunctionalTeamsWhereUniqueInput
    update?: XOR<CrossFunctionalTeamsUpdateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedUpdateWithoutEngagementsInput>
  }

  export type RequestorInformationUpdateOneRequiredWithoutEngagementInput = {
    create?: XOR<RequestorInformationCreateWithoutEngagementInput, RequestorInformationUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: RequestorInformationCreateOrConnectWithoutEngagementInput
    upsert?: RequestorInformationUpsertWithoutEngagementInput
    connect?: RequestorInformationWhereUniqueInput
    update?: XOR<RequestorInformationUpdateWithoutEngagementInput, RequestorInformationUncheckedUpdateWithoutEngagementInput>
  }

  export type EventUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<EventCreateWithoutEngagementInput>, Enumerable<EventUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: EventCreateManyEngagementInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type DueDateUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<DueDateCreateWithoutEngagementInput>, Enumerable<DueDateUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<DueDateCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<DueDateUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: DueDateCreateManyEngagementInputEnvelope
    set?: Enumerable<DueDateWhereUniqueInput>
    disconnect?: Enumerable<DueDateWhereUniqueInput>
    delete?: Enumerable<DueDateWhereUniqueInput>
    connect?: Enumerable<DueDateWhereUniqueInput>
    update?: Enumerable<DueDateUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<DueDateUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<DueDateScalarWhereInput>
  }

  export type FileUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementInput>, Enumerable<FileUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: FileCreateManyEngagementInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type FeedbackConfigUpdateOneWithoutEngagementInput = {
    create?: XOR<FeedbackConfigCreateWithoutEngagementInput, FeedbackConfigUncheckedCreateWithoutEngagementInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutEngagementInput
    upsert?: FeedbackConfigUpsertWithoutEngagementInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackConfigWhereUniqueInput
    update?: XOR<FeedbackConfigUpdateWithoutEngagementInput, FeedbackConfigUncheckedUpdateWithoutEngagementInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EventUncheckedUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<EventCreateWithoutEngagementInput>, Enumerable<EventUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: EventCreateManyEngagementInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type DueDateUncheckedUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<DueDateCreateWithoutEngagementInput>, Enumerable<DueDateUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<DueDateCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<DueDateUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: DueDateCreateManyEngagementInputEnvelope
    set?: Enumerable<DueDateWhereUniqueInput>
    disconnect?: Enumerable<DueDateWhereUniqueInput>
    delete?: Enumerable<DueDateWhereUniqueInput>
    connect?: Enumerable<DueDateWhereUniqueInput>
    update?: Enumerable<DueDateUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<DueDateUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<DueDateScalarWhereInput>
  }

  export type FileUncheckedUpdateManyWithoutEngagementInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementInput>, Enumerable<FileUncheckedCreateWithoutEngagementInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutEngagementInput>
    createMany?: FileCreateManyEngagementInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutEngagementInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutEngagementInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type EngagementCreateNestedOneWithoutLocationInput = {
    create?: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutLocationInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutLocationInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutLocationInput = {
    create?: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutLocationInput
    upsert?: EngagementUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutLocationInput, EngagementUncheckedUpdateWithoutLocationInput>
  }

  export type EngagementUncheckedUpdateOneWithoutLocationInput = {
    create?: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutLocationInput
    upsert?: EngagementUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutLocationInput, EngagementUncheckedUpdateWithoutLocationInput>
  }

  export type EngagementCreateNestedOneWithoutEngagementDetailInput = {
    create?: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEngagementDetailInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUncheckedCreateNestedOneWithoutEngagementDetailInput = {
    create?: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEngagementDetailInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutEngagementDetailInput = {
    create?: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEngagementDetailInput
    upsert?: EngagementUpsertWithoutEngagementDetailInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutEngagementDetailInput, EngagementUncheckedUpdateWithoutEngagementDetailInput>
  }

  export type EngagementUncheckedUpdateOneWithoutEngagementDetailInput = {
    create?: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEngagementDetailInput
    upsert?: EngagementUpsertWithoutEngagementDetailInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutEngagementDetailInput, EngagementUncheckedUpdateWithoutEngagementDetailInput>
  }

  export type EngagementCreateNestedManyWithoutCrossFunctionalTeamInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutCrossFunctionalTeamInput>, Enumerable<EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutCrossFunctionalTeamInput>
    createMany?: EngagementCreateManyCrossFunctionalTeamInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type EngagementUncheckedCreateNestedManyWithoutCrossFunctionalTeamInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutCrossFunctionalTeamInput>, Enumerable<EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutCrossFunctionalTeamInput>
    createMany?: EngagementCreateManyCrossFunctionalTeamInputEnvelope
    connect?: Enumerable<EngagementWhereUniqueInput>
  }

  export type EngagementUpdateManyWithoutCrossFunctionalTeamInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutCrossFunctionalTeamInput>, Enumerable<EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutCrossFunctionalTeamInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutCrossFunctionalTeamInput>
    createMany?: EngagementCreateManyCrossFunctionalTeamInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutCrossFunctionalTeamInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutCrossFunctionalTeamInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type EngagementUncheckedUpdateManyWithoutCrossFunctionalTeamInput = {
    create?: XOR<Enumerable<EngagementCreateWithoutCrossFunctionalTeamInput>, Enumerable<EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>>
    connectOrCreate?: Enumerable<EngagementCreateOrConnectWithoutCrossFunctionalTeamInput>
    upsert?: Enumerable<EngagementUpsertWithWhereUniqueWithoutCrossFunctionalTeamInput>
    createMany?: EngagementCreateManyCrossFunctionalTeamInputEnvelope
    set?: Enumerable<EngagementWhereUniqueInput>
    disconnect?: Enumerable<EngagementWhereUniqueInput>
    delete?: Enumerable<EngagementWhereUniqueInput>
    connect?: Enumerable<EngagementWhereUniqueInput>
    update?: Enumerable<EngagementUpdateWithWhereUniqueWithoutCrossFunctionalTeamInput>
    updateMany?: Enumerable<EngagementUpdateManyWithWhereWithoutCrossFunctionalTeamInput>
    deleteMany?: Enumerable<EngagementScalarWhereInput>
  }

  export type EngagementCreateNestedOneWithoutDemographicInput = {
    create?: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDemographicInput
    connect?: EngagementWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutDemographicsInput = {
    create?: XOR<Enumerable<RequirementCreateWithoutDemographicsInput>, Enumerable<RequirementUncheckedCreateWithoutDemographicsInput>>
    connectOrCreate?: Enumerable<RequirementCreateOrConnectWithoutDemographicsInput>
    connect?: Enumerable<RequirementWhereUniqueInput>
  }

  export type EngagementUncheckedCreateNestedOneWithoutDemographicInput = {
    create?: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDemographicInput
    connect?: EngagementWhereUniqueInput
  }

  export type RequirementUncheckedCreateNestedManyWithoutDemographicsInput = {
    create?: XOR<Enumerable<RequirementCreateWithoutDemographicsInput>, Enumerable<RequirementUncheckedCreateWithoutDemographicsInput>>
    connectOrCreate?: Enumerable<RequirementCreateOrConnectWithoutDemographicsInput>
    connect?: Enumerable<RequirementWhereUniqueInput>
  }

  export type EngagementUpdateOneWithoutDemographicInput = {
    create?: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDemographicInput
    upsert?: EngagementUpsertWithoutDemographicInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutDemographicInput, EngagementUncheckedUpdateWithoutDemographicInput>
  }

  export type RequirementUpdateManyWithoutDemographicsInput = {
    create?: XOR<Enumerable<RequirementCreateWithoutDemographicsInput>, Enumerable<RequirementUncheckedCreateWithoutDemographicsInput>>
    connectOrCreate?: Enumerable<RequirementCreateOrConnectWithoutDemographicsInput>
    upsert?: Enumerable<RequirementUpsertWithWhereUniqueWithoutDemographicsInput>
    set?: Enumerable<RequirementWhereUniqueInput>
    disconnect?: Enumerable<RequirementWhereUniqueInput>
    delete?: Enumerable<RequirementWhereUniqueInput>
    connect?: Enumerable<RequirementWhereUniqueInput>
    update?: Enumerable<RequirementUpdateWithWhereUniqueWithoutDemographicsInput>
    updateMany?: Enumerable<RequirementUpdateManyWithWhereWithoutDemographicsInput>
    deleteMany?: Enumerable<RequirementScalarWhereInput>
  }

  export type EngagementUncheckedUpdateOneWithoutDemographicInput = {
    create?: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDemographicInput
    upsert?: EngagementUpsertWithoutDemographicInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutDemographicInput, EngagementUncheckedUpdateWithoutDemographicInput>
  }

  export type RequirementUncheckedUpdateManyWithoutDemographicsInput = {
    create?: XOR<Enumerable<RequirementCreateWithoutDemographicsInput>, Enumerable<RequirementUncheckedCreateWithoutDemographicsInput>>
    connectOrCreate?: Enumerable<RequirementCreateOrConnectWithoutDemographicsInput>
    upsert?: Enumerable<RequirementUpsertWithWhereUniqueWithoutDemographicsInput>
    set?: Enumerable<RequirementWhereUniqueInput>
    disconnect?: Enumerable<RequirementWhereUniqueInput>
    delete?: Enumerable<RequirementWhereUniqueInput>
    connect?: Enumerable<RequirementWhereUniqueInput>
    update?: Enumerable<RequirementUpdateWithWhereUniqueWithoutDemographicsInput>
    updateMany?: Enumerable<RequirementUpdateManyWithWhereWithoutDemographicsInput>
    deleteMany?: Enumerable<RequirementScalarWhereInput>
  }

  export type DemographicCreateNestedManyWithoutRequirementsInput = {
    create?: XOR<Enumerable<DemographicCreateWithoutRequirementsInput>, Enumerable<DemographicUncheckedCreateWithoutRequirementsInput>>
    connectOrCreate?: Enumerable<DemographicCreateOrConnectWithoutRequirementsInput>
    connect?: Enumerable<DemographicWhereUniqueInput>
  }

  export type DemographicUncheckedCreateNestedManyWithoutRequirementsInput = {
    create?: XOR<Enumerable<DemographicCreateWithoutRequirementsInput>, Enumerable<DemographicUncheckedCreateWithoutRequirementsInput>>
    connectOrCreate?: Enumerable<DemographicCreateOrConnectWithoutRequirementsInput>
    connect?: Enumerable<DemographicWhereUniqueInput>
  }

  export type DemographicUpdateManyWithoutRequirementsInput = {
    create?: XOR<Enumerable<DemographicCreateWithoutRequirementsInput>, Enumerable<DemographicUncheckedCreateWithoutRequirementsInput>>
    connectOrCreate?: Enumerable<DemographicCreateOrConnectWithoutRequirementsInput>
    upsert?: Enumerable<DemographicUpsertWithWhereUniqueWithoutRequirementsInput>
    set?: Enumerable<DemographicWhereUniqueInput>
    disconnect?: Enumerable<DemographicWhereUniqueInput>
    delete?: Enumerable<DemographicWhereUniqueInput>
    connect?: Enumerable<DemographicWhereUniqueInput>
    update?: Enumerable<DemographicUpdateWithWhereUniqueWithoutRequirementsInput>
    updateMany?: Enumerable<DemographicUpdateManyWithWhereWithoutRequirementsInput>
    deleteMany?: Enumerable<DemographicScalarWhereInput>
  }

  export type DemographicUncheckedUpdateManyWithoutRequirementsInput = {
    create?: XOR<Enumerable<DemographicCreateWithoutRequirementsInput>, Enumerable<DemographicUncheckedCreateWithoutRequirementsInput>>
    connectOrCreate?: Enumerable<DemographicCreateOrConnectWithoutRequirementsInput>
    upsert?: Enumerable<DemographicUpsertWithWhereUniqueWithoutRequirementsInput>
    set?: Enumerable<DemographicWhereUniqueInput>
    disconnect?: Enumerable<DemographicWhereUniqueInput>
    delete?: Enumerable<DemographicWhereUniqueInput>
    connect?: Enumerable<DemographicWhereUniqueInput>
    update?: Enumerable<DemographicUpdateWithWhereUniqueWithoutRequirementsInput>
    updateMany?: Enumerable<DemographicUpdateManyWithWhereWithoutRequirementsInput>
    deleteMany?: Enumerable<DemographicScalarWhereInput>
  }

  export type EngagementCreateNestedOneWithoutRequestorInput = {
    create?: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutRequestorInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUncheckedCreateNestedOneWithoutRequestorInput = {
    create?: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutRequestorInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutRequestorInput = {
    create?: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutRequestorInput
    upsert?: EngagementUpsertWithoutRequestorInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutRequestorInput, EngagementUncheckedUpdateWithoutRequestorInput>
  }

  export type EngagementUncheckedUpdateOneWithoutRequestorInput = {
    create?: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutRequestorInput
    upsert?: EngagementUpsertWithoutRequestorInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutRequestorInput, EngagementUncheckedUpdateWithoutRequestorInput>
  }

  export type EngagementCreateNestedOneWithoutEventsInput = {
    create?: XOR<EngagementCreateWithoutEventsInput, EngagementUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEventsInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutEventsInput = {
    create?: XOR<EngagementCreateWithoutEventsInput, EngagementUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutEventsInput
    upsert?: EngagementUpsertWithoutEventsInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutEventsInput, EngagementUncheckedUpdateWithoutEventsInput>
  }

  export type EngagementCreateNestedOneWithoutDueDatesInput = {
    create?: XOR<EngagementCreateWithoutDueDatesInput, EngagementUncheckedCreateWithoutDueDatesInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDueDatesInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutDueDatesInput = {
    create?: XOR<EngagementCreateWithoutDueDatesInput, EngagementUncheckedCreateWithoutDueDatesInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutDueDatesInput
    upsert?: EngagementUpsertWithoutDueDatesInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutDueDatesInput, EngagementUncheckedUpdateWithoutDueDatesInput>
  }

  export type EngagementCreateNestedOneWithoutFeedbackConfigInput = {
    create?: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFeedbackConfigInput
    connect?: EngagementWhereUniqueInput
  }

  export type TestFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<TestFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: TestFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
  }

  export type InputFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<InputFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: InputFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
  }

  export type FreeFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<FreeFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: FreeFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
  }

  export type EngagementUncheckedCreateNestedOneWithoutFeedbackConfigInput = {
    create?: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFeedbackConfigInput
    connect?: EngagementWhereUniqueInput
  }

  export type TestFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<TestFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: TestFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
  }

  export type InputFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<InputFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: InputFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
  }

  export type FreeFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<FreeFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    createMany?: FreeFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    connect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
  }

  export type EnumFeedbackTypesFieldUpdateOperationsInput = {
    set?: FeedbackTypes
  }

  export type EngagementUpdateOneWithoutFeedbackConfigInput = {
    create?: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFeedbackConfigInput
    upsert?: EngagementUpsertWithoutFeedbackConfigInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutFeedbackConfigInput, EngagementUncheckedUpdateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<TestFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<TestFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: TestFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<TestFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<TestFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<TestFeedbackSubmissionScalarWhereInput>
  }

  export type InputFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<InputFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<InputFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: InputFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<InputFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<InputFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<InputFeedbackSubmissionScalarWhereInput>
  }

  export type FreeFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<FreeFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<FreeFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: FreeFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<FreeFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<FreeFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<FreeFeedbackSubmissionScalarWhereInput>
  }

  export type EngagementUncheckedUpdateOneWithoutFeedbackConfigInput = {
    create?: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFeedbackConfigInput
    upsert?: EngagementUpsertWithoutFeedbackConfigInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutFeedbackConfigInput, EngagementUncheckedUpdateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<TestFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<TestFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: TestFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<TestFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<TestFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<TestFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<TestFeedbackSubmissionScalarWhereInput>
  }

  export type InputFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<InputFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<InputFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: InputFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<InputFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<InputFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<InputFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<InputFeedbackSubmissionScalarWhereInput>
  }

  export type FreeFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput = {
    create?: XOR<Enumerable<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput>, Enumerable<FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>>
    connectOrCreate?: Enumerable<FreeFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput>
    upsert?: Enumerable<FreeFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput>
    createMany?: FreeFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope
    set?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    disconnect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    delete?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    connect?: Enumerable<FreeFeedbackSubmissionWhereUniqueInput>
    update?: Enumerable<FreeFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput>
    updateMany?: Enumerable<FreeFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput>
    deleteMany?: Enumerable<FreeFeedbackSubmissionScalarWhereInput>
  }

  export type FeedbackConfigCreateNestedOneWithoutTestFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutTestFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutTestFeedbackSubmissionsInput
    connect?: FeedbackConfigWhereUniqueInput
  }

  export type TestFeedbackResponsesCreateNestedOneWithoutTestFeedbackInput = {
    create?: XOR<TestFeedbackResponsesCreateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedCreateWithoutTestFeedbackInput>
    connectOrCreate?: TestFeedbackResponsesCreateOrConnectWithoutTestFeedbackInput
    connect?: TestFeedbackResponsesWhereUniqueInput
  }

  export type FeedbackConfigUpdateOneWithoutTestFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutTestFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutTestFeedbackSubmissionsInput
    upsert?: FeedbackConfigUpsertWithoutTestFeedbackSubmissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackConfigWhereUniqueInput
    update?: XOR<FeedbackConfigUpdateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutTestFeedbackSubmissionsInput>
  }

  export type TestFeedbackResponsesUpdateOneRequiredWithoutTestFeedbackInput = {
    create?: XOR<TestFeedbackResponsesCreateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedCreateWithoutTestFeedbackInput>
    connectOrCreate?: TestFeedbackResponsesCreateOrConnectWithoutTestFeedbackInput
    upsert?: TestFeedbackResponsesUpsertWithoutTestFeedbackInput
    connect?: TestFeedbackResponsesWhereUniqueInput
    update?: XOR<TestFeedbackResponsesUpdateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedUpdateWithoutTestFeedbackInput>
  }

  export type TestFeedbackSubmissionCreateNestedOneWithoutTestFeedbackResponsesInput = {
    create?: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
    connectOrCreate?: TestFeedbackSubmissionCreateOrConnectWithoutTestFeedbackResponsesInput
    connect?: TestFeedbackSubmissionWhereUniqueInput
  }

  export type TestFeedbackSubmissionUncheckedCreateNestedOneWithoutTestFeedbackResponsesInput = {
    create?: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
    connectOrCreate?: TestFeedbackSubmissionCreateOrConnectWithoutTestFeedbackResponsesInput
    connect?: TestFeedbackSubmissionWhereUniqueInput
  }

  export type TestFeedbackSubmissionUpdateOneWithoutTestFeedbackResponsesInput = {
    create?: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
    connectOrCreate?: TestFeedbackSubmissionCreateOrConnectWithoutTestFeedbackResponsesInput
    upsert?: TestFeedbackSubmissionUpsertWithoutTestFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: TestFeedbackSubmissionWhereUniqueInput
    update?: XOR<TestFeedbackSubmissionUpdateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedUpdateWithoutTestFeedbackResponsesInput>
  }

  export type TestFeedbackSubmissionUncheckedUpdateOneWithoutTestFeedbackResponsesInput = {
    create?: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
    connectOrCreate?: TestFeedbackSubmissionCreateOrConnectWithoutTestFeedbackResponsesInput
    upsert?: TestFeedbackSubmissionUpsertWithoutTestFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: TestFeedbackSubmissionWhereUniqueInput
    update?: XOR<TestFeedbackSubmissionUpdateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedUpdateWithoutTestFeedbackResponsesInput>
  }

  export type FeedbackConfigCreateNestedOneWithoutInputFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutInputFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutInputFeedbackSubmissionsInput
    connect?: FeedbackConfigWhereUniqueInput
  }

  export type InputFeedbackResponsesCreateNestedOneWithoutInputFeedbackInput = {
    create?: XOR<InputFeedbackResponsesCreateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedCreateWithoutInputFeedbackInput>
    connectOrCreate?: InputFeedbackResponsesCreateOrConnectWithoutInputFeedbackInput
    connect?: InputFeedbackResponsesWhereUniqueInput
  }

  export type FeedbackConfigUpdateOneWithoutInputFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutInputFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutInputFeedbackSubmissionsInput
    upsert?: FeedbackConfigUpsertWithoutInputFeedbackSubmissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackConfigWhereUniqueInput
    update?: XOR<FeedbackConfigUpdateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutInputFeedbackSubmissionsInput>
  }

  export type InputFeedbackResponsesUpdateOneRequiredWithoutInputFeedbackInput = {
    create?: XOR<InputFeedbackResponsesCreateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedCreateWithoutInputFeedbackInput>
    connectOrCreate?: InputFeedbackResponsesCreateOrConnectWithoutInputFeedbackInput
    upsert?: InputFeedbackResponsesUpsertWithoutInputFeedbackInput
    connect?: InputFeedbackResponsesWhereUniqueInput
    update?: XOR<InputFeedbackResponsesUpdateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedUpdateWithoutInputFeedbackInput>
  }

  export type InputFeedbackSubmissionCreateNestedOneWithoutInputFeedbackResponsesInput = {
    create?: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
    connectOrCreate?: InputFeedbackSubmissionCreateOrConnectWithoutInputFeedbackResponsesInput
    connect?: InputFeedbackSubmissionWhereUniqueInput
  }

  export type InputFeedbackSubmissionUncheckedCreateNestedOneWithoutInputFeedbackResponsesInput = {
    create?: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
    connectOrCreate?: InputFeedbackSubmissionCreateOrConnectWithoutInputFeedbackResponsesInput
    connect?: InputFeedbackSubmissionWhereUniqueInput
  }

  export type InputFeedbackSubmissionUpdateOneWithoutInputFeedbackResponsesInput = {
    create?: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
    connectOrCreate?: InputFeedbackSubmissionCreateOrConnectWithoutInputFeedbackResponsesInput
    upsert?: InputFeedbackSubmissionUpsertWithoutInputFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: InputFeedbackSubmissionWhereUniqueInput
    update?: XOR<InputFeedbackSubmissionUpdateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedUpdateWithoutInputFeedbackResponsesInput>
  }

  export type InputFeedbackSubmissionUncheckedUpdateOneWithoutInputFeedbackResponsesInput = {
    create?: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
    connectOrCreate?: InputFeedbackSubmissionCreateOrConnectWithoutInputFeedbackResponsesInput
    upsert?: InputFeedbackSubmissionUpsertWithoutInputFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: InputFeedbackSubmissionWhereUniqueInput
    update?: XOR<InputFeedbackSubmissionUpdateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedUpdateWithoutInputFeedbackResponsesInput>
  }

  export type FeedbackConfigCreateNestedOneWithoutFreeFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutFreeFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutFreeFeedbackSubmissionsInput
    connect?: FeedbackConfigWhereUniqueInput
  }

  export type FreeFeedbackResponsesCreateNestedOneWithoutFreeFeedbackInput = {
    create?: XOR<FreeFeedbackResponsesCreateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedCreateWithoutFreeFeedbackInput>
    connectOrCreate?: FreeFeedbackResponsesCreateOrConnectWithoutFreeFeedbackInput
    connect?: FreeFeedbackResponsesWhereUniqueInput
  }

  export type FeedbackConfigUpdateOneWithoutFreeFeedbackSubmissionsInput = {
    create?: XOR<FeedbackConfigCreateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutFreeFeedbackSubmissionsInput>
    connectOrCreate?: FeedbackConfigCreateOrConnectWithoutFreeFeedbackSubmissionsInput
    upsert?: FeedbackConfigUpsertWithoutFreeFeedbackSubmissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackConfigWhereUniqueInput
    update?: XOR<FeedbackConfigUpdateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutFreeFeedbackSubmissionsInput>
  }

  export type FreeFeedbackResponsesUpdateOneRequiredWithoutFreeFeedbackInput = {
    create?: XOR<FreeFeedbackResponsesCreateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedCreateWithoutFreeFeedbackInput>
    connectOrCreate?: FreeFeedbackResponsesCreateOrConnectWithoutFreeFeedbackInput
    upsert?: FreeFeedbackResponsesUpsertWithoutFreeFeedbackInput
    connect?: FreeFeedbackResponsesWhereUniqueInput
    update?: XOR<FreeFeedbackResponsesUpdateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedUpdateWithoutFreeFeedbackInput>
  }

  export type FreeFeedbackSubmissionCreateNestedOneWithoutFreeFeedbackResponsesInput = {
    create?: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
    connectOrCreate?: FreeFeedbackSubmissionCreateOrConnectWithoutFreeFeedbackResponsesInput
    connect?: FreeFeedbackSubmissionWhereUniqueInput
  }

  export type FreeFeedbackSubmissionUncheckedCreateNestedOneWithoutFreeFeedbackResponsesInput = {
    create?: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
    connectOrCreate?: FreeFeedbackSubmissionCreateOrConnectWithoutFreeFeedbackResponsesInput
    connect?: FreeFeedbackSubmissionWhereUniqueInput
  }

  export type FreeFeedbackSubmissionUpdateOneWithoutFreeFeedbackResponsesInput = {
    create?: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
    connectOrCreate?: FreeFeedbackSubmissionCreateOrConnectWithoutFreeFeedbackResponsesInput
    upsert?: FreeFeedbackSubmissionUpsertWithoutFreeFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: FreeFeedbackSubmissionWhereUniqueInput
    update?: XOR<FreeFeedbackSubmissionUpdateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedUpdateWithoutFreeFeedbackResponsesInput>
  }

  export type FreeFeedbackSubmissionUncheckedUpdateOneWithoutFreeFeedbackResponsesInput = {
    create?: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
    connectOrCreate?: FreeFeedbackSubmissionCreateOrConnectWithoutFreeFeedbackResponsesInput
    upsert?: FreeFeedbackSubmissionUpsertWithoutFreeFeedbackResponsesInput
    disconnect?: boolean
    delete?: boolean
    connect?: FreeFeedbackSubmissionWhereUniqueInput
    update?: XOR<FreeFeedbackSubmissionUpdateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedUpdateWithoutFreeFeedbackResponsesInput>
  }

  export type EngagementCreateNestedOneWithoutFilesInput = {
    create?: XOR<EngagementCreateWithoutFilesInput, EngagementUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFilesInput
    connect?: EngagementWhereUniqueInput
  }

  export type EngagementDraftCreateNestedOneWithoutFilesInput = {
    create?: XOR<EngagementDraftCreateWithoutFilesInput, EngagementDraftUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EngagementDraftCreateOrConnectWithoutFilesInput
    connect?: EngagementDraftWhereUniqueInput
  }

  export type EngagementUpdateOneWithoutFilesInput = {
    create?: XOR<EngagementCreateWithoutFilesInput, EngagementUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EngagementCreateOrConnectWithoutFilesInput
    upsert?: EngagementUpsertWithoutFilesInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementWhereUniqueInput
    update?: XOR<EngagementUpdateWithoutFilesInput, EngagementUncheckedUpdateWithoutFilesInput>
  }

  export type EngagementDraftUpdateOneWithoutFilesInput = {
    create?: XOR<EngagementDraftCreateWithoutFilesInput, EngagementDraftUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EngagementDraftCreateOrConnectWithoutFilesInput
    upsert?: EngagementDraftUpsertWithoutFilesInput
    disconnect?: boolean
    delete?: boolean
    connect?: EngagementDraftWhereUniqueInput
    update?: XOR<EngagementDraftUpdateWithoutFilesInput, EngagementDraftUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutEngagementDraftInput = {
    create?: XOR<UserCreateWithoutEngagementDraftInput, UserUncheckedCreateWithoutEngagementDraftInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementDraftInput
    connect?: UserWhereUniqueInput
  }

  export type EngagementDraftCreaterequirementsInput = {
    set: Enumerable<string>
  }

  export type FileCreateNestedManyWithoutEngagementDraftInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementDraftInput>, Enumerable<FileUncheckedCreateWithoutEngagementDraftInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementDraftInput>
    createMany?: FileCreateManyEngagementDraftInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type FileUncheckedCreateNestedManyWithoutEngagementDraftInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementDraftInput>, Enumerable<FileUncheckedCreateWithoutEngagementDraftInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementDraftInput>
    createMany?: FileCreateManyEngagementDraftInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutEngagementDraftInput = {
    create?: XOR<UserCreateWithoutEngagementDraftInput, UserUncheckedCreateWithoutEngagementDraftInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementDraftInput
    upsert?: UserUpsertWithoutEngagementDraftInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEngagementDraftInput, UserUncheckedUpdateWithoutEngagementDraftInput>
  }

  export type EngagementDraftUpdaterequirementsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FileUpdateManyWithoutEngagementDraftInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementDraftInput>, Enumerable<FileUncheckedCreateWithoutEngagementDraftInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementDraftInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutEngagementDraftInput>
    createMany?: FileCreateManyEngagementDraftInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutEngagementDraftInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutEngagementDraftInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type FileUncheckedUpdateManyWithoutEngagementDraftInput = {
    create?: XOR<Enumerable<FileCreateWithoutEngagementDraftInput>, Enumerable<FileUncheckedCreateWithoutEngagementDraftInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutEngagementDraftInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutEngagementDraftInput>
    createMany?: FileCreateManyEngagementDraftInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutEngagementDraftInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutEngagementDraftInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumFeedbackTypesFilter = {
    equals?: FeedbackTypes
    in?: Enumerable<FeedbackTypes>
    notIn?: Enumerable<FeedbackTypes>
    not?: NestedEnumFeedbackTypesFilter | FeedbackTypes
  }

  export type NestedEnumFeedbackTypesWithAggregatesFilter = {
    equals?: FeedbackTypes
    in?: Enumerable<FeedbackTypes>
    notIn?: Enumerable<FeedbackTypes>
    not?: NestedEnumFeedbackTypesWithAggregatesFilter | FeedbackTypes
    _count?: NestedIntFilter
    _min?: NestedEnumFeedbackTypesFilter
    _max?: NestedEnumFeedbackTypesFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    role: RoleCreateNestedOneWithoutUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementUncheckedCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: Enumerable<UserCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type EngagementCreateWithoutOrganizationInput = {
    id?: string
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutOrganizationInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutOrganizationInput, EngagementUncheckedCreateWithoutOrganizationInput>
  }

  export type EngagementCreateManyOrganizationInputEnvelope = {
    data: Enumerable<EngagementCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type OrganizationAccessCreateWithoutOrganizationInput = {
    user: UserCreateNestedOneWithoutOrganizationAccessInput
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessUncheckedCreateWithoutOrganizationInput = {
    userId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationAccessWhereUniqueInput
    create: XOR<OrganizationAccessCreateWithoutOrganizationInput, OrganizationAccessUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationAccessCreateManyOrganizationInputEnvelope = {
    data: Enumerable<OrganizationAccessCreateManyOrganizationInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    initials?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    organizationId?: StringNullableFilter | string | null
    roleId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EngagementUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutOrganizationInput, EngagementUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EngagementCreateWithoutOrganizationInput, EngagementUncheckedCreateWithoutOrganizationInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutOrganizationInput, EngagementUncheckedUpdateWithoutOrganizationInput>
  }

  export type EngagementUpdateManyWithWhereWithoutOrganizationInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutEngagementInput>
  }

  export type EngagementScalarWhereInput = {
    AND?: Enumerable<EngagementScalarWhereInput>
    OR?: Enumerable<EngagementScalarWhereInput>
    NOT?: Enumerable<EngagementScalarWhereInput>
    id?: StringFilter | string
    organizationId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    locationId?: StringNullableFilter | string | null
    demographicId?: StringFilter | string
    engagementDetailId?: StringFilter | string
    status?: StringFilter | string
    crossFunctionalTeamId?: IntFilter | number
    requestorId?: StringFilter | string
    shortId?: StringNullableFilter | string | null
    feedbackConfigId?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    statusChangedOn?: DateTimeNullableFilter | Date | string | null
  }

  export type OrganizationAccessUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationAccessWhereUniqueInput
    update: XOR<OrganizationAccessUpdateWithoutOrganizationInput, OrganizationAccessUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationAccessCreateWithoutOrganizationInput, OrganizationAccessUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationAccessUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationAccessWhereUniqueInput
    data: XOR<OrganizationAccessUpdateWithoutOrganizationInput, OrganizationAccessUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationAccessUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationAccessScalarWhereInput
    data: XOR<OrganizationAccessUpdateManyMutationInput, OrganizationAccessUncheckedUpdateManyWithoutOrganizationAccessInput>
  }

  export type OrganizationAccessScalarWhereInput = {
    AND?: Enumerable<OrganizationAccessScalarWhereInput>
    OR?: Enumerable<OrganizationAccessScalarWhereInput>
    NOT?: Enumerable<OrganizationAccessScalarWhereInput>
    organizationId?: StringFilter | string
    userId?: StringFilter | string
    read?: BoolFilter | boolean
    write?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type OrganizationCreateWithoutUserInput = {
    id?: string
    name: string
    engagement?: EngagementCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    engagement?: EngagementUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUserInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
  }

  export type RoleCreateWithoutUsersInput = {
    type: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    type: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type EngagementCreateWithoutUserInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutUserInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutUserInput, EngagementUncheckedCreateWithoutUserInput>
  }

  export type EngagementCreateManyUserInputEnvelope = {
    data: Enumerable<EngagementCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrganizationAccessCreateWithoutUserInput = {
    organization: OrganizationCreateNestedOneWithoutOrganizationAccessInput
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessUncheckedCreateWithoutUserInput = {
    organizationId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationAccessCreateOrConnectWithoutUserInput = {
    where: OrganizationAccessWhereUniqueInput
    create: XOR<OrganizationAccessCreateWithoutUserInput, OrganizationAccessUncheckedCreateWithoutUserInput>
  }

  export type OrganizationAccessCreateManyUserInputEnvelope = {
    data: Enumerable<OrganizationAccessCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type EngagementDraftCreateWithoutUserInput = {
    id?: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    files?: FileCreateNestedManyWithoutEngagementDraftInput
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftUncheckedCreateWithoutUserInput = {
    id?: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    files?: FileUncheckedCreateNestedManyWithoutEngagementDraftInput
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftCreateOrConnectWithoutUserInput = {
    where: EngagementDraftWhereUniqueInput
    create: XOR<EngagementDraftCreateWithoutUserInput, EngagementDraftUncheckedCreateWithoutUserInput>
  }

  export type EngagementDraftCreateManyUserInputEnvelope = {
    data: Enumerable<EngagementDraftCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUserInput = {
    update: XOR<OrganizationUpdateWithoutUserInput, OrganizationUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationCreateWithoutUserInput, OrganizationUncheckedCreateWithoutUserInput>
  }

  export type OrganizationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUpdateManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUncheckedUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutOrganizationInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type EngagementUpsertWithWhereUniqueWithoutUserInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutUserInput, EngagementUncheckedUpdateWithoutUserInput>
    create: XOR<EngagementCreateWithoutUserInput, EngagementUncheckedCreateWithoutUserInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutUserInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutUserInput, EngagementUncheckedUpdateWithoutUserInput>
  }

  export type EngagementUpdateManyWithWhereWithoutUserInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutEngagementInput>
  }

  export type OrganizationAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationAccessWhereUniqueInput
    update: XOR<OrganizationAccessUpdateWithoutUserInput, OrganizationAccessUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationAccessCreateWithoutUserInput, OrganizationAccessUncheckedCreateWithoutUserInput>
  }

  export type OrganizationAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationAccessWhereUniqueInput
    data: XOR<OrganizationAccessUpdateWithoutUserInput, OrganizationAccessUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationAccessUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationAccessScalarWhereInput
    data: XOR<OrganizationAccessUpdateManyMutationInput, OrganizationAccessUncheckedUpdateManyWithoutOrganizationAccessInput>
  }

  export type EngagementDraftUpsertWithWhereUniqueWithoutUserInput = {
    where: EngagementDraftWhereUniqueInput
    update: XOR<EngagementDraftUpdateWithoutUserInput, EngagementDraftUncheckedUpdateWithoutUserInput>
    create: XOR<EngagementDraftCreateWithoutUserInput, EngagementDraftUncheckedCreateWithoutUserInput>
  }

  export type EngagementDraftUpdateWithWhereUniqueWithoutUserInput = {
    where: EngagementDraftWhereUniqueInput
    data: XOR<EngagementDraftUpdateWithoutUserInput, EngagementDraftUncheckedUpdateWithoutUserInput>
  }

  export type EngagementDraftUpdateManyWithWhereWithoutUserInput = {
    where: EngagementDraftScalarWhereInput
    data: XOR<EngagementDraftUpdateManyMutationInput, EngagementDraftUncheckedUpdateManyWithoutEngagementDraftInput>
  }

  export type EngagementDraftScalarWhereInput = {
    AND?: Enumerable<EngagementDraftScalarWhereInput>
    OR?: Enumerable<EngagementDraftScalarWhereInput>
    NOT?: Enumerable<EngagementDraftScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    engagementTitle?: StringNullableFilter | string | null
    engagementSummary?: StringNullableFilter | string | null
    associatedProgram?: StringNullableFilter | string | null
    soldierInput?: StringNullableFilter | string | null
    soldiersNeeded?: StringNullableFilter | string | null
    preferredDivision?: StringNullableFilter | string | null
    mos?: StringNullableFilter | string | null
    requirements?: StringNullableListFilter
    armyImpact?: StringNullableFilter | string | null
    cft?: IntNullableFilter | number | null
    engagementRequest?: StringNullableFilter | string | null
    feedbackType?: StringNullableFilter | string | null
    eventStartDate?: DateTimeNullableFilter | Date | string | null
    eventEndDate?: DateTimeNullableFilter | Date | string | null
    eventTitle?: StringNullableFilter | string | null
    eventDescription?: StringNullableFilter | string | null
    dueDate?: DateTimeNullableFilter | Date | string | null
    dueDateTitle?: StringNullableFilter | string | null
    addressOne?: StringNullableFilter | string | null
    addressTwo?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    zip?: StringNullableFilter | string | null
    funding?: StringNullableFilter | string | null
    otherInfo?: StringNullableFilter | string | null
    requestorName?: StringNullableFilter | string | null
    requestorEmail?: StringNullableFilter | string | null
    requestorPhone?: StringNullableFilter | string | null
    requestorTitle?: StringNullableFilter | string | null
    requestorOrganization?: StringNullableFilter | string | null
    freeFormQuestion?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organization?: OrganizationCreateNestedOneWithoutUserInput
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementUncheckedCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type OrganizationCreateWithoutOrganizationAccessInput = {
    id?: string
    name: string
    user?: UserCreateNestedManyWithoutOrganizationInput
    engagement?: EngagementCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutOrganizationAccessInput = {
    id?: string
    name: string
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    engagement?: EngagementUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutOrganizationAccessInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOrganizationAccessInput, OrganizationUncheckedCreateWithoutOrganizationAccessInput>
  }

  export type UserCreateWithoutOrganizationAccessInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organization?: OrganizationCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationAccessInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementUncheckedCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationAccessInput, UserUncheckedCreateWithoutOrganizationAccessInput>
  }

  export type OrganizationUpsertWithoutOrganizationAccessInput = {
    update: XOR<OrganizationUpdateWithoutOrganizationAccessInput, OrganizationUncheckedUpdateWithoutOrganizationAccessInput>
    create: XOR<OrganizationCreateWithoutOrganizationAccessInput, OrganizationUncheckedCreateWithoutOrganizationAccessInput>
  }

  export type OrganizationUpdateWithoutOrganizationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutOrganizationInput
    engagement?: EngagementUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutOrganizationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutOrganizationInput
    engagement?: EngagementUncheckedUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutOrganizationAccessInput = {
    update: XOR<UserUpdateWithoutOrganizationAccessInput, UserUncheckedUpdateWithoutOrganizationAccessInput>
    create: XOR<UserCreateWithoutOrganizationAccessInput, UserUncheckedCreateWithoutOrganizationAccessInput>
  }

  export type UserUpdateWithoutOrganizationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneWithoutUserInput
    role?: RoleUpdateOneRequiredWithoutUsersInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrganizationAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUncheckedUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedUpdateManyWithoutUserInput
  }

  export type OrganizationCreateWithoutEngagementInput = {
    id?: string
    name: string
    user?: UserCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEngagementInput = {
    id?: string
    name: string
    user?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEngagementInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEngagementInput, OrganizationUncheckedCreateWithoutEngagementInput>
  }

  export type UserCreateWithoutEngagementInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organization?: OrganizationCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEngagementInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEngagementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEngagementInput, UserUncheckedCreateWithoutEngagementInput>
  }

  export type LocationCreateWithoutEngagementInput = {
    id?: string
    addressOne: string
    addressTwo?: string | null
    city: string
    state: string
    zip: number
  }

  export type LocationUncheckedCreateWithoutEngagementInput = {
    id?: string
    addressOne: string
    addressTwo?: string | null
    city: string
    state: string
    zip: number
  }

  export type LocationCreateOrConnectWithoutEngagementInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEngagementInput, LocationUncheckedCreateWithoutEngagementInput>
  }

  export type DemographicCreateWithoutEngagementInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    requirements?: RequirementCreateNestedManyWithoutDemographicsInput
  }

  export type DemographicUncheckedCreateWithoutEngagementInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    requirements?: RequirementUncheckedCreateNestedManyWithoutDemographicsInput
  }

  export type DemographicCreateOrConnectWithoutEngagementInput = {
    where: DemographicWhereUniqueInput
    create: XOR<DemographicCreateWithoutEngagementInput, DemographicUncheckedCreateWithoutEngagementInput>
  }

  export type EngagementDetailCreateWithoutEngagementInput = {
    id?: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails?: string | null
    otherInformation?: string | null
  }

  export type EngagementDetailUncheckedCreateWithoutEngagementInput = {
    id?: string
    title: string
    summary: string
    description: string
    associatedProgram: string
    armyImpact: string
    fundingDetails?: string | null
    otherInformation?: string | null
  }

  export type EngagementDetailCreateOrConnectWithoutEngagementInput = {
    where: EngagementDetailWhereUniqueInput
    create: XOR<EngagementDetailCreateWithoutEngagementInput, EngagementDetailUncheckedCreateWithoutEngagementInput>
  }

  export type CrossFunctionalTeamsCreateWithoutEngagementsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrossFunctionalTeamsUncheckedCreateWithoutEngagementsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrossFunctionalTeamsCreateOrConnectWithoutEngagementsInput = {
    where: CrossFunctionalTeamsWhereUniqueInput
    create: XOR<CrossFunctionalTeamsCreateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedCreateWithoutEngagementsInput>
  }

  export type RequestorInformationCreateWithoutEngagementInput = {
    id?: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
  }

  export type RequestorInformationUncheckedCreateWithoutEngagementInput = {
    id?: string
    name: string
    organization: string
    title: string
    email: string
    phone: string
  }

  export type RequestorInformationCreateOrConnectWithoutEngagementInput = {
    where: RequestorInformationWhereUniqueInput
    create: XOR<RequestorInformationCreateWithoutEngagementInput, RequestorInformationUncheckedCreateWithoutEngagementInput>
  }

  export type EventCreateWithoutEngagementInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutEngagementInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutEngagementInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEngagementInput, EventUncheckedCreateWithoutEngagementInput>
  }

  export type EventCreateManyEngagementInputEnvelope = {
    data: Enumerable<EventCreateManyEngagementInput>
    skipDuplicates?: boolean
  }

  export type DueDateCreateWithoutEngagementInput = {
    id?: string
    title: string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateUncheckedCreateWithoutEngagementInput = {
    id?: string
    title: string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateCreateOrConnectWithoutEngagementInput = {
    where: DueDateWhereUniqueInput
    create: XOR<DueDateCreateWithoutEngagementInput, DueDateUncheckedCreateWithoutEngagementInput>
  }

  export type DueDateCreateManyEngagementInputEnvelope = {
    data: Enumerable<DueDateCreateManyEngagementInput>
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutEngagementInput = {
    id?: string
    engagementDraft?: EngagementDraftCreateNestedOneWithoutFilesInput
    blobName: string
    containerName: string
    path: string
  }

  export type FileUncheckedCreateWithoutEngagementInput = {
    id?: string
    engagementDraftId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type FileCreateOrConnectWithoutEngagementInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutEngagementInput, FileUncheckedCreateWithoutEngagementInput>
  }

  export type FileCreateManyEngagementInputEnvelope = {
    data: Enumerable<FileCreateManyEngagementInput>
    skipDuplicates?: boolean
  }

  export type FeedbackConfigCreateWithoutEngagementInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    testFeedbackSubmissions?: TestFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUncheckedCreateWithoutEngagementInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigCreateOrConnectWithoutEngagementInput = {
    where: FeedbackConfigWhereUniqueInput
    create: XOR<FeedbackConfigCreateWithoutEngagementInput, FeedbackConfigUncheckedCreateWithoutEngagementInput>
  }

  export type OrganizationUpsertWithoutEngagementInput = {
    update: XOR<OrganizationUpdateWithoutEngagementInput, OrganizationUncheckedUpdateWithoutEngagementInput>
    create: XOR<OrganizationCreateWithoutEngagementInput, OrganizationUncheckedCreateWithoutEngagementInput>
  }

  export type OrganizationUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUpdateManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutOrganizationInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutOrganizationInput
  }

  export type UserUpsertWithoutEngagementInput = {
    update: XOR<UserUpdateWithoutEngagementInput, UserUncheckedUpdateWithoutEngagementInput>
    create: XOR<UserCreateWithoutEngagementInput, UserUncheckedCreateWithoutEngagementInput>
  }

  export type UserUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneWithoutUserInput
    role?: RoleUpdateOneRequiredWithoutUsersInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedUpdateManyWithoutUserInput
  }

  export type LocationUpsertWithoutEngagementInput = {
    update: XOR<LocationUpdateWithoutEngagementInput, LocationUncheckedUpdateWithoutEngagementInput>
    create: XOR<LocationCreateWithoutEngagementInput, LocationUncheckedCreateWithoutEngagementInput>
  }

  export type LocationUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type LocationUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressOne?: StringFieldUpdateOperationsInput | string
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: IntFieldUpdateOperationsInput | number
  }

  export type DemographicUpsertWithoutEngagementInput = {
    update: XOR<DemographicUpdateWithoutEngagementInput, DemographicUncheckedUpdateWithoutEngagementInput>
    create: XOR<DemographicCreateWithoutEngagementInput, DemographicUncheckedCreateWithoutEngagementInput>
  }

  export type DemographicUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    requirements?: RequirementUpdateManyWithoutDemographicsInput
  }

  export type DemographicUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    requirements?: RequirementUncheckedUpdateManyWithoutDemographicsInput
  }

  export type EngagementDetailUpsertWithoutEngagementInput = {
    update: XOR<EngagementDetailUpdateWithoutEngagementInput, EngagementDetailUncheckedUpdateWithoutEngagementInput>
    create: XOR<EngagementDetailCreateWithoutEngagementInput, EngagementDetailUncheckedCreateWithoutEngagementInput>
  }

  export type EngagementDetailUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDetailUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    associatedProgram?: StringFieldUpdateOperationsInput | string
    armyImpact?: StringFieldUpdateOperationsInput | string
    fundingDetails?: NullableStringFieldUpdateOperationsInput | string | null
    otherInformation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrossFunctionalTeamsUpsertWithoutEngagementsInput = {
    update: XOR<CrossFunctionalTeamsUpdateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedUpdateWithoutEngagementsInput>
    create: XOR<CrossFunctionalTeamsCreateWithoutEngagementsInput, CrossFunctionalTeamsUncheckedCreateWithoutEngagementsInput>
  }

  export type CrossFunctionalTeamsUpdateWithoutEngagementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrossFunctionalTeamsUncheckedUpdateWithoutEngagementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestorInformationUpsertWithoutEngagementInput = {
    update: XOR<RequestorInformationUpdateWithoutEngagementInput, RequestorInformationUncheckedUpdateWithoutEngagementInput>
    create: XOR<RequestorInformationCreateWithoutEngagementInput, RequestorInformationUncheckedCreateWithoutEngagementInput>
  }

  export type RequestorInformationUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type RequestorInformationUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpsertWithWhereUniqueWithoutEngagementInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutEngagementInput, EventUncheckedUpdateWithoutEngagementInput>
    create: XOR<EventCreateWithoutEngagementInput, EventUncheckedCreateWithoutEngagementInput>
  }

  export type EventUpdateWithWhereUniqueWithoutEngagementInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutEngagementInput, EventUncheckedUpdateWithoutEngagementInput>
  }

  export type EventUpdateManyWithWhereWithoutEngagementInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventScalarWhereInput = {
    AND?: Enumerable<EventScalarWhereInput>
    OR?: Enumerable<EventScalarWhereInput>
    NOT?: Enumerable<EventScalarWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    title?: StringFilter | string
    description?: StringFilter | string
    engagementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DueDateUpsertWithWhereUniqueWithoutEngagementInput = {
    where: DueDateWhereUniqueInput
    update: XOR<DueDateUpdateWithoutEngagementInput, DueDateUncheckedUpdateWithoutEngagementInput>
    create: XOR<DueDateCreateWithoutEngagementInput, DueDateUncheckedCreateWithoutEngagementInput>
  }

  export type DueDateUpdateWithWhereUniqueWithoutEngagementInput = {
    where: DueDateWhereUniqueInput
    data: XOR<DueDateUpdateWithoutEngagementInput, DueDateUncheckedUpdateWithoutEngagementInput>
  }

  export type DueDateUpdateManyWithWhereWithoutEngagementInput = {
    where: DueDateScalarWhereInput
    data: XOR<DueDateUpdateManyMutationInput, DueDateUncheckedUpdateManyWithoutDueDatesInput>
  }

  export type DueDateScalarWhereInput = {
    AND?: Enumerable<DueDateScalarWhereInput>
    OR?: Enumerable<DueDateScalarWhereInput>
    NOT?: Enumerable<DueDateScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    dueDate?: DateTimeFilter | Date | string
    engagementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FileUpsertWithWhereUniqueWithoutEngagementInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutEngagementInput, FileUncheckedUpdateWithoutEngagementInput>
    create: XOR<FileCreateWithoutEngagementInput, FileUncheckedCreateWithoutEngagementInput>
  }

  export type FileUpdateWithWhereUniqueWithoutEngagementInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutEngagementInput, FileUncheckedUpdateWithoutEngagementInput>
  }

  export type FileUpdateManyWithWhereWithoutEngagementInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFilesInput>
  }

  export type FileScalarWhereInput = {
    AND?: Enumerable<FileScalarWhereInput>
    OR?: Enumerable<FileScalarWhereInput>
    NOT?: Enumerable<FileScalarWhereInput>
    id?: StringFilter | string
    engagementId?: StringNullableFilter | string | null
    engagementDraftId?: StringNullableFilter | string | null
    blobName?: StringFilter | string
    containerName?: StringFilter | string
    path?: StringFilter | string
  }

  export type FeedbackConfigUpsertWithoutEngagementInput = {
    update: XOR<FeedbackConfigUpdateWithoutEngagementInput, FeedbackConfigUncheckedUpdateWithoutEngagementInput>
    create: XOR<FeedbackConfigCreateWithoutEngagementInput, FeedbackConfigUncheckedCreateWithoutEngagementInput>
  }

  export type FeedbackConfigUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    testFeedbackSubmissions?: TestFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementCreateWithoutLocationInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutLocationInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutLocationInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
  }

  export type EngagementUpsertWithoutLocationInput = {
    update: XOR<EngagementUpdateWithoutLocationInput, EngagementUncheckedUpdateWithoutLocationInput>
    create: XOR<EngagementCreateWithoutLocationInput, EngagementUncheckedCreateWithoutLocationInput>
  }

  export type EngagementUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateWithoutEngagementDetailInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutEngagementDetailInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutEngagementDetailInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
  }

  export type EngagementUpsertWithoutEngagementDetailInput = {
    update: XOR<EngagementUpdateWithoutEngagementDetailInput, EngagementUncheckedUpdateWithoutEngagementDetailInput>
    create: XOR<EngagementCreateWithoutEngagementDetailInput, EngagementUncheckedCreateWithoutEngagementDetailInput>
  }

  export type EngagementUpdateWithoutEngagementDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutEngagementDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateWithoutCrossFunctionalTeamInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutCrossFunctionalTeamInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutCrossFunctionalTeamInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutCrossFunctionalTeamInput, EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>
  }

  export type EngagementCreateManyCrossFunctionalTeamInputEnvelope = {
    data: Enumerable<EngagementCreateManyCrossFunctionalTeamInput>
    skipDuplicates?: boolean
  }

  export type EngagementUpsertWithWhereUniqueWithoutCrossFunctionalTeamInput = {
    where: EngagementWhereUniqueInput
    update: XOR<EngagementUpdateWithoutCrossFunctionalTeamInput, EngagementUncheckedUpdateWithoutCrossFunctionalTeamInput>
    create: XOR<EngagementCreateWithoutCrossFunctionalTeamInput, EngagementUncheckedCreateWithoutCrossFunctionalTeamInput>
  }

  export type EngagementUpdateWithWhereUniqueWithoutCrossFunctionalTeamInput = {
    where: EngagementWhereUniqueInput
    data: XOR<EngagementUpdateWithoutCrossFunctionalTeamInput, EngagementUncheckedUpdateWithoutCrossFunctionalTeamInput>
  }

  export type EngagementUpdateManyWithWhereWithoutCrossFunctionalTeamInput = {
    where: EngagementScalarWhereInput
    data: XOR<EngagementUpdateManyMutationInput, EngagementUncheckedUpdateManyWithoutEngagementsInput>
  }

  export type EngagementCreateWithoutDemographicInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutDemographicInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutDemographicInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
  }

  export type RequirementCreateWithoutDemographicsInput = {
    id?: string
    content: string
  }

  export type RequirementUncheckedCreateWithoutDemographicsInput = {
    id?: string
    content: string
  }

  export type RequirementCreateOrConnectWithoutDemographicsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutDemographicsInput, RequirementUncheckedCreateWithoutDemographicsInput>
  }

  export type EngagementUpsertWithoutDemographicInput = {
    update: XOR<EngagementUpdateWithoutDemographicInput, EngagementUncheckedUpdateWithoutDemographicInput>
    create: XOR<EngagementCreateWithoutDemographicInput, EngagementUncheckedCreateWithoutDemographicInput>
  }

  export type EngagementUpdateWithoutDemographicInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutDemographicInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementUpsertWithWhereUniqueWithoutDemographicsInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutDemographicsInput, RequirementUncheckedUpdateWithoutDemographicsInput>
    create: XOR<RequirementCreateWithoutDemographicsInput, RequirementUncheckedCreateWithoutDemographicsInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutDemographicsInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutDemographicsInput, RequirementUncheckedUpdateWithoutDemographicsInput>
  }

  export type RequirementUpdateManyWithWhereWithoutDemographicsInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutRequirementsInput>
  }

  export type RequirementScalarWhereInput = {
    AND?: Enumerable<RequirementScalarWhereInput>
    OR?: Enumerable<RequirementScalarWhereInput>
    NOT?: Enumerable<RequirementScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
  }

  export type DemographicCreateWithoutRequirementsInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    engagement?: EngagementCreateNestedOneWithoutDemographicInput
  }

  export type DemographicUncheckedCreateWithoutRequirementsInput = {
    id?: string
    soldierInput: string
    soldiersNeeded: number
    mos: string
    engagement?: EngagementUncheckedCreateNestedOneWithoutDemographicInput
  }

  export type DemographicCreateOrConnectWithoutRequirementsInput = {
    where: DemographicWhereUniqueInput
    create: XOR<DemographicCreateWithoutRequirementsInput, DemographicUncheckedCreateWithoutRequirementsInput>
  }

  export type DemographicUpsertWithWhereUniqueWithoutRequirementsInput = {
    where: DemographicWhereUniqueInput
    update: XOR<DemographicUpdateWithoutRequirementsInput, DemographicUncheckedUpdateWithoutRequirementsInput>
    create: XOR<DemographicCreateWithoutRequirementsInput, DemographicUncheckedCreateWithoutRequirementsInput>
  }

  export type DemographicUpdateWithWhereUniqueWithoutRequirementsInput = {
    where: DemographicWhereUniqueInput
    data: XOR<DemographicUpdateWithoutRequirementsInput, DemographicUncheckedUpdateWithoutRequirementsInput>
  }

  export type DemographicUpdateManyWithWhereWithoutRequirementsInput = {
    where: DemographicScalarWhereInput
    data: XOR<DemographicUpdateManyMutationInput, DemographicUncheckedUpdateManyWithoutDemographicsInput>
  }

  export type DemographicScalarWhereInput = {
    AND?: Enumerable<DemographicScalarWhereInput>
    OR?: Enumerable<DemographicScalarWhereInput>
    NOT?: Enumerable<DemographicScalarWhereInput>
    id?: StringFilter | string
    soldierInput?: StringFilter | string
    soldiersNeeded?: IntFilter | number
    mos?: StringFilter | string
  }

  export type EngagementCreateWithoutRequestorInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutRequestorInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutRequestorInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
  }

  export type EngagementUpsertWithoutRequestorInput = {
    update: XOR<EngagementUpdateWithoutRequestorInput, EngagementUncheckedUpdateWithoutRequestorInput>
    create: XOR<EngagementCreateWithoutRequestorInput, EngagementUncheckedCreateWithoutRequestorInput>
  }

  export type EngagementUpdateWithoutRequestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutRequestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateWithoutEventsInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutEventsInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutEventsInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutEventsInput, EngagementUncheckedCreateWithoutEventsInput>
  }

  export type EngagementUpsertWithoutEventsInput = {
    update: XOR<EngagementUpdateWithoutEventsInput, EngagementUncheckedUpdateWithoutEventsInput>
    create: XOR<EngagementCreateWithoutEventsInput, EngagementUncheckedCreateWithoutEventsInput>
  }

  export type EngagementUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateWithoutDueDatesInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutDueDatesInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutDueDatesInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutDueDatesInput, EngagementUncheckedCreateWithoutDueDatesInput>
  }

  export type EngagementUpsertWithoutDueDatesInput = {
    update: XOR<EngagementUpdateWithoutDueDatesInput, EngagementUncheckedUpdateWithoutDueDatesInput>
    create: XOR<EngagementCreateWithoutDueDatesInput, EngagementUncheckedCreateWithoutDueDatesInput>
  }

  export type EngagementUpdateWithoutDueDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutDueDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementCreateWithoutFeedbackConfigInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    files?: FileCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutFeedbackConfigInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    files?: FileUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutFeedbackConfigInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionCreateWithoutFeedbackConfigInput = {
    id?: string
    rating: string
    testFeedbackResponses: TestFeedbackResponsesCreateNestedOneWithoutTestFeedbackInput
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput = {
    id?: string
    rating: string
    testFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput = {
    where: TestFeedbackSubmissionWhereUniqueInput
    create: XOR<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput, TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope = {
    data: Enumerable<TestFeedbackSubmissionCreateManyFeedbackConfigInput>
    skipDuplicates?: boolean
  }

  export type InputFeedbackSubmissionCreateWithoutFeedbackConfigInput = {
    id?: string
    inputFeedbackResponses: InputFeedbackResponsesCreateNestedOneWithoutInputFeedbackInput
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput = {
    id?: string
    inputFeedbackResponseId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput = {
    where: InputFeedbackSubmissionWhereUniqueInput
    create: XOR<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput, InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type InputFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope = {
    data: Enumerable<InputFeedbackSubmissionCreateManyFeedbackConfigInput>
    skipDuplicates?: boolean
  }

  export type FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput = {
    id?: string
    freeFeedbackResponses: FreeFeedbackResponsesCreateNestedOneWithoutFreeFeedbackInput
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput = {
    id?: string
    freeFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionCreateOrConnectWithoutFeedbackConfigInput = {
    where: FreeFeedbackSubmissionWhereUniqueInput
    create: XOR<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput, FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type FreeFeedbackSubmissionCreateManyFeedbackConfigInputEnvelope = {
    data: Enumerable<FreeFeedbackSubmissionCreateManyFeedbackConfigInput>
    skipDuplicates?: boolean
  }

  export type EngagementUpsertWithoutFeedbackConfigInput = {
    update: XOR<EngagementUpdateWithoutFeedbackConfigInput, EngagementUncheckedUpdateWithoutFeedbackConfigInput>
    create: XOR<EngagementCreateWithoutFeedbackConfigInput, EngagementUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type EngagementUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput = {
    where: TestFeedbackSubmissionWhereUniqueInput
    update: XOR<TestFeedbackSubmissionUpdateWithoutFeedbackConfigInput, TestFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
    create: XOR<TestFeedbackSubmissionCreateWithoutFeedbackConfigInput, TestFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput = {
    where: TestFeedbackSubmissionWhereUniqueInput
    data: XOR<TestFeedbackSubmissionUpdateWithoutFeedbackConfigInput, TestFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
  }

  export type TestFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput = {
    where: TestFeedbackSubmissionScalarWhereInput
    data: XOR<TestFeedbackSubmissionUpdateManyMutationInput, TestFeedbackSubmissionUncheckedUpdateManyWithoutTestFeedbackSubmissionsInput>
  }

  export type TestFeedbackSubmissionScalarWhereInput = {
    AND?: Enumerable<TestFeedbackSubmissionScalarWhereInput>
    OR?: Enumerable<TestFeedbackSubmissionScalarWhereInput>
    NOT?: Enumerable<TestFeedbackSubmissionScalarWhereInput>
    id?: StringFilter | string
    feedbackConfigId?: StringFilter | string
    rating?: StringFilter | string
    testFeedbackResponseId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InputFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput = {
    where: InputFeedbackSubmissionWhereUniqueInput
    update: XOR<InputFeedbackSubmissionUpdateWithoutFeedbackConfigInput, InputFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
    create: XOR<InputFeedbackSubmissionCreateWithoutFeedbackConfigInput, InputFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type InputFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput = {
    where: InputFeedbackSubmissionWhereUniqueInput
    data: XOR<InputFeedbackSubmissionUpdateWithoutFeedbackConfigInput, InputFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
  }

  export type InputFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput = {
    where: InputFeedbackSubmissionScalarWhereInput
    data: XOR<InputFeedbackSubmissionUpdateManyMutationInput, InputFeedbackSubmissionUncheckedUpdateManyWithoutInputFeedbackSubmissionsInput>
  }

  export type InputFeedbackSubmissionScalarWhereInput = {
    AND?: Enumerable<InputFeedbackSubmissionScalarWhereInput>
    OR?: Enumerable<InputFeedbackSubmissionScalarWhereInput>
    NOT?: Enumerable<InputFeedbackSubmissionScalarWhereInput>
    id?: StringFilter | string
    feedbackConfigId?: StringFilter | string
    inputFeedbackResponseId?: StringFilter | string
    rating?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type FreeFeedbackSubmissionUpsertWithWhereUniqueWithoutFeedbackConfigInput = {
    where: FreeFeedbackSubmissionWhereUniqueInput
    update: XOR<FreeFeedbackSubmissionUpdateWithoutFeedbackConfigInput, FreeFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
    create: XOR<FreeFeedbackSubmissionCreateWithoutFeedbackConfigInput, FreeFeedbackSubmissionUncheckedCreateWithoutFeedbackConfigInput>
  }

  export type FreeFeedbackSubmissionUpdateWithWhereUniqueWithoutFeedbackConfigInput = {
    where: FreeFeedbackSubmissionWhereUniqueInput
    data: XOR<FreeFeedbackSubmissionUpdateWithoutFeedbackConfigInput, FreeFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput>
  }

  export type FreeFeedbackSubmissionUpdateManyWithWhereWithoutFeedbackConfigInput = {
    where: FreeFeedbackSubmissionScalarWhereInput
    data: XOR<FreeFeedbackSubmissionUpdateManyMutationInput, FreeFeedbackSubmissionUncheckedUpdateManyWithoutFreeFeedbackSubmissionsInput>
  }

  export type FreeFeedbackSubmissionScalarWhereInput = {
    AND?: Enumerable<FreeFeedbackSubmissionScalarWhereInput>
    OR?: Enumerable<FreeFeedbackSubmissionScalarWhereInput>
    NOT?: Enumerable<FreeFeedbackSubmissionScalarWhereInput>
    id?: StringFilter | string
    feedbackConfigId?: StringFilter | string
    freeFeedbackResponseId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    rating?: StringFilter | string
  }

  export type FeedbackConfigCreateWithoutTestFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementCreateNestedOneWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUncheckedCreateWithoutTestFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementUncheckedCreateNestedOneWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigCreateOrConnectWithoutTestFeedbackSubmissionsInput = {
    where: FeedbackConfigWhereUniqueInput
    create: XOR<FeedbackConfigCreateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutTestFeedbackSubmissionsInput>
  }

  export type TestFeedbackResponsesCreateWithoutTestFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackResponsesUncheckedCreateWithoutTestFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    results: string
    anticipatedResults: string
    conditionsConstraints: string
    metExpectations: string
    notMetExpectations: string
    otherOpportunities: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackResponsesCreateOrConnectWithoutTestFeedbackInput = {
    where: TestFeedbackResponsesWhereUniqueInput
    create: XOR<TestFeedbackResponsesCreateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedCreateWithoutTestFeedbackInput>
  }

  export type FeedbackConfigUpsertWithoutTestFeedbackSubmissionsInput = {
    update: XOR<FeedbackConfigUpdateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutTestFeedbackSubmissionsInput>
    create: XOR<FeedbackConfigCreateWithoutTestFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutTestFeedbackSubmissionsInput>
  }

  export type FeedbackConfigUpdateWithoutTestFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUpdateOneWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateWithoutTestFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUncheckedUpdateOneWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesUpsertWithoutTestFeedbackInput = {
    update: XOR<TestFeedbackResponsesUpdateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedUpdateWithoutTestFeedbackInput>
    create: XOR<TestFeedbackResponsesCreateWithoutTestFeedbackInput, TestFeedbackResponsesUncheckedCreateWithoutTestFeedbackInput>
  }

  export type TestFeedbackResponsesUpdateWithoutTestFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackResponsesUncheckedUpdateWithoutTestFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    results?: StringFieldUpdateOperationsInput | string
    anticipatedResults?: StringFieldUpdateOperationsInput | string
    conditionsConstraints?: StringFieldUpdateOperationsInput | string
    metExpectations?: StringFieldUpdateOperationsInput | string
    notMetExpectations?: StringFieldUpdateOperationsInput | string
    otherOpportunities?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutTestFeedbackSubmissionsInput
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput = {
    id?: string
    feedbackConfigId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestFeedbackSubmissionCreateOrConnectWithoutTestFeedbackResponsesInput = {
    where: TestFeedbackSubmissionWhereUniqueInput
    create: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
  }

  export type TestFeedbackSubmissionUpsertWithoutTestFeedbackResponsesInput = {
    update: XOR<TestFeedbackSubmissionUpdateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedUpdateWithoutTestFeedbackResponsesInput>
    create: XOR<TestFeedbackSubmissionCreateWithoutTestFeedbackResponsesInput, TestFeedbackSubmissionUncheckedCreateWithoutTestFeedbackResponsesInput>
  }

  export type TestFeedbackSubmissionUpdateWithoutTestFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutTestFeedbackSubmissionsInput
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionUncheckedUpdateWithoutTestFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigCreateWithoutInputFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUncheckedCreateWithoutInputFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementUncheckedCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigCreateOrConnectWithoutInputFeedbackSubmissionsInput = {
    where: FeedbackConfigWhereUniqueInput
    create: XOR<FeedbackConfigCreateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutInputFeedbackSubmissionsInput>
  }

  export type InputFeedbackResponsesCreateWithoutInputFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackResponsesUncheckedCreateWithoutInputFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    customResponse?: string | null
    opportunities: string
    processSolution: string
    notAsked: string
    responseViews: string
    additionalThoughts?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackResponsesCreateOrConnectWithoutInputFeedbackInput = {
    where: InputFeedbackResponsesWhereUniqueInput
    create: XOR<InputFeedbackResponsesCreateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedCreateWithoutInputFeedbackInput>
  }

  export type FeedbackConfigUpsertWithoutInputFeedbackSubmissionsInput = {
    update: XOR<FeedbackConfigUpdateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutInputFeedbackSubmissionsInput>
    create: XOR<FeedbackConfigCreateWithoutInputFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutInputFeedbackSubmissionsInput>
  }

  export type FeedbackConfigUpdateWithoutInputFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateWithoutInputFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUncheckedUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFeedbackSubmissions?: FreeFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesUpsertWithoutInputFeedbackInput = {
    update: XOR<InputFeedbackResponsesUpdateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedUpdateWithoutInputFeedbackInput>
    create: XOR<InputFeedbackResponsesCreateWithoutInputFeedbackInput, InputFeedbackResponsesUncheckedCreateWithoutInputFeedbackInput>
  }

  export type InputFeedbackResponsesUpdateWithoutInputFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackResponsesUncheckedUpdateWithoutInputFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customResponse?: NullableStringFieldUpdateOperationsInput | string | null
    opportunities?: StringFieldUpdateOperationsInput | string
    processSolution?: StringFieldUpdateOperationsInput | string
    notAsked?: StringFieldUpdateOperationsInput | string
    responseViews?: StringFieldUpdateOperationsInput | string
    additionalThoughts?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutInputFeedbackSubmissionsInput
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput = {
    id?: string
    feedbackConfigId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionCreateOrConnectWithoutInputFeedbackResponsesInput = {
    where: InputFeedbackSubmissionWhereUniqueInput
    create: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
  }

  export type InputFeedbackSubmissionUpsertWithoutInputFeedbackResponsesInput = {
    update: XOR<InputFeedbackSubmissionUpdateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedUpdateWithoutInputFeedbackResponsesInput>
    create: XOR<InputFeedbackSubmissionCreateWithoutInputFeedbackResponsesInput, InputFeedbackSubmissionUncheckedCreateWithoutInputFeedbackResponsesInput>
  }

  export type InputFeedbackSubmissionUpdateWithoutInputFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutInputFeedbackSubmissionsInput
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUncheckedUpdateWithoutInputFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigCreateWithoutFreeFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigUncheckedCreateWithoutFreeFeedbackSubmissionsInput = {
    id?: string
    feedbackType: FeedbackTypes
    isHumanResearch: boolean
    hasSubmissions: boolean
    engagement?: EngagementUncheckedCreateNestedOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedCreateNestedManyWithoutFeedbackConfigInput
    freeFormQuestion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackConfigCreateOrConnectWithoutFreeFeedbackSubmissionsInput = {
    where: FeedbackConfigWhereUniqueInput
    create: XOR<FeedbackConfigCreateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutFreeFeedbackSubmissionsInput>
  }

  export type FreeFeedbackResponsesCreateWithoutFreeFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackResponsesUncheckedCreateWithoutFreeFeedbackInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    response: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackResponsesCreateOrConnectWithoutFreeFeedbackInput = {
    where: FreeFeedbackResponsesWhereUniqueInput
    create: XOR<FreeFeedbackResponsesCreateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedCreateWithoutFreeFeedbackInput>
  }

  export type FeedbackConfigUpsertWithoutFreeFeedbackSubmissionsInput = {
    update: XOR<FeedbackConfigUpdateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedUpdateWithoutFreeFeedbackSubmissionsInput>
    create: XOR<FeedbackConfigCreateWithoutFreeFeedbackSubmissionsInput, FeedbackConfigUncheckedCreateWithoutFreeFeedbackSubmissionsInput>
  }

  export type FeedbackConfigUpdateWithoutFreeFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackConfigUncheckedUpdateWithoutFreeFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypesFieldUpdateOperationsInput | FeedbackTypes
    isHumanResearch?: BoolFieldUpdateOperationsInput | boolean
    hasSubmissions?: BoolFieldUpdateOperationsInput | boolean
    engagement?: EngagementUncheckedUpdateOneWithoutFeedbackConfigInput
    testFeedbackSubmissions?: TestFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    inputFeedbackSubmissions?: InputFeedbackSubmissionUncheckedUpdateManyWithoutFeedbackConfigInput
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackResponsesUpsertWithoutFreeFeedbackInput = {
    update: XOR<FreeFeedbackResponsesUpdateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedUpdateWithoutFreeFeedbackInput>
    create: XOR<FreeFeedbackResponsesCreateWithoutFreeFeedbackInput, FreeFeedbackResponsesUncheckedCreateWithoutFreeFeedbackInput>
  }

  export type FreeFeedbackResponsesUpdateWithoutFreeFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackResponsesUncheckedUpdateWithoutFreeFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput = {
    id?: string
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutFreeFeedbackSubmissionsInput
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput = {
    id?: string
    feedbackConfigId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type FreeFeedbackSubmissionCreateOrConnectWithoutFreeFeedbackResponsesInput = {
    where: FreeFeedbackSubmissionWhereUniqueInput
    create: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
  }

  export type FreeFeedbackSubmissionUpsertWithoutFreeFeedbackResponsesInput = {
    update: XOR<FreeFeedbackSubmissionUpdateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedUpdateWithoutFreeFeedbackResponsesInput>
    create: XOR<FreeFeedbackSubmissionCreateWithoutFreeFeedbackResponsesInput, FreeFeedbackSubmissionUncheckedCreateWithoutFreeFeedbackResponsesInput>
  }

  export type FreeFeedbackSubmissionUpdateWithoutFreeFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfig?: FeedbackConfigUpdateOneWithoutFreeFeedbackSubmissionsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionUncheckedUpdateWithoutFreeFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedbackConfigId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type EngagementCreateWithoutFilesInput = {
    id?: string
    organization: OrganizationCreateNestedOneWithoutEngagementInput
    user: UserCreateNestedOneWithoutEngagementInput
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEngagementInput
    demographic: DemographicCreateNestedOneWithoutEngagementInput
    engagementDetail: EngagementDetailCreateNestedOneWithoutEngagementInput
    status: string
    crossFunctionalTeam: CrossFunctionalTeamsCreateNestedOneWithoutEngagementsInput
    requestor: RequestorInformationCreateNestedOneWithoutEngagementInput
    events?: EventCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfig?: FeedbackConfigCreateNestedOneWithoutEngagementInput
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUncheckedCreateWithoutFilesInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    events?: EventUncheckedCreateNestedManyWithoutEngagementInput
    dueDates?: DueDateUncheckedCreateNestedManyWithoutEngagementInput
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementCreateOrConnectWithoutFilesInput = {
    where: EngagementWhereUniqueInput
    create: XOR<EngagementCreateWithoutFilesInput, EngagementUncheckedCreateWithoutFilesInput>
  }

  export type EngagementDraftCreateWithoutFilesInput = {
    id?: string
    user: UserCreateNestedOneWithoutEngagementDraftInput
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftUncheckedCreateWithoutFilesInput = {
    id?: string
    userId: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementDraftCreateOrConnectWithoutFilesInput = {
    where: EngagementDraftWhereUniqueInput
    create: XOR<EngagementDraftCreateWithoutFilesInput, EngagementDraftUncheckedCreateWithoutFilesInput>
  }

  export type EngagementUpsertWithoutFilesInput = {
    update: XOR<EngagementUpdateWithoutFilesInput, EngagementUncheckedUpdateWithoutFilesInput>
    create: XOR<EngagementCreateWithoutFilesInput, EngagementUncheckedCreateWithoutFilesInput>
  }

  export type EngagementUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementDraftUpsertWithoutFilesInput = {
    update: XOR<EngagementDraftUpdateWithoutFilesInput, EngagementDraftUncheckedUpdateWithoutFilesInput>
    create: XOR<EngagementDraftCreateWithoutFilesInput, EngagementDraftUncheckedCreateWithoutFilesInput>
  }

  export type EngagementDraftUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEngagementDraftInput
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutEngagementDraftInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organization?: OrganizationCreateNestedOneWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEngagementDraftInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    engagement?: EngagementUncheckedCreateNestedManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEngagementDraftInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEngagementDraftInput, UserUncheckedCreateWithoutEngagementDraftInput>
  }

  export type FileCreateWithoutEngagementDraftInput = {
    id?: string
    engagement?: EngagementCreateNestedOneWithoutFilesInput
    blobName: string
    containerName: string
    path: string
  }

  export type FileUncheckedCreateWithoutEngagementDraftInput = {
    id?: string
    engagementId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type FileCreateOrConnectWithoutEngagementDraftInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutEngagementDraftInput, FileUncheckedCreateWithoutEngagementDraftInput>
  }

  export type FileCreateManyEngagementDraftInputEnvelope = {
    data: Enumerable<FileCreateManyEngagementDraftInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEngagementDraftInput = {
    update: XOR<UserUpdateWithoutEngagementDraftInput, UserUncheckedUpdateWithoutEngagementDraftInput>
    create: XOR<UserCreateWithoutEngagementDraftInput, UserUncheckedCreateWithoutEngagementDraftInput>
  }

  export type UserUpdateWithoutEngagementDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneWithoutUserInput
    role?: RoleUpdateOneRequiredWithoutUsersInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutEngagementDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUncheckedUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutUserInput
  }

  export type FileUpsertWithWhereUniqueWithoutEngagementDraftInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutEngagementDraftInput, FileUncheckedUpdateWithoutEngagementDraftInput>
    create: XOR<FileCreateWithoutEngagementDraftInput, FileUncheckedCreateWithoutEngagementDraftInput>
  }

  export type FileUpdateWithWhereUniqueWithoutEngagementDraftInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutEngagementDraftInput, FileUncheckedUpdateWithoutEngagementDraftInput>
  }

  export type FileUpdateManyWithWhereWithoutEngagementDraftInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFilesInput>
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementCreateManyOrganizationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type OrganizationAccessCreateManyOrganizationInput = {
    userId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutUsersInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUncheckedUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateManyWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationAccessUpdateWithoutOrganizationInput = {
    user?: UserUpdateOneRequiredWithoutOrganizationAccessInput
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessUncheckedUpdateWithoutOrganizationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessUncheckedUpdateManyWithoutOrganizationAccessInput = {
    userId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementCreateManyUserInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    crossFunctionalTeamId: number
    requestorId: string
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type OrganizationAccessCreateManyUserInput = {
    organizationId: string
    read?: boolean
    write?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementDraftCreateManyUserInput = {
    id?: string
    engagementTitle?: string | null
    engagementSummary?: string | null
    associatedProgram?: string | null
    soldierInput?: string | null
    soldiersNeeded?: string | null
    preferredDivision?: string | null
    mos?: string | null
    requirements?: EngagementDraftCreaterequirementsInput | Enumerable<string>
    armyImpact?: string | null
    cft?: number | null
    engagementRequest?: string | null
    feedbackType?: string | null
    eventStartDate?: Date | string | null
    eventEndDate?: Date | string | null
    eventTitle?: string | null
    eventDescription?: string | null
    dueDate?: Date | string | null
    dueDateTitle?: string | null
    addressOne?: string | null
    addressTwo?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    funding?: string | null
    otherInfo?: string | null
    requestorName?: string | null
    requestorEmail?: string | null
    requestorPhone?: string | null
    requestorTitle?: string | null
    requestorOrganization?: string | null
    freeFormQuestion?: string | null
  }

  export type EngagementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeam?: CrossFunctionalTeamsUpdateOneRequiredWithoutEngagementsInput
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    crossFunctionalTeamId?: IntFieldUpdateOperationsInput | number
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationAccessUpdateWithoutUserInput = {
    organization?: OrganizationUpdateOneRequiredWithoutOrganizationAccessInput
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationAccessUncheckedUpdateWithoutUserInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    write?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementDraftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUpdateManyWithoutEngagementDraftInput
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutEngagementDraftInput
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EngagementDraftUncheckedUpdateManyWithoutEngagementDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementTitle?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSummary?: NullableStringFieldUpdateOperationsInput | string | null
    associatedProgram?: NullableStringFieldUpdateOperationsInput | string | null
    soldierInput?: NullableStringFieldUpdateOperationsInput | string | null
    soldiersNeeded?: NullableStringFieldUpdateOperationsInput | string | null
    preferredDivision?: NullableStringFieldUpdateOperationsInput | string | null
    mos?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: EngagementDraftUpdaterequirementsInput | Enumerable<string>
    armyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    cft?: NullableIntFieldUpdateOperationsInput | number | null
    engagementRequest?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackType?: NullableStringFieldUpdateOperationsInput | string | null
    eventStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventTitle?: NullableStringFieldUpdateOperationsInput | string | null
    eventDescription?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDateTitle?: NullableStringFieldUpdateOperationsInput | string | null
    addressOne?: NullableStringFieldUpdateOperationsInput | string | null
    addressTwo?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    funding?: NullableStringFieldUpdateOperationsInput | string | null
    otherInfo?: NullableStringFieldUpdateOperationsInput | string | null
    requestorName?: NullableStringFieldUpdateOperationsInput | string | null
    requestorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    requestorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    requestorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    requestorOrganization?: NullableStringFieldUpdateOperationsInput | string | null
    freeFormQuestion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyRoleInput = {
    id?: string
    firstName: string
    lastName: string
    initials: string
    email: string
    password: string
    organizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneWithoutUserInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagement?: EngagementUncheckedUpdateManyWithoutUserInput
    organizationAccess?: OrganizationAccessUncheckedUpdateManyWithoutUserInput
    EngagementDraft?: EngagementDraftUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    initials?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyEngagementInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDateCreateManyEngagementInput = {
    id?: string
    title: string
    dueDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateManyEngagementInput = {
    id?: string
    engagementDraftId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type EventUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDateUncheckedUpdateManyWithoutDueDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementDraft?: EngagementDraftUpdateOneWithoutFilesInput
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateWithoutEngagementInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateManyWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementDraftId?: NullableStringFieldUpdateOperationsInput | string | null
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type EngagementCreateManyCrossFunctionalTeamInput = {
    id?: string
    organizationId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locationId?: string | null
    demographicId: string
    engagementDetailId: string
    status: string
    requestorId: string
    shortId?: string | null
    feedbackConfigId?: string | null
    isDeleted?: boolean
    statusChangedOn?: Date | string | null
  }

  export type EngagementUpdateWithoutCrossFunctionalTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization?: OrganizationUpdateOneRequiredWithoutEngagementInput
    user?: UserUpdateOneRequiredWithoutEngagementInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEngagementInput
    demographic?: DemographicUpdateOneRequiredWithoutEngagementInput
    engagementDetail?: EngagementDetailUpdateOneRequiredWithoutEngagementInput
    status?: StringFieldUpdateOperationsInput | string
    requestor?: RequestorInformationUpdateOneRequiredWithoutEngagementInput
    events?: EventUpdateManyWithoutEngagementInput
    dueDates?: DueDateUpdateManyWithoutEngagementInput
    files?: FileUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfig?: FeedbackConfigUpdateOneWithoutEngagementInput
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateWithoutCrossFunctionalTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutEngagementInput
    dueDates?: DueDateUncheckedUpdateManyWithoutEngagementInput
    files?: FileUncheckedUpdateManyWithoutEngagementInput
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EngagementUncheckedUpdateManyWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    demographicId?: StringFieldUpdateOperationsInput | string
    engagementDetailId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestorId?: StringFieldUpdateOperationsInput | string
    shortId?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    statusChangedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementUpdateWithoutDemographicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RequirementUncheckedUpdateWithoutDemographicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RequirementUncheckedUpdateManyWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type DemographicUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutDemographicInput
  }

  export type DemographicUncheckedUpdateWithoutRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUncheckedUpdateOneWithoutDemographicInput
  }

  export type DemographicUncheckedUpdateManyWithoutDemographicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    soldierInput?: StringFieldUpdateOperationsInput | string
    soldiersNeeded?: IntFieldUpdateOperationsInput | number
    mos?: StringFieldUpdateOperationsInput | string
  }

  export type TestFeedbackSubmissionCreateManyFeedbackConfigInput = {
    id?: string
    rating: string
    testFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InputFeedbackSubmissionCreateManyFeedbackConfigInput = {
    id?: string
    inputFeedbackResponseId: string
    rating: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreeFeedbackSubmissionCreateManyFeedbackConfigInput = {
    id?: string
    freeFeedbackResponseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rating: string
  }

  export type TestFeedbackSubmissionUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponses?: TestFeedbackResponsesUpdateOneRequiredWithoutTestFeedbackInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestFeedbackSubmissionUncheckedUpdateManyWithoutTestFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    testFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputFeedbackResponses?: InputFeedbackResponsesUpdateOneRequiredWithoutInputFeedbackInput
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InputFeedbackSubmissionUncheckedUpdateManyWithoutInputFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inputFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    rating?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreeFeedbackSubmissionUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    freeFeedbackResponses?: FreeFeedbackResponsesUpdateOneRequiredWithoutFreeFeedbackInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionUncheckedUpdateWithoutFeedbackConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    freeFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FreeFeedbackSubmissionUncheckedUpdateManyWithoutFreeFeedbackSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    freeFeedbackResponseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManyEngagementDraftInput = {
    id?: string
    engagementId?: string | null
    blobName: string
    containerName: string
    path: string
  }

  export type FileUpdateWithoutEngagementDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagement?: EngagementUpdateOneWithoutFilesInput
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateWithoutEngagementDraftInput = {
    id?: StringFieldUpdateOperationsInput | string
    engagementId?: NullableStringFieldUpdateOperationsInput | string | null
    blobName?: StringFieldUpdateOperationsInput | string
    containerName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}